
# === Archivo: nova_erp_total_combined.py ===

# --- /home/runner/workspace/nova_erp_total/wsgi.py ---
"""
WSGI config for nova_erp_total project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'nova_erp_total.settings')

application = get_wsgi_application()



# --- /home/runner/workspace/nova_erp_total/__init__.py ---



# --- /home/runner/workspace/nova_erp_total/asgi.py ---
"""
ASGI config for nova_erp_total project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'nova_erp_total.settings')

application = get_asgi_application()



# --- /home/runner/workspace/nova_erp_total/urls.py ---
from django.contrib import admin
from django.urls import path, include
from rest_framework.permissions import AllowAny
from django.http import JsonResponse
from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView

def ping(request):
    return JsonResponse({"status": "ok", "message": "Nova ERP API is running"})

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/ping/', ping),

    # Rutas globales API core
    path('api/', include('core.api.urls')),

    # Rutas específicas de apps
    path('api/auth/', include('accounts.urls')),
    path('auth/', include('social_django.urls', namespace='social')),

    # Documentación y esquema
    path('api/schema/', SpectacularAPIView.as_view(permission_classes=[AllowAny]), name='schema'),
    path('api/docs/', SpectacularSwaggerView.as_view(url_name='schema', permission_classes=[AllowAny]), name='swagger-ui'),

    # **Importar las rutas de inventario correctamente** 
    path('api/inventory/', include('inventario.urls')),  # Esto es lo que estaba comentado

    # *** Aquí agregas las rutas de ventas ***
    path('api/sales/', include('ventas.urls')),

    path('api/core/', include('core.urls')),

    path('api/purchases/', include('compras.urls')),

    path('api/finanzas/', include('finanzas.urls')),

    path('api/contabilidad/', include('contabilidad.urls')),

    path('api/facturacion/', include('facturacion.urls')),
]




# --- /home/runner/workspace/nova_erp_total/settings.py ---
"""
Django settings for nova_erp_total project.

Generated by 'django-admin startproject' using Django 5.0.2.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path
from datetime import timedelta

import os

# import sentry_sdk
# from sentry_sdk.integrations.django import DjangoIntegration
# Build paths inside the project like this: BASE_DIR / 'subdir'.

BASE_DIR = Path(__file__).resolve().parent.parent

import sentry_sdk
import base64

sentry_sdk.init(
    dsn=
    "https://59a6b3f5a097d60c09ff94e6a517e6f4@o4509617180311552.ingest.us.sentry.io/4509617183981568",
    # Add data like request headers and IP for users,
    # see https://docs.sentry.io/platforms/python/data-management/data-collected/ for more info
    send_default_pii=True,
)

ALLOWED_IPS = ['190.10.20.30', '10.0.0.1']  # oficina, cliente


class IPWhitelistMiddleware:

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        ip = request.META.get('REMOTE_ADDR')
        if ip not in ALLOWED_IPS:
            from django.http import HttpResponseForbidden
            return HttpResponseForbidden("IP no autorizada")
        return self.get_response(request)


# sentry_sdk.init(
#     dsn="https://tu_clave@o0.ingest.sentry.io/proyecto-id",
#     integrations=[DjangoIntegration()],
#     traces_sample_rate=1.0,  # o 0.1 para producción
#     send_default_pii=True,
# )

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-qamg-)bhge&qtj+!*ayn4+*vp6=u708^1^$nu5hf7#1refr+do'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'social_django',
    'accounts.apps.AccountsConfig',
    'django_extensions',
    # Apps locales
    # 'accounts',
    'inventario',
    # 'ventas',
    'ventas.apps.VentasConfig',
    'compras',
    'finanzas',
    # 'contabilidad',
    'contabilidad.apps.ContabilidadConfig',
    'rrhh',
    'documentos',
    'core',
    'facturacion',

    # REST Framework y JWT
    'rest_framework',
    'rest_framework_simplejwt.token_blacklist',
    'corsheaders',
]
FACTURAMA_USER = "EKU9003173C9222"
FACTURAMA_PASSWORD = "Losy990209bn7"
# FACTURAMA_API_URL = "https://apisandbox.facturama.mx/3/cfdis/3.3/"
FACTURAMA_API_URL = "https://apisandbox.facturama.mx/3/cfdis"

# FACTURAMA_API_URL = "https://api.facturama.mx"  # o sandbox si estás probando
# FACTURAMA_CREDENTIALS = f"<Base64 {FACTURAMA_USER}:{FACTURAMA_PASSWORD}>"
FACTURAMA_CREDENTIALS = base64.b64encode(f"{FACTURAMA_USER}:{FACTURAMA_PASSWORD}".encode()).decode()


INSTALLED_APPS += ['django_filters', 'drf_spectacular']

AUTH_USER_MODEL = 'accounts.Usuario'

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',

    # CORS
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',

    #AUDITARIA MIDDLEWARE
    'core.middleware.auditoria.AuditoriaMiddleware',
    'social_django.middleware.SocialAuthExceptionMiddleware',
]

REST_FRAMEWORK = {
    'DEFAULT_FILTER_BACKENDS':
    ['django_filters.rest_framework.DjangoFilterBackend'],
    'DEFAULT_PAGINATION_CLASS':
    'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE':
    25,  # Páginas de 20 resultados
    'DEFAULT_AUTHENTICATION_CLASSES':
    ('rest_framework_simplejwt.authentication.JWTAuthentication', ),
    'DEFAULT_PERMISSION_CLASSES':
    ('rest_framework.permissions.IsAuthenticated', ),
    # 'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
    'DEFAULT_SCHEMA_CLASS':
    'accounts.schema.CustomAutoSchema',
    #CIBERCEGURIDAD VS FUERZA BRUTA
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.UserRateThrottle',
        'rest_framework.throttling.AnonRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        'user': '100/minute',  # ajusta según tu tráfico real
        'anon': '10/minute',  # no autenticados (login, reset)
        'login': '5/minute',  # 👈 solo para login
    },
}

SPECTACULAR_SETTINGS = {
    'TITLE': 'Nova ERP API',
    'DESCRIPTION': 'Documentación de la API del sistema Nova ERP',
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA':
    True,  # 👈 Esta línea permite conectar correctamente con /docs/
    'SCHEMA_PATH_PREFIX': '/api/schema/',
    'PARSER_CLASSES': ['drf_spectacular.parsers.YAMLParser'],
    'RENDERER_CLASSES': ['drf_spectacular.renderers.YAMLRenderer'],
}

# settings.py DESPUES SE DESCOMENTARA CON LOGINS CREO
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'DEBUG',
    },
}

SIMPLE_JWT = {
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': 'secret_key_here',
    # 'ACCESS_TOKEN_LIFETIME': timedelta(days=1),        # antes: 5 minutos
    # 'REFRESH_TOKEN_LIFETIME': timedelta(days=30),      # antes: 1 día
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
}

DEBUG = True

if DEBUG:
    SIMPLE_JWT['ACCESS_TOKEN_LIFETIME'] = timedelta(days=1)
    SIMPLE_JWT['REFRESH_TOKEN_LIFETIME'] = timedelta(days=30)
else:
    SIMPLE_JWT['ACCESS_TOKEN_LIFETIME'] = timedelta(minutes=5)
    SIMPLE_JWT['REFRESH_TOKEN_LIFETIME'] = timedelta(days=1)

AUTHENTICATION_BACKENDS = (
    'social_core.backends.google.GoogleOAuth2',
    'social_core.backends.microsoft.MicrosoftOAuth2',
    'django.contrib.auth.backends.ModelBackend',
)

SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = '1039784506241-ehqp78nga5sh3rkumrii0ltkgcd46bph.apps.googleusercontent.com'
SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = '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'

CORS_ALLOW_ALL_ORIGINS = True

ROOT_URLCONF = 'nova_erp_total.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'social_django.context_processors.backends',  # Agrega esta línea
                'social_django.context_processors.login_redirect',  # Y esta
            ],
        },
    },
]

WSGI_APPLICATION = 'nova_erp_total.wsgi.application'

# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME':
        'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME':
        'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME':
        'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME':
        'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = '<tu-client-id-google>'
SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = '<tu-client-secret-google>'

SOCIAL_AUTH_MICROSOFT_KEY = '<tu-client-id-microsoft>'
SOCIAL_AUTH_MICROSOFT_SECRET = '<tu-client-secret-microsoft>'

CSRF_TRUSTED_ORIGINS = [
    "https://fca3faea-e64a-4f83-a448-762fa6e71df4-00-1kkfg9j97gplb.spock.replit.dev",
    # puedes agregar más orígenes si usas otros subdominios o entornos
]

# --------------------------------------------------------------------------------
# Cabeceras HTTP seguras (anti XSS, Clickjacking, etc.)
# --------------------------------------------------------------------------------
# Protege contra XSS
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True

# Previene que tu sitio sea cargado en un iframe (clickjacking)
X_FRAME_OPTIONS = 'DENY'

# Política del encabezado Referer
SECURE_REFERRER_POLICY = 'same-origin'

# Seguridad estricta solo si usas HTTPS
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# Cookies seguras si usas JWT en cookies (no aplica por default)
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True


# Permite solo tu frontend (React, Vue, etc.)
CORS_ALLOWED_ORIGINS = [
    "https://fca3faea-e64a-4f83-a448-762fa6e71df4-00-1kkfg9j97gplb.spock.replit.dev",
    "https://tusitio-frontend.com",
    "https://erpcliente.com",
]

# Evita permitir todos los orígenes (¡no usar en producción!)
CORS_ALLOW_ALL_ORIGINS = False

# Métodos permitidos
CORS_ALLOW_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"]

# Headers permitidos
CORS_ALLOW_HEADERS = [
    "authorization",
    "content-type",
    "accept",
    "origin",
    "user-agent",
]



EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = 'yaview.lomeli@gmail.com'
EMAIL_HOST_PASSWORD = 'ncvs lfro srke goiq'
DEFAULT_FROM_EMAIL = 'Nova_erp_api <yaview.lomeli@gmail.com>'





# === Archivo: accounts_combined.py ===

# --- /home/runner/workspace/accounts/__init__.py ---



# --- /home/runner/workspace/accounts/filters.py ---
# accounts/filters.py
import django_filters
from accounts.models import Auditoria

class AuditoriaFilter(django_filters.FilterSet):
    fecha_inicio = django_filters.DateTimeFilter(field_name='timestamp', lookup_expr='gte')
    fecha_fin = django_filters.DateTimeFilter(field_name='timestamp', lookup_expr='lte')

    class Meta:
        model = Auditoria
        fields = {
            'usuario__username': ['exact', 'icontains'],
            'accion': ['exact', 'icontains'],
            'tabla_afectada': ['exact', 'icontains'],
        }



# --- /home/runner/workspace/accounts/admin.py ---
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import Group, Permission
from accounts.models import Usuario, Rol, Auditoria

# 🔐 Usuario Admin
@admin.register(Usuario)
class UsuarioAdmin(BaseUserAdmin):
    list_display = ('username', 'email', 'empresa', 'rol', 'is_active', 'last_login')
    list_filter = ('rol', 'empresa', 'is_active', 'is_superuser')
    search_fields = ('username', 'email', 'rol__nombre', 'empresa__nombre')
    ordering = ('username',)

    fieldsets = (
        (None, {'fields': ('username', 'password')}),
        ('Información Personal', {'fields': ('email', 'empresa', 'rol')}),
        ('Permisos del Sistema', {
            'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions'),
        }),
        ('Accesos y Registro', {'fields': ('last_login', 'date_joined')}),
    )

    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('username', 'email', 'empresa', 'rol', 'password1', 'password2',
                       'is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions'),
        }),
    )

# 🔧 Rol Admin
@admin.register(Rol)
class RolAdmin(admin.ModelAdmin):
    list_display = ('nombre', 'descripcion')
    search_fields = ('nombre',)
    ordering = ('nombre',)

# 🕵️ Auditoría Admin (Solo lectura)
@admin.register(Auditoria)
class AuditoriaAdmin(admin.ModelAdmin):
    list_display = ('usuario', 'accion', 'tabla_afectada', 'registro_afectado', 'timestamp')
    list_filter = ('accion', 'tabla_afectada', 'timestamp')
    search_fields = ('usuario__username', 'accion', 'tabla_afectada', 'registro_afectado')
    readonly_fields = ('usuario', 'accion', 'tabla_afectada', 'registro_afectado', 'timestamp')

    def has_add_permission(self, request):
        return False

    def has_delete_permission(self, request, obj=None):
        return False

# ✅ Permitir gestionar permisos y grupos desde el admin
admin.site.unregister(Group)
@admin.register(Group)
class GroupAdmin(admin.ModelAdmin):
    list_display = ('name',)
    search_fields = ('name',)
    filter_horizontal = ('permissions',)

@admin.register(Permission)
class PermissionAdmin(admin.ModelAdmin):
    list_display = ('name', 'codename', 'content_type')
    list_filter = ('content_type',)
    search_fields = ('name', 'codename')


# # accounts/admin.py
# from django.contrib import admin
# from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
# from accounts.models import Usuario, Rol, Auditoria

# @admin.register(Usuario)
# class UsuarioAdmin(BaseUserAdmin):
#     list_display = ('username', 'email', 'empresa', 'rol')  # elimina is_staff, is_active
#     list_filter = ('rol', 'empresa')  # elimina is_staff, is_active

#     # Campos para el formulario de edición
#     fieldsets = (
#         (None, {'fields': ('username', 'password')}),
#         ('Información Personal', {'fields': ('email', 'empresa', 'rol')}),
#         ('Permisos', {'fields': ('is_staff', 'is_active', 'is_superuser', 'groups', 'user_permissions')}),
#         ('Fechas importantes', {'fields': ('last_login', 'date_joined')}),
#     )

#     # Campos que se usarán para crear usuario
#     add_fieldsets = (
#         (None, {
#             'classes': ('wide',),
#             'fields': ('username', 'email', 'empresa', 'rol', 'password1', 'password2', 'is_staff', 'is_active')}
#         ),
#     )

#     search_fields = ('username', 'email')
#     ordering = ('username',)

# @admin.register(Rol)
# class RolAdmin(admin.ModelAdmin):
#     list_display = ('nombre', 'descripcion')
#     list_display = ('nombre', 'descripcion')


# @admin.register(Auditoria)
# class AuditoriaAdmin(admin.ModelAdmin):
#     list_display = ('usuario', 'accion', 'tabla_afectada', 'timestamp')
#     list_filter = ('accion', 'tabla_afectada', 'timestamp')
#     search_fields = ('usuario__username', 'accion', 'tabla_afectada', 'registro_afectado')
#     readonly_fields = ('usuario', 'accion', 'tabla_afectada', 'registro_afectado', 'timestamp')

#     def has_add_permission(self, request):
#         return False  # No se permite agregar registros manualmente

#     def has_delete_permission(self, request, obj=None):
#         return False  # Opcional: impedir borrar registros para mantener integridad


# --- /home/runner/workspace/accounts/signals.py ---
# accounts/signals.py

from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.utils.timezone import now
from django.contrib.contenttypes.models import ContentType
from accounts.models import Auditoria, Usuario
from django.conf import settings
import threading
from django.contrib.auth.models import Group
from accounts.models import Usuario

# Hilo-local para almacenar temporalmente el usuario
_local = threading.local()

def set_audit_user(user):
    _local.user = user

def get_audit_user():
    return getattr(_local, 'user', None)


def registrar_auditoria(instance, accion):
    modelo = instance.__class__.__name__
    usuario = get_audit_user()
    if not usuario or not isinstance(usuario, Usuario):
        return

    Auditoria.objects.create(
        usuario=usuario,
        accion=accion,
        tabla_afectada=modelo,
        registro_afectado=str(instance)
    )

# --- Señales globales ---

@receiver(post_save)
def auditoria_crear_modificar(sender, instance, created, **kwargs):
    if sender._meta.app_label in ['accounts', 'ventas', 'compras', 'inventario']:
        accion = "CREADO" if created else "MODIFICADO"
        registrar_auditoria(instance, accion)

@receiver(post_delete)
def auditoria_eliminar(sender, instance, **kwargs):
    if sender._meta.app_label in ['accounts', 'ventas', 'compras', 'inventario']:
        registrar_auditoria(instance, "ELIMINADO")

@receiver(post_save, sender=Usuario)
def sync_user_group(sender, instance, **kwargs):
    if instance.rol:
        group, created = Group.objects.get_or_create(name=instance.rol.nombre)
        instance.groups.set([group])
    else:
        instance.groups.clear()


# --- /home/runner/workspace/accounts/apps.py ---
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

    def ready(self):
        import accounts.signals  # conecta señales


# --- /home/runner/workspace/accounts/urls.py ---
# accounts/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter

# Importación de vistas por módulos
from accounts.views import auth, profile, password_reset, mfa, audit, users
from accounts.views.roles import RoleViewSet 
from accounts.views.users import UsuarioViewSet
from accounts.views.audit import AuditLogListView, AuditLogExportCSV
from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView
from .views.mfa import MFAEnableView, MFAVerifyView, MFADisableView, MFALoginVerifyView

from accounts.views.groups import GroupViewSet
from accounts.views.permissions import PermissionViewSet



# Rutas registradas con router para vistas basadas en ViewSet
router = DefaultRouter()
router.register(r'users', UsuarioViewSet, basename='usuarios')
router.register(r'roles', RoleViewSet )
router.register(r'groups', GroupViewSet, basename='group')
router.register(r'permissions', PermissionViewSet, basename='permission')

# Lista de URLs explícitas
urlpatterns = [
                           

    # --- Autenticación ---
    path('login/', auth.LoginView.as_view(), name='login'),                        # POST - Iniciar sesión
    path('logout/', auth.LogoutView.as_view(), name='logout'),                     # POST - Cerrar sesión
    path('register/', auth.RegisterView.as_view(), name='register'),               # POST - Registro de usuario
    path('refresh/', auth.RefreshTokenView.as_view(), name='token-refresh'),       # POST - Refrescar token JWT

    # --- Perfil de usuario ---
    path('profile/', profile.ProfileView.as_view(), name='profile'),               # GET/PUT - Ver o editar perfil

    # --- Recuperación de contraseña ---
    path('password-reset/request/', password_reset.PasswordResetRequestView.as_view(), name='password-reset-request'),  # POST - Solicitar reinicio
    path('password-reset/confirm/', password_reset.PasswordResetConfirmView.as_view(), name='password-reset-confirm'),
    # path('password-reset/confirm/', password_reset.PasswordResetConfirmView.as_view(), name='password-reset-confirm'),  # POST - Confirmar reinicio

    # --- Autenticación de dos factores (2FA) ---
    path('2fa/verify-login/', MFALoginVerifyView.as_view(), name='mfa-verify-login'),  # POST - Verificar 2FA en login
    path('2fa/enable/', MFAEnableView.as_view(), name='mfa-enable'),                   # POST - Habilitar 2FA
    path('2fa/verify/', MFAVerifyView.as_view(), name='mfa-verify'),                   # POST - Verificar código 2FA
    path('2fa/disable/', MFADisableView.as_view(), name='mfa-disable'),                # POST - Deshabilitar 2FA

    # --- Actividad del usuario ---
    path('activity/', audit.ActivityLogView.as_view(), name='activity-log'),                # GET - Ver actividad

    # --- Auditoría ---
    path('audit-log/', AuditLogListView.as_view(), name='audit-log-list'),                  # GET - Lista de logs de auditoría
    path('audit-log/export-csv/', AuditLogExportCSV.as_view(), name='audit-log-export-csv'),# GET - Exportar logs como CSV


    path('', include(router.urls)),

]

# urlpatterns += router.urls



# --- /home/runner/workspace/accounts/schema.py ---
from drf_spectacular.openapi import AutoSchema
from drf_spectacular.utils import OpenApiResponse

class CustomAutoSchema(AutoSchema):
    def get_responses(self):
        responses = super().get_responses()

        common_errors = {
            '400': OpenApiResponse(description='Bad Request'),
            '401': OpenApiResponse(description='Unauthorized'),
            '403': OpenApiResponse(description='Forbidden'),
            '404': OpenApiResponse(description='Not Found'),
            '500': OpenApiResponse(description='Internal Server Error'),
        }

        # Solo agregar los errores que no estén ya
        for code, response in common_errors.items():
            if code not in responses:
                responses[code] = response

        return responses


# from drf_spectacular.utils import extend_schema_view, extend_schema, OpenApiResponse
# from rest_framework import viewsets

# @extend_schema_view(
#     post=extend_schema(
#         summary="Login",
#         description="Autenticación con JWT",
#         responses={
#             200: OpenApiResponse(description="Login exitoso"),
#             400: OpenApiResponse(description="Datos inválidos"),
#             401: OpenApiResponse(description="Credenciales incorrectas"),
#             500: OpenApiResponse(description="Error interno"),
#         },
#     ),
#     get=extend_schema(
#         summary="Ver perfil",
#         description="Datos del usuario autenticado",
#         responses={
#             200: OpenApiResponse(description="Datos del usuario"),
#             401: OpenApiResponse(description="Token inválido o no enviado"),
#         },
#     ),
# )
# class AuthViewSet(viewsets.ViewSet):
#     pass



# --- /home/runner/workspace/accounts/constants.py ---
# accounts/constants.py

class Roles:
    SUPERADMIN = "Superadministrador"
    ADMIN_EMPRESA = "Administrador de Empresa"
    VENDEDOR = "Vendedor"
    INVENTARIO = "Almacén / Inventario"
    COMPRAS = "Compras / Proveedores"
    CONTADOR = "Contador"
    TESORERO = "Tesorero / Finanzas"
    RH = "Recursos Humanos"
    AUDITOR = "Auditor / Legal"
    CLIENTE = "Cliente externo"


# --- /home/runner/workspace/accounts/permissions.py ---
# accounts/permissions.py

from rest_framework.permissions import BasePermission, SAFE_METHODS
from accounts.constants import Roles

class IsEmpleado(BasePermission):
    def has_permission(self, request, view):
        return (
            request.user.is_authenticated and
            request.user.rol and
            request.user.rol.nombre == "Empleado"
        )


class IsSuperAdminOrEmpresaAdminOrReadOnly(BasePermission):
    """
    Solo SuperAdmin puede eliminar, Admin Empresa puede crear y actualizar,
    otros roles solo lectura (GET)
    """
    def has_permission(self, request, view):
        user = request.user
        if not user.is_authenticated:
            return False

        if request.method in SAFE_METHODS:
            return True  # lectura para todos autenticados

        if request.method == 'DELETE':
            return user.rol.nombre == Roles.SUPERADMIN

        if request.method in ['POST', 'PUT', 'PATCH']:
            return user.rol.nombre in [Roles.SUPERADMIN, Roles.ADMIN_EMPRESA]

        return False


# 🔐 Permisos base por rol exacto (uno por clase)
class IsSuperAdmin(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.SUPERADMIN

class IsEmpresaAdmin(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.ADMIN_EMPRESA

class IsVendedor(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.VENDEDOR

class IsInventario(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.INVENTARIO

class IsCompras(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.COMPRAS

class IsContador(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.CONTADOR

class IsTesorero(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.TESORERO

class IsRecursosHumanos(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.RH

class IsAuditor(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.AUDITOR

class IsClienteExterno(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre == Roles.CLIENTE


# 🔁 Combinaciones comunes (útiles para reutilizar en muchas vistas)

class IsSuperAdminOrEmpresaAdmin(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre in [
            Roles.SUPERADMIN, Roles.ADMIN_EMPRESA
        ]

class IsSuperAdminOrVendedor(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre in [
            Roles.SUPERADMIN, Roles.VENDEDOR
        ]

class IsSuperAdminOrInventario(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre in [
            Roles.SUPERADMIN, Roles.INVENTARIO
        ]

class IsSuperAdminOrCompras(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre in [
            Roles.SUPERADMIN, Roles.COMPRAS
        ]

class IsSuperAdminOrContador(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre in [
            Roles.SUPERADMIN, Roles.CONTADOR
        ]

class IsSuperAdminOrTesorero(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre in [
            Roles.SUPERADMIN, Roles.TESORERO
        ]

class IsSuperAdminOrRecursosHumanos(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre in [
            Roles.SUPERADMIN, Roles.RH
        ]

class IsSuperAdminOrAuditor(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre in [
            Roles.SUPERADMIN, Roles.AUDITOR
        ]

class IsEmpresaAdminOrVendedor(BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.rol.nombre in [
            Roles.ADMIN_EMPRESA, Roles.VENDEDOR
        ]


# 🔀 Helper dinámico para múltiples combinaciones OR
def OrPermissions(*perms):
    class _OrPermission(BasePermission):
        def has_permission(self, request, view):
            return any(perm().has_permission(request, view) for perm in perms)
    return _OrPermission


# 🛡️ Permisos basados en codename de Django (add_modelo, view_modelo, etc.)
def CustomPermission(permiso_codename):
    class _CustomPermission(BasePermission):
        def has_permission(self, request, view):
            return request.user.is_authenticated and request.user.has_perm(permiso_codename)
    return _CustomPermission




class IsAdminOrReadOnly(BasePermission):
    """
    Permite solo lectura a usuarios normales.
    Permite lectura y escritura a SuperAdmin o AdminEmpresa.
    """
    def has_permission(self, request, view):
        # Si el método es seguro (GET, HEAD, OPTIONS), se permite a todos los autenticados
        if request.method in SAFE_METHODS:
            return request.user and request.user.is_authenticated

        # Si es escritura (POST, PUT, DELETE...), solo Admins
        return (
            request.user.is_authenticated and
            request.user.rol.nombre in ["Superadministrador", "Administrador"]
        )


# --- /home/runner/workspace/accounts/models.py ---
# accounts/models.py

from django.db import models
from django.utils import timezone
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, BaseUserManager
from core.models import Empresa
from django.conf import settings


# accounts/models.py

from django.core.exceptions import ValidationError


from django.db import models

from django.core.exceptions import ValidationError
from django.db import models

from django.contrib.auth.models import Group

class Auditoria(models.Model):
    usuario = models.ForeignKey(
        'Usuario', 
        null=True, blank=True,  # ← Permitir que sea opcional
        on_delete=models.SET_NULL,  # ← No eliminar auditorías si se borra el usuario
        related_name="auditorias"
    )
    username_intentado = models.CharField(
        max_length=150, 
        null=True, blank=True, 
        help_text="Nombre de usuario usado en caso de login fallido"
    )
    accion = models.CharField(max_length=255)
    tabla_afectada = models.CharField(max_length=255)
    registro_afectado = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = 'Auditoría'
        verbose_name_plural = 'Auditorías'
        ordering = ['-timestamp']

    def __str__(self):
        return f"{self.usuario or self.username_intentado} - {self.accion} ({self.timestamp})"

    def clean(self):
        if not self.usuario and not self.username_intentado:
            raise ValidationError("Debe proporcionarse 'usuario' o 'username_intentado'.")
        if not self.accion:
            raise ValidationError("El campo 'acción' es obligatorio.")
        if not self.tabla_afectada:
            raise ValidationError("El campo 'tabla_afectada' es obligatorio.")
        if not self.registro_afectado:
            raise ValidationError("El campo 'registro_afectado' es obligatorio.")




class Rol(models.Model):
    nombre = models.CharField(max_length=100, unique=True)
    descripcion = models.TextField(blank=True, null=True)
    grupo = models.OneToOneField(Group, on_delete=models.SET_NULL, null=True, blank=True)

    class Meta:
        verbose_name = "Rol"
        verbose_name_plural = "Roles"
        ordering = ['nombre']

    def __str__(self):
        return self.nombre


from django.contrib.auth.models import BaseUserManager

class UsuarioManager(BaseUserManager):
    def create_user(self, username, email=None, password=None, empresa=None, **extra_fields):
        if not empresa:
            raise ValueError("El campo empresa es obligatorio")
        if not username:
            raise ValueError('El usuario debe tener un nombre de usuario')
        email = self.normalize_email(email)

        # Aseguramos valores por defecto para los flags de estado
        extra_fields.setdefault('is_active', True)
        extra_fields.setdefault('activo', True)  # Si usas este campo personalizado
        extra_fields.setdefault('is_staff', False)
        extra_fields.setdefault('is_superuser', False)

        user = self.model(
            username=username,
            email=email,
            empresa=empresa,
            **extra_fields  # Pasa todos los campos extra para asignarlos directo
        )

        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, username, email=None, password=None, empresa=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True)
        extra_fields.setdefault('activo', True)

        if empresa is None:
            raise ValueError("El superusuario debe tener una empresa asignada")

        if extra_fields.get('is_staff') is not True:
            raise ValueError('El superusuario debe tener is_staff=True.')

        if extra_fields.get('is_superuser') is not True:
            raise ValueError('El superusuario debe tener is_superuser=True.')

        return self.create_user(username, email, password, empresa=empresa, **extra_fields)


class Usuario(AbstractBaseUser, PermissionsMixin):
    mfa_enabled = models.BooleanField(default=False)
    mfa_secret = models.CharField(max_length=32, blank=True, null=True)
    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE, related_name='usuarios')
    rol = models.ForeignKey(Rol, on_delete=models.SET_NULL, null=True, blank=True, related_name='usuarios')
    username = models.CharField(max_length=150, unique=True)
    email = models.EmailField(unique=True)
    # password = models.CharField(max_length=128)

    activo = models.BooleanField(default=True)  # si quieres mantenerlo aparte
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)

    fecha_creacion = models.DateTimeField(default=timezone.now)
    foto = models.URLField(blank=True, null=True)
    telefono = models.CharField(max_length=30, blank=True, null=True)
    direccion = models.TextField(blank=True, null=True)
    idioma = models.CharField(max_length=10, default='es')
    tema = models.CharField(max_length=50, default='claro')
    sucursal_actual = models.ForeignKey(
        'core.Sucursal',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='usuarios_actuales'
    )

    USERNAME_FIELD = 'username'
    REQUIRED_FIELDS = ['email']

    objects = UsuarioManager()

    class Meta:
        verbose_name = 'Usuario'
        verbose_name_plural = 'Usuarios'
        ordering = ['username']
        indexes = [
            models.Index(fields=['empresa', 'username']),
            models.Index(fields=['rol', 'activo']),
        ]

    @property
    def empresa_actual(self):
        # Simplemente devuelve la empresa asociada
        return self.empresa

    def __str__(self):
        empresa_nombre = self.empresa.nombre if self.empresa else "Sin empresa"
        return f"{self.username} ({self.email}) - {empresa_nombre}"

    # def __str__(self):
    #     empresa_nombre = self.empresa.nombre if self.empresa else "Sin empresa"
    #     return f"{self.username} ({self.email}) - {empresa_nombre}"

    def get_full_name(self):
        return self.username

    def get_short_name(self):
        return self.username




# --- /home/runner/workspace/accounts/views/__init__.py ---
from .auth import *
from .profile import *
from .password_reset import *
from .mfa import *
from .audit import *
from .users import *
from .roles import *


# --- /home/runner/workspace/accounts/views/groups.py ---
# 🧩 Django
from django.contrib.auth.models import Group

# 🛠️ Django REST Framework
from rest_framework import viewsets

# 📦 Serializers
from accounts.serializers.group_permission_serializers import GroupSerializer

# 🔐 Permisos personalizados
from accounts.permissions import IsSuperAdmin, CustomPermission


class GroupViewSet(viewsets.ModelViewSet):
    queryset = Group.objects.all()
    serializer_class = GroupSerializer

    def get_permissions(self):
        if self.action in ['create', 'update', 'partial_update', 'destroy']:
            # Solo SuperAdmin puede modificar grupos
            return [IsSuperAdmin()]
        elif self.action in ['list', 'retrieve']:
            # Ver grupos requiere permiso explícito de Django
            return [CustomPermission('auth.view_group')()]
        # Fallback seguro
        return [IsSuperAdmin()]

# from django.contrib.auth.models import Group
# from rest_framework import viewsets
# from rest_framework.permissions import IsAuthenticated

# from accounts.serializers.group_permission_serializers import GroupSerializer

# class GroupViewSet(viewsets.ModelViewSet):
#     queryset = Group.objects.all()
#     serializer_class = GroupSerializer
#     permission_classes = [IsAuthenticated]  # O usa tu CustomPermission



# --- /home/runner/workspace/accounts/views/mfa.py ---
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework_simplejwt.tokens import AccessToken, RefreshToken
from rest_framework_simplejwt.exceptions import TokenError
from datetime import timedelta
import pyotp

from accounts.models import Usuario
from accounts.serializers.mfa_serializers import (
    MFAEnableSerializer,
    MFAVerifySerializer,
    MFADisableSerializer
)
from accounts.serializers.user_serializers import UsuarioSerializer
from accounts.utils.auditoria import registrar_auditoria

# 🔐 Roles permitidos (definidos previamente en accounts.constants.Roles)
from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsEmpleado, IsAuditor


def generate_temp_token(user):
    access_token = AccessToken.for_user(user)
    access_token.set_exp(lifetime=timedelta(minutes=5))  # Token válido solo 5 minutos
    return str(access_token)


class MFAEnableView(APIView):
    permission_classes = [IsAuthenticated]  # Se puede reforzar con IsEmpresaAdmin | IsEmpleado
    serializer_class = MFAEnableSerializer

    def post(self, request):
        user = request.user
        if user.mfa_enabled:
            return Response({"detail": "MFA ya está activado."}, status=status.HTTP_400_BAD_REQUEST)

        secret = pyotp.random_base32()
        user.mfa_secret = secret
        user.save()

        otp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
            name=user.username,
            issuer_name="Nova ERP"
        )

        return Response({"otp_uri": otp_uri, "secret": secret})


class MFAVerifyView(APIView):
    permission_classes = [IsAuthenticated]
    serializer_class = MFAVerifySerializer

    def post(self, request):
        user = request.user
        serializer = MFAVerifySerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        code = serializer.validated_data['code']

        if not user.mfa_secret:
            return Response({"detail": "MFA no está configurado para este usuario."}, status=400)

        totp = pyotp.TOTP(user.mfa_secret)
        if totp.verify(code):
            user.mfa_enabled = True
            user.save()
            registrar_auditoria(user, "MFA_ACTIVADO", "Usuario", "MFA activado correctamente")
            return Response({"detail": "MFA activado correctamente."})

        registrar_auditoria(user, "MFA_FALLIDO", "Usuario", "Código MFA inválido")
        return Response({"detail": "Código MFA inválido. Intenta de nuevo."}, status=400)


class MFADisableView(APIView):
    permission_classes = [IsAuthenticated]  # Se puede reforzar con IsEmpresaAdmin | IsEmpleado
    serializer_class = MFADisableSerializer

    def post(self, request):
        user = request.user
        serializer = MFADisableSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        code = serializer.validated_data['code']

        if not user.mfa_enabled:
            return Response({"detail": "MFA no está activado."}, status=400)

        totp = pyotp.TOTP(user.mfa_secret)
        if totp.verify(code):
            user.mfa_enabled = False
            user.mfa_secret = ""
            user.save()
            registrar_auditoria(user, "MFA_DESACTIVADO", "Usuario", "MFA desactivado")
            return Response({"detail": "MFA desactivado correctamente."})

        return Response({"detail": "Código inválido."}, status=400)


class MFALoginVerifyView(APIView):
    permission_classes = [AllowAny]
    serializer_class = MFAVerifySerializer

    def post(self, request):
        token = request.data.get("temp_token")
        code = request.data.get("code")

        if not token or not code:
            return Response({"detail": "Datos incompletos"}, status=400)

        try:
            access_token = AccessToken(token)
            user_id = access_token['user_id']
            user = Usuario.objects.get(id=user_id)
        except TokenError as e:
            return Response({"detail": "Token inválido o expirado", "error": str(e)}, status=401)
        except KeyError:
            return Response({"detail": "Token mal formado"}, status=400)
        except Usuario.DoesNotExist:
            return Response({"detail": "Usuario no encontrado"}, status=404)

        if not user.mfa_secret:
            return Response({"detail": "2FA no habilitado para este usuario"}, status=400)

        totp = pyotp.TOTP(user.mfa_secret)
        if totp.verify(code):
            refresh = RefreshToken.for_user(user)
            return Response({
                'access': str(refresh.access_token),
                'refresh': str(refresh),
                'user': UsuarioSerializer(user).data
            })

        return Response({"detail": "Código MFA inválido"}, status=400)

# # from rest_framework.permissions import AllowAny
# # # Standard Library
# # from datetime import timedelta
# # import pyotp

# # # Django REST Framework
# # from rest_framework.views import APIView
# # from rest_framework.response import Response
# # from rest_framework.permissions import IsAuthenticated
# # from rest_framework import status
# # from rest_framework_simplejwt.tokens import AccessToken, RefreshToken
# # from rest_framework_simplejwt.exceptions import TokenError

# # # App local
# # from accounts.models import Usuario
# # from accounts.serializers.mfa_serializers import (
# #     MFAEnableSerializer,
# #     MFAVerifySerializer,
# #     MFADisableSerializer
# # )
# # from accounts.serializers.user_serializers import UsuarioSerializer
# # from accounts.utils.auditoria import registrar_auditoria

# # from rest_framework import serializers



# # def generate_temp_token(user):
# #     # Crear un AccessToken para el usuario
# #     access_token = AccessToken.for_user(user)
# #     # Aquí puedes agregar más datos si es necesario
# #     access_token.set_exp(lifetime=timedelta(minutes=5))  # Establecer un tiempo de expiración corto
# #     return str(access_token)

# # class MFAEnableView(APIView):
# #     permission_classes = [IsAuthenticated]
# #     serializer_class = MFAEnableSerializer

# #     def post(self, request):
# #         user = request.user
# #         if user.mfa_enabled:
# #             return Response({"detail": "MFA ya está activado."}, status=status.HTTP_400_BAD_REQUEST)

# #         # Generar nuevo secreto
# #         secret = pyotp.random_base32()
# #         user.mfa_secret = secret
# #         user.save()

# #         # Generar URL para QR (otpauth)
# #         otp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
# #             name=user.username, issuer_name="Nova ERP"
# #         )

# #         return Response({
# #             "otp_uri": otp_uri,
# #             "secret": secret,  # opcional mostrar clave manualmente
# #         })

# # class MFAVerifyView(APIView):
# #     permission_classes = [IsAuthenticated]
# #     serializer_class = MFAVerifySerializer
    
# #     def post(self, request):
# #         user = request.user
# #         serializer = MFAVerifySerializer(data=request.data)

# #         # Verificar que los datos del serializer son válidos
# #         serializer.is_valid(raise_exception=True)

# #         # Obtener el código MFA del serializer
# #         code = serializer.validated_data['code']

# #         # Verificar si el usuario tiene configurado MFA
# #         if not user.mfa_secret:
# #             return Response(
# #                 {"detail": "MFA no está configurado para este usuario."}, 
# #                 status=status.HTTP_400_BAD_REQUEST
# #             )

# #         # Generar el objeto TOTP y verificar el código
# #         totp = pyotp.TOTP(user.mfa_secret)
# #         if totp.verify(code):
# #             # Si el código es válido, habilitar MFA para el usuario
# #             user.mfa_enabled = True
# #             user.save()

# #             # Registrar la auditoría para activación exitosa
# #             registrar_auditoria(user, "MFA_ACTIVADO", "Usuario", "MFA activado correctamente")

# #             return Response({"detail": "MFA activado correctamente."})
# #         else:
# #             # Registrar la auditoría para intento fallido
# #             registrar_auditoria(user, "MFA_FALLIDO", "Usuario", "Código MFA inválido")

# #             return Response(
# #                 {"detail": "Código MFA inválido. Por favor, intente nuevamente."}, 
# #                 status=status.HTTP_400_BAD_REQUEST
# #             )



# # class MFADisableView(APIView):
# #     permission_classes = [IsAuthenticated]
# #     serializer_class = MFADisableSerializer

# #     def post(self, request):
# #         user = request.user
# #         serializer = MFADisableSerializer(data=request.data)
# #         serializer.is_valid(raise_exception=True)

# #         code = serializer.validated_data['code']
# #         if not user.mfa_enabled:
# #             return Response({"detail": "MFA no está activado."}, status=status.HTTP_400_BAD_REQUEST)

# #         totp = pyotp.TOTP(user.mfa_secret)
# #         if totp.verify(code):
# #             user.mfa_enabled = False
# #             user.mfa_secret = ""
# #             user.save()
# #             registrar_auditoria(user, "MFA_DESACTIVADO", "Usuario", "MFA desactivado")
# #             return Response({"detail": "MFA desactivado correctamente."})
# #         else:
# #             return Response({"detail": "Código inválido."}, status=status.HTTP_400_BAD_REQUEST)




# # class MFALoginVerifyView(APIView):
# #     permission_classes = [AllowAny]
# #     serializer_class = MFAVerifySerializer

# #     def post(self, request):
# #         token = request.data.get("temp_token")
# #         code = request.data.get("code")

# #         if not token or not code:
# #             return Response({"detail": "Datos incompletos"}, status=400)

# #         try:
# #             access_token = AccessToken(token)
# #             user_id = access_token['user_id']
# #             user = Usuario.objects.get(id=user_id)
# #         except TokenError as e:
# #             return Response({"detail": "Token inválido o expirado", "error": str(e)}, status=401)
# #         except KeyError:
# #             return Response({"detail": "Token mal formado"}, status=400)
# #         except Usuario.DoesNotExist:
# #             return Response({"detail": "Usuario no encontrado"}, status=404)

# #         if not user.mfa_secret:
# #             return Response({"detail": "2FA no habilitado para este usuario"}, status=400)

# #         totp = pyotp.TOTP(user.mfa_secret)
# #         if totp.verify(code):
# #             refresh = RefreshToken.for_user(user)
# #             return Response({
# #                 'access': str(refresh.access_token),
# #                 'refresh': str(refresh),
# #                 'user': UsuarioSerializer(user).data
# #             })

# #         return Response({"detail": "Código MFA inválido"}, status=400)


# from rest_framework.permissions import AllowAny, IsAuthenticated
# from rest_framework.views import APIView
# from rest_framework.response import Response
# from rest_framework import status
# from rest_framework_simplejwt.tokens import AccessToken, RefreshToken
# from rest_framework_simplejwt.exceptions import TokenError
# from datetime import timedelta
# import pyotp

# from accounts.models import Usuario
# from accounts.serializers.mfa_serializers import MFAEnableSerializer, MFAVerifySerializer, MFADisableSerializer
# from accounts.serializers.user_serializers import UsuarioSerializer
# from accounts.utils.auditoria import registrar_auditoria


# def generate_temp_token(user):
#     access_token = AccessToken.for_user(user)
#     access_token.set_exp(lifetime=timedelta(minutes=5))  # Token válido solo 5 minutos
#     return str(access_token)


# class MFAEnableView(APIView):
#     permission_classes = [IsAuthenticated]
#     serializer_class = MFAEnableSerializer

#     def post(self, request):
#         user = request.user
#         if user.mfa_enabled:
#             return Response({"detail": "MFA ya está activado."}, status=status.HTTP_400_BAD_REQUEST)

#         secret = pyotp.random_base32()
#         user.mfa_secret = secret
#         user.save()

#         otp_uri = pyotp.totp.TOTP(secret).provisioning_uri(name=user.username, issuer_name="Nova ERP")

#         return Response({"otp_uri": otp_uri, "secret": secret})


# class MFAVerifyView(APIView):
#     permission_classes = [IsAuthenticated]
#     serializer_class = MFAVerifySerializer

#     def post(self, request):
#         user = request.user
#         serializer = MFAVerifySerializer(data=request.data)
#         serializer.is_valid(raise_exception=True)

#         code = serializer.validated_data['code']

#         if not user.mfa_secret:
#             return Response({"detail": "MFA no está configurado para este usuario."}, status=status.HTTP_400_BAD_REQUEST)

#         totp = pyotp.TOTP(user.mfa_secret)
#         if totp.verify(code):
#             user.mfa_enabled = True
#             user.save()
#             registrar_auditoria(user, "MFA_ACTIVADO", "Usuario", "MFA activado correctamente")
#             return Response({"detail": "MFA activado correctamente."})
#         else:
#             registrar_auditoria(user, "MFA_FALLIDO", "Usuario", "Código MFA inválido")
#             return Response({"detail": "Código MFA inválido. Intenta de nuevo."}, status=status.HTTP_400_BAD_REQUEST)


# class MFADisableView(APIView):
#     permission_classes = [IsAuthenticated]
#     serializer_class = MFADisableSerializer

#     def post(self, request):
#         user = request.user
#         serializer = MFADisableSerializer(data=request.data)
#         serializer.is_valid(raise_exception=True)

#         code = serializer.validated_data['code']

#         if not user.mfa_enabled:
#             return Response({"detail": "MFA no está activado."}, status=status.HTTP_400_BAD_REQUEST)

#         totp = pyotp.TOTP(user.mfa_secret)
#         if totp.verify(code):
#             user.mfa_enabled = False
#             user.mfa_secret = ""
#             user.save()
#             registrar_auditoria(user, "MFA_DESACTIVADO", "Usuario", "MFA desactivado")
#             return Response({"detail": "MFA desactivado correctamente."})
#         else:
#             return Response({"detail": "Código inválido."}, status=status.HTTP_400_BAD_REQUEST)


# class MFALoginVerifyView(APIView):
#     permission_classes = [AllowAny]
#     serializer_class = MFAVerifySerializer

#     def post(self, request):
#         token = request.data.get("temp_token")
#         code = request.data.get("code")

#         if not token or not code:
#             return Response({"detail": "Datos incompletos"}, status=status.HTTP_400_BAD_REQUEST)

#         try:
#             access_token = AccessToken(token)
#             user_id = access_token['user_id']
#             user = Usuario.objects.get(id=user_id)
#         except TokenError as e:
#             return Response({"detail": "Token inválido o expirado", "error": str(e)}, status=status.HTTP_401_UNAUTHORIZED)
#         except KeyError:
#             return Response({"detail": "Token mal formado"}, status=status.HTTP_400_BAD_REQUEST)
#         except Usuario.DoesNotExist:
#             return Response({"detail": "Usuario no encontrado"}, status=status.HTTP_404_NOT_FOUND)

#         if not user.mfa_secret:
#             return Response({"detail": "2FA no habilitado para este usuario"}, status=status.HTTP_400_BAD_REQUEST)

#         totp = pyotp.TOTP(user.mfa_secret)
#         if totp.verify(code):
#             refresh = RefreshToken.for_user(user)
#             return Response({
#                 'access': str(refresh.access_token),
#                 'refresh': str(refresh),
#                 'user': UsuarioSerializer(user).data
#             })

#         return Response({"detail": "Código MFA inválido"}, status=status.HTTP_400_BAD_REQUEST)



# --- /home/runner/workspace/accounts/views/password_reset.py ---
# Django
from django.core.mail import send_mail
from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_encode, urlsafe_base64_decode
from django.utils.encoding import force_bytes, force_str

# Django REST Framework
from rest_framework import status
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import AllowAny

# Utilidades
import pyotp

# App local
from accounts.models import Usuario
from accounts.utils.auditoria import registrar_auditoria
from accounts.serializers.auth_serializers import (
    PasswordResetRequestSerializer,
    PasswordResetConfirmSerializer
)

# Configuración del sitio (ajusta si usas variable de entorno)
site_url = "fca3faea-e64a-4f83-a448-762fa6e71df4-00-1kkfg9j97gplb.spock.replit.dev"
# Ej: site_url = os.environ.get("SITE_URL")


# 📤 Enviar correo de recuperación
class PasswordResetRequestView(APIView):
    permission_classes = [AllowAny]
    serializer_class = PasswordResetRequestSerializer

    def post(self, request):
        serializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)
        email = serializer.validated_data['email']

        try:
            user = Usuario.objects.get(email=email)
            token = default_token_generator.make_token(user)
            uidb64 = urlsafe_base64_encode(force_bytes(user.pk))

            reset_url = f"https://{site_url}/api/auth/password-reset/confirm/?uidb64={uidb64}&token={token}"

            send_mail(
                subject="Recuperación de contraseña - Nova ERP",
                message=f"Haz clic en el siguiente enlace para restablecer tu contraseña:\n\n{reset_url}",
                from_email="no-reply@novaerp.com",
                recipient_list=[email],
                fail_silently=False,
            )

            registrar_auditoria(user, "RESET_SOLICITADO", "Usuario", "Solicitud de recuperación de contraseña")
            return Response({"msg": "Correo enviado para recuperación de contraseña"}, status=status.HTTP_200_OK)

        except Usuario.DoesNotExist:
            # Por seguridad, se devuelve siempre éxito
            return Response({"msg": "Correo enviado para recuperación de contraseña"}, status=status.HTTP_200_OK)


# ✅ Confirmar cambio de contraseña
class PasswordResetConfirmView(APIView):
    permission_classes = [AllowAny]
    serializer_class = PasswordResetConfirmSerializer

    def post(self, request):
        serializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)

        uidb64 = serializer.validated_data['uidb64']
        token = serializer.validated_data['token']
        password = serializer.validated_data['password']
        code = serializer.validated_data.get('code')

        try:
            uid = force_str(urlsafe_base64_decode(uidb64))
            user = Usuario.objects.get(pk=uid)
        except (TypeError, ValueError, OverflowError, Usuario.DoesNotExist):
            return Response({"error": "Usuario inválido"}, status=status.HTTP_400_BAD_REQUEST)

        if not default_token_generator.check_token(user, token):
            return Response({"error": "Token inválido o expirado"}, status=status.HTTP_400_BAD_REQUEST)

        # Si tiene MFA habilitado
        if getattr(user, 'mfa_enabled', False):
            if not code:
                return Response({"error": "Código MFA requerido"}, status=status.HTTP_400_BAD_REQUEST)

            totp = pyotp.TOTP(user.mfa_secret)
            if not totp.verify(code):
                registrar_auditoria(user, "RESET_MFA_FAIL", "Usuario", "Código MFA inválido en recuperación")
                return Response({"error": "Código MFA inválido"}, status=status.HTTP_400_BAD_REQUEST)

        # Restablecer contraseña
        user.set_password(password)
        user.save()
        registrar_auditoria(user, "RESET_PASSWORD", "Usuario", "Contraseña restablecida exitosamente")
        return Response({"msg": "Contraseña cambiada correctamente"}, status=status.HTTP_200_OK)

# # Django
# from django.core.mail import send_mail
# from django.contrib.auth.tokens import default_token_generator
# from django.utils.http import urlsafe_base64_encode, urlsafe_base64_decode
# from django.utils.encoding import force_bytes, force_str

# # Django REST Framework
# from rest_framework import status, serializers
# from rest_framework.views import APIView
# from rest_framework.response import Response
# from rest_framework.permissions import AllowAny

# # App local
# from accounts.models import Usuario
# from accounts.utils.auditoria import registrar_auditoria
# from accounts.serializers.auth_serializers import (
#     PasswordResetRequestSerializer,
#     PasswordResetConfirmSerializer
# )

# import pyotp


# site_url = "fca3faea-e64a-4f83-a448-762fa6e71df4-00-1kkfg9j97gplb.spock.replit.dev"


# # ----------------------------------------
# # 🔐 SERIALIZERS (si ya los tienes en accounts.serializers.auth_serializers, no repitas aquí)
# # ----------------------------------------
# # class PasswordResetRequestSerializer(serializers.Serializer):
# #     email = serializers.EmailField()

# # class PasswordResetConfirmSerializer(serializers.Serializer):
# #     uidb64 = serializers.CharField()
# #     token = serializers.CharField()
# #     password = serializers.CharField(min_length=8)
# #     code = serializers.CharField(required=False)  # Solo si tiene MFA


# # ----------------------------------------
# # 📤 SOLICITUD DE RECUPERACIÓN
# # ----------------------------------------

# class PasswordResetRequestView(APIView):
#     permission_classes = [AllowAny]
#     serializer_class = PasswordResetRequestSerializer

#     def post(self, request):
#         serializer = self.serializer_class(data=request.data)
#         serializer.is_valid(raise_exception=True)
#         email = serializer.validated_data['email']

#         try:
#             user = Usuario.objects.get(email=email)
#             token = default_token_generator.make_token(user)
#             uidb64 = urlsafe_base64_encode(force_bytes(user.pk))

#             reset_url = f"https://{site_url}/api/auth/password-reset/confirm/?uidb64={uidb64}&token={token}"
#             send_mail(
#                 subject="Recupera tu contraseña",
#                 message=f"Enlace para resetear: {reset_url}",
#                 from_email="no-reply@erp.com",
#                 recipient_list=[email],
#                 fail_silently=False,
#             )
#             return Response({"msg": "Email enviado"}, status=status.HTTP_200_OK)

#         except Usuario.DoesNotExist:
#             # Para no revelar si el email existe o no, puedes devolver éxito aquí también (mejor seguridad)
#             return Response({"msg": "Email enviado"}, status=status.HTTP_200_OK)
#             # Si quieres indicar que no existe:
#             # return Response({"error": "Email no registrado"}, status=status.HTTP_404_NOT_FOUND)


# # ----------------------------------------
# # ✅ CONFIRMACIÓN DEL CAMBIO DE CONTRASEÑA
# # ----------------------------------------

# class PasswordResetConfirmView(APIView):
#     permission_classes = [AllowAny]
#     serializer_class = PasswordResetConfirmSerializer

#     def post(self, request):
#         serializer = self.serializer_class(data=request.data)
#         serializer.is_valid(raise_exception=True)

#         uidb64 = serializer.validated_data['uidb64']
#         token = serializer.validated_data['token']
#         password = serializer.validated_data['password']
#         code = serializer.validated_data.get('code')

#         try:
#             uid = force_str(urlsafe_base64_decode(uidb64))
#             user = Usuario.objects.get(pk=uid)
#         except (TypeError, ValueError, OverflowError, Usuario.DoesNotExist):
#             return Response({"error": "Usuario inválido"}, status=status.HTTP_400_BAD_REQUEST)

#         if default_token_generator.check_token(user, token):
#             if getattr(user, 'mfa_enabled', False):
#                 if not code:
#                     return Response({"error": "Código MFA requerido"}, status=status.HTTP_400_BAD_REQUEST)
#                 totp = pyotp.TOTP(user.mfa_secret)
#                 if not totp.verify(code):
#                     registrar_auditoria(user, "RESET_MFA_FAIL", "Usuario", "Código MFA inválido")
#                     return Response({"error": "Código MFA inválido"}, status=status.HTTP_400_BAD_REQUEST)

#             user.set_password(password)
#             user.save()
#             registrar_auditoria(user, "RESET_PASSWORD", "Usuario", "Contraseña restablecida con éxito")
#             return Response({"msg": "Contraseña cambiada correctamente"}, status=status.HTTP_200_OK)

#         return Response({"error": "Token inválido o expirado"}, status=status.HTTP_400_BAD_REQUEST)


# # # Django
# # from django.core.mail import send_mail
# # from django.contrib.auth.tokens import default_token_generator
# # from django.utils.http import urlsafe_base64_encode, urlsafe_base64_decode
# # from django.utils.encoding import force_bytes, force_str

# # # Django REST Framework
# # from rest_framework import status
# # from rest_framework.views import APIView
# # from rest_framework.response import Response

# # # App local
# # from accounts.models import Usuario
# # from accounts.utils.auditoria import registrar_auditoria
# # from accounts.serializers.auth_serializers import (
# #     PasswordResetRequestSerializer,
# #     PasswordResetConfirmSerializer
# # )

# # import pyotp

# # from rest_framework import serializers


# # site_url = "fca3faea-e64a-4f83-a448-762fa6e71df4-00-1kkfg9j97gplb.spock.replit.dev"

# # # ----------------------------------------
# # # 🔐 SERIALIZERS
# # # ----------------------------------------

# # class PasswordResetRequestSerializer(serializers.Serializer):
# #     email = serializers.EmailField()

# # class PasswordResetConfirmSerializer(serializers.Serializer):
# #     uidb64 = serializers.CharField()
# #     token = serializers.CharField()
# #     password = serializers.CharField(min_length=8)
# #     code = serializers.CharField(required=False)  # Solo si tiene MFA


# # # ----------------------------------------
# # # 📤 SOLICITUD DE RECUPERACIÓN
# # # ----------------------------------------

# # class PasswordResetRequestView(APIView):
# #     serializer_class = PasswordResetRequestSerializer

# #     def post(self, request):
# #         serializer = self.serializer_class(data=request.data)
# #         serializer.is_valid(raise_exception=True)
# #         email = serializer.validated_data['email']

# #         try:
# #             user = Usuario.objects.get(email=email)
# #             token = default_token_generator.make_token(user)
# #             uidb64 = urlsafe_base64_encode(force_bytes(user.pk))

# #             reset_url = f"https://{site_url}/api/auth/password-reset/confirm/?uidb64={uidb64}&token={token}"
# #             send_mail(
# #                 subject="Recupera tu contraseña",
# #                 message=f"Enlace para resetear: {reset_url}",
# #                 from_email="no-reply@erp.com",
# #                 recipient_list=[email],
# #                 fail_silently=False,
# #             )
# #             return Response({"msg": "Email enviado"}, status=200)

# #         except Usuario.DoesNotExist:
# #             return Response({"error": "Email no registrado"}, status=404)

# # # ----------------------------------------
# # # ✅ CONFIRMACIÓN DEL CAMBIO DE CONTRASEÑA
# # # ----------------------------------------

# # class PasswordResetConfirmView(APIView):
# #     serializer_class = PasswordResetConfirmSerializer

# #     def post(self, request):
# #         serializer = self.serializer_class(data=request.data)
# #         serializer.is_valid(raise_exception=True)

# #         uidb64 = serializer.validated_data['uidb64']
# #         token = serializer.validated_data['token']
# #         password = serializer.validated_data['password']
# #         code = serializer.validated_data.get('code')

# #         try:
# #             uid = force_str(urlsafe_base64_decode(uidb64))
# #             user = Usuario.objects.get(pk=uid)
# #         except (TypeError, ValueError, OverflowError, Usuario.DoesNotExist):
# #             return Response({"error": "Usuario inválido"}, status=400)

# #         if default_token_generator.check_token(user, token):
# #             if getattr(user, 'mfa_enabled', False):
# #                 if not code:
# #                     return Response({"error": "Código MFA requerido"}, status=400)
# #                 totp = pyotp.TOTP(user.mfa_secret)
# #                 if not totp.verify(code):
# #                     registrar_auditoria(user, "RESET_MFA_FAIL", "Usuario", "Código MFA inválido")
# #                     return Response({"error": "Código MFA inválido"}, status=400)

# #             user.set_password(password)
# #             user.save()
# #             registrar_auditoria(user, "RESET_PASSWORD", "Usuario", "Contraseña restablecida con éxito")
# #             return Response({"msg": "Contraseña cambiada correctamente"})

# #         return Response({"error": "Token inválido o expirado"}, status=400)



# # # ----------------------------------------
# # # ✅ CONFIRMACIÓN DEL CAMBIO DE CONTRASEÑA
# # # ----------------------------------------

# # class PasswordResetConfirmView(APIView):
# #     serializer_class = PasswordResetConfirmSerializer
# #     def post(self, request):
# #         serializer = PasswordResetConfirmSerializer(data=request.data)
# #         serializer.is_valid(raise_exception=True)

# #         uidb64 = serializer.validated_data['uidb64']
# #         token = serializer.validated_data['token']
# #         password = serializer.validated_data['password']
# #         code = serializer.validated_data.get('code')

# #         try:
# #             uid = force_str(urlsafe_base64_decode(uidb64))
# #             user = Usuario.objects.get(pk=uid)
# #         except (TypeError, ValueError, OverflowError, Usuario.DoesNotExist):
# #             return Response({"error": "Usuario inválido"}, status=400)

# #         if default_token_generator.check_token(user, token):
# #             if user.mfa_enabled:
# #                 if not code:
# #                     return Response({"error": "Código MFA requerido"}, status=400)
# #                 totp = pyotp.TOTP(user.mfa_secret)
# #                 if not totp.verify(code):
# #                     registrar_auditoria(user, "RESET_MFA_FAIL", "Usuario", "Código MFA inválido")
# #                     return Response({"error": "Código MFA inválido"}, status=400)

# #             user.set_password(password)
# #             user.save()
# #             registrar_auditoria(user, "RESET_PASSWORD", "Usuario", "Contraseña restablecida con éxito")
# #             return Response({"msg": "Contraseña cambiada correctamente"})

# #         # 🔴 El token es inválido
# #         return Response({"error": "Token inválido o expirado"}, status=400)





# --- /home/runner/workspace/accounts/views/audit.py ---
# 📦 Standard library
import csv

# 🧩 Django
from django.http import HttpResponse

# 🛠️ Django REST Framework
from rest_framework import generics, filters, serializers
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.pagination import PageNumberPagination

# 🔍 Filtros de terceros
from django_filters.rest_framework import DjangoFilterBackend

# 🧠 Local apps
from accounts.models import Auditoria
from accounts.serializers.auditoria_serializers import AuditoriaSerializer
from accounts.filters import AuditoriaFilter
from accounts.permissions import IsSuperAdminOrAuditor


# 🔹 Serializer vacío para cumplir con DRF en vistas sin body
class EmptySerializer(serializers.Serializer):
    pass


# ✅ Exportar auditoría a CSV (solo SuperAdmin o Auditor)
class AuditLogExportCSV(APIView):
    permission_classes = [IsSuperAdminOrAuditor]
    serializer_class = EmptySerializer

    def get(self, request):
        filtro = AuditoriaFilter(request.GET, queryset=Auditoria.objects.all())

        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="audit_log.csv"'

        writer = csv.writer(response)
        writer.writerow(['ID', 'Usuario', 'Acción', 'Tabla', 'Registro Afectado', 'Fecha/Hora'])

        for entry in filtro.qs.order_by('-timestamp'):
            writer.writerow([
                entry.id,
                str(entry.usuario),
                entry.accion,
                entry.tabla_afectada,
                entry.registro_afectado,
                entry.timestamp.strftime('%Y-%m-%d %H:%M:%S'),
            ])

        return response


# ✅ Ver historial personal del usuario autenticado
class ActivityLogView(APIView):
    permission_classes = [IsAuthenticated]
    serializer_class = AuditoriaSerializer

    def get(self, request):
        logs = Auditoria.objects.filter(usuario_id=request.user.id).order_by('-timestamp')[:50]
        data = self.serializer_class(logs, many=True).data
        return Response(data)


# ✅ Ver últimas 200 auditorías (solo SuperAdmin o Auditor)
class AuditLogView(APIView):
    permission_classes = [IsSuperAdminOrAuditor]
    serializer_class = AuditoriaSerializer

    def get(self, request):
        logs = Auditoria.objects.all().order_by('-timestamp')[:200]
        data = self.serializer_class(logs, many=True).data
        return Response(data)


# ✅ Paginación estándar para auditorías
class StandardResultsSetPagination(PageNumberPagination):
    page_size = 25
    page_size_query_param = 'page_size'
    max_page_size = 100


# ✅ Lista paginada, filtrable y ordenable de auditorías
class AuditLogListView(generics.ListAPIView):
    queryset = Auditoria.objects.all()
    serializer_class = AuditoriaSerializer
    permission_classes = [IsSuperAdminOrAuditor]
    filter_backends = [DjangoFilterBackend, filters.OrderingFilter]
    filterset_class = AuditoriaFilter
    ordering_fields = ['timestamp', 'usuario__username', 'accion', 'tabla_afectada']
    ordering = ['-timestamp']
    pagination_class = StandardResultsSetPagination





# --- /home/runner/workspace/accounts/views/profile.py ---
from rest_framework import generics
from rest_framework.permissions import BasePermission
from accounts.serializers.user_serializers import UsuarioSerializer

# Importa tus permisos personalizados si los quieres usar aparte (aquí no son usados directamente)
from accounts.permissions import (
    IsSuperAdmin,
    IsEmpresaAdmin,
    IsVendedor,
    IsInventario,
    IsCompras,
    IsContador,
    IsTesorero,
    IsRecursosHumanos,
    IsAuditor,
    IsClienteExterno,
)

# ✅ Permiso combinado para usuarios con cualquier rol válido en el sistema
class HasValidRole(BasePermission):
    def has_permission(self, request, view):
        return (
            request.user.is_authenticated and
            request.user.rol and
            request.user.rol.nombre in [
                "Superadministrador",
                "Administrador de Empresa",
                "Vendedor",
                "Almacén / Inventario",
                "Compras / Proveedores",
                "Contador",
                "Tesorero / Finanzas",
                "Recursos Humanos",
                "Auditor / Legal",
                "Cliente externo"
            ]
        )


class ProfileView(generics.RetrieveUpdateAPIView):
    serializer_class = UsuarioSerializer
    permission_classes = [HasValidRole]

    def get_object(self):
        return self.request.user



# --- /home/runner/workspace/accounts/views/users.py ---
from rest_framework import viewsets, filters
from accounts.models import Usuario
from accounts.serializers.user_serializers import UsuarioCreateSerializer, UsuarioDetailSerializer
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.exceptions import PermissionDenied

from accounts.permissions import IsSuperAdminOrEmpresaAdmin  # permiso combinado importado

class UsuarioViewSet(viewsets.ModelViewSet):
    permission_classes = [IsSuperAdminOrEmpresaAdmin]
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['username', 'email']
    filterset_fields = ['activo', 'empresa', 'rol']

    def get_queryset(self):
        user = self.request.user

        if user.rol.nombre == "Superadministrador":
            return Usuario.objects.select_related('empresa', 'rol').all()
        elif user.rol.nombre == "Administrador de Empresa":
            return Usuario.objects.select_related('empresa', 'rol').filter(empresa=user.empresa)
        else:
            raise PermissionDenied("No tienes permisos para ver usuarios")

    def get_serializer_class(self):
        if self.action == 'create':
            return UsuarioCreateSerializer
        return UsuarioDetailSerializer

    def perform_create(self, serializer):
        user = self.request.user

        if user.rol.nombre == "Superadministrador":
            serializer.save()
        elif user.rol.nombre == "Administrador de Empresa":
            serializer.save(empresa=user.empresa)
        else:
            raise PermissionDenied("No puedes crear usuarios")

    def perform_destroy(self, instance):
        # Baja lógica: no se borra, solo se inactiva
        instance.activo = False
        instance.save()






# --- /home/runner/workspace/accounts/views/auth.py ---
# 🛡️ Django REST Framework
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework import status, generics, serializers
from rest_framework.exceptions import ValidationError
from rest_framework.authentication import BaseAuthentication, BasicAuthentication

# 🔑 JWT
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.views import TokenRefreshView
from rest_framework_simplejwt.exceptions import TokenError

# 🧾 Serializers
from accounts.serializers.auth_serializers import LoginSerializer
from accounts.serializers.user_serializers import UsuarioRegistroSerializer, UsuarioSerializer

# 🧠 Auditoría
from accounts.utils.auditoria import registrar_auditoria


# 🔹 Serializer vacío para endpoints sin entrada
class EmptySerializer(serializers.Serializer):
    pass


# 🔹 Desactiva autenticación para ciertos endpoints como login
class NoAuthentication(BaseAuthentication):
    def authenticate(self, request):
        return None


# ✅ LOGIN CON AUDITORÍA Y SOPORTE PARA MFA
class LoginView(APIView):
    serializer_class = LoginSerializer
    permission_classes = [AllowAny]
    authentication_classes = [NoAuthentication]  # ignora token JWT aquí

    def post(self, request):
        serializer = self.serializer_class(data=request.data)

        try:
            serializer.is_valid(raise_exception=True)
        except ValidationError:
            username = request.data.get("username", "desconocido")
            registrar_auditoria(
                usuario=None,
                username_intentado=username,
                accion="LOGIN_FAIL",
                tabla="Usuario",
                registro=f"Intento fallido de login para '{username}'"
            )
            raise

        user = serializer.validated_data['user']

        if getattr(user, 'mfa_enabled', False):
            temp_token = RefreshToken.for_user(user)
            registrar_auditoria(
                usuario=user,
                accion="LOGIN_MFA",
                tabla="Usuario",
                registro="Login exitoso (pendiente MFA)"
            )
            return Response({
                'mfa_required': True,
                'temp_token': str(temp_token.access_token),
                'detail': 'MFA_REQUIRED'
            }, status=202)

        refresh = RefreshToken.for_user(user)
        registrar_auditoria(
            usuario=user,
            accion="LOGIN",
            tabla="Usuario",
            registro="Login exitoso"
        )

        return Response({
            'access': str(refresh.access_token),
            'refresh': str(refresh),
            'user': UsuarioSerializer(user).data
        })


# ✅ LOGOUT CON BLACKLIST Y AUDITORÍA
class LogoutView(APIView):
    permission_classes = [IsAuthenticated]
    serializer_class = EmptySerializer

    def post(self, request):
        refresh_token = request.data.get('refresh')

        if not refresh_token:
            return Response(
                {"detail": "Se requiere el refresh token para cerrar sesión."},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            token = RefreshToken(refresh_token)
            token.blacklist()

            registrar_auditoria(
                usuario=request.user,
                accion="LOGOUT",
                tabla="Usuario",
                registro="Logout exitoso"
            )

            return Response(
                {"detail": "Sesión cerrada correctamente."},
                status=status.HTTP_205_RESET_CONTENT
            )

        except TokenError:
            return Response(
                {"detail": "El token ya fue usado o es inválido."},
                status=status.HTTP_400_BAD_REQUEST
            )

        except Exception:
            return Response(
                {"detail": "Error inesperado al cerrar sesión."},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


# ✅ REGISTRO DE USUARIOS (público o controlable por rol)
class RegisterView(generics.CreateAPIView):
    serializer_class = UsuarioRegistroSerializer
    permission_classes = [AllowAny]
    authentication_classes = [BasicAuthentication]  # útil para apps móviles o sistemas externos


# ✅ REFRESCAR TOKEN JWT
class RefreshTokenView(TokenRefreshView):
    permission_classes = [AllowAny]




# --- /home/runner/workspace/accounts/views/permissions.py ---
from django.contrib.auth.models import Permission
from rest_framework import viewsets
from rest_framework.permissions import BasePermission

from accounts.serializers.group_permission_serializers import PermissionSerializer


# 🔐 Permiso personalizado: Solo Superadmin o Auditor/Legal
class IsSuperAdminOrAuditor(BasePermission):
    def has_permission(self, request, view):
        user = request.user
        return (
            user.is_authenticated and 
            user.rol is not None and 
            user.rol.nombre in ["Superadministrador", "Auditor / Legal"]
        )


# 📋 Vista de solo lectura para listar permisos disponibles en el sistema
class PermissionViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Permission.objects.all()
    serializer_class = PermissionSerializer
    permission_classes = [IsSuperAdminOrAuditor]





# --- /home/runner/workspace/accounts/views/roles.py ---
from rest_framework import viewsets
from accounts.models import Rol
from accounts.serializers.rol_serializers import RoleSerializer
from accounts.permissions import IsSuperAdmin , IsSuperAdminOrEmpresaAdmin # Importa tu permiso personalizado
from rest_framework.permissions import AllowAny

class RoleViewSet(viewsets.ModelViewSet):
    queryset = Rol.objects.all()
    serializer_class = RoleSerializer
    permission_classes = [AllowAny]




# --- /home/runner/workspace/accounts/tests/test_auth.py ---
# accounts/tests/test_auth.py

from rest_framework.test import APITestCase
from django.urls import reverse
from accounts.models import Usuario
from rest_framework import status

class AuthTests(APITestCase):
    def setUp(self):
        self.user = Usuario.objects.create_user(
            username="testuser",
            password="testpass123",
            email="test@example.com"
        )

    def test_login(self):
        url = reverse("login")  # Asegúrate de tener 'name="login"' en tu URL
        response = self.client.post(url, {"username": "testuser", "password": "testpass123"})
        self.assertEqual(response.status_code, 200)
        self.assertIn("access", response.data)
        self.assertIn("refresh", response.data)

    def test_profile_access(self):
        self.client.force_authenticate(user=self.user)
        url = reverse("profile")  # Asegúrate de tener 'name="profile"'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data["username"], "testuser")

    def test_register_user(self):
        url = reverse("register")
        data = {
            "username": "newuser",
            "password": "newpass123",
            "email": "newuser@example.com"
        }
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 201)
        self.assertTrue(Usuario.objects.filter(username="newuser").exists())

def test_login_fail(self):
    url = reverse("login")
    response = self.client.post(url, {"username": "wronguser", "password": "wrongpass"})
    self.assertEqual(response.status_code, 401)


# --- /home/runner/workspace/accounts/tests/test_accounts_full.py ---
# ✅ TESTS AUTOMATIZADOS COMPLETOS PARA accounts
# Archivo sugerido: accounts/tests/test_accounts_full.py

from rest_framework.test import APITestCase
from django.urls import reverse
from rest_framework import status
from accounts.models import Usuario, Rol
from rest_framework_simplejwt.tokens import RefreshToken
import pyotp

class AccountsFullTests(APITestCase):
    def setUp(self):
        self.user = Usuario.objects.create_user(
            username="testuser",
            password="testpass123",
            email="test@example.com"
        )
        self.admin = Usuario.objects.create_superuser(
            username="admin",
            password="adminpass",
            email="admin@example.com"
        )

    def authenticate(self, user):
        refresh = RefreshToken.for_user(user)
        self.client.credentials(HTTP_AUTHORIZATION=f"Bearer {refresh.access_token}")

    def test_logout(self):
        self.authenticate(self.user)
        url = reverse("logout")
        refresh = str(RefreshToken.for_user(self.user))
        response = self.client.post(url, {"refresh": refresh})
        self.assertEqual(response.status_code, 205)

    def test_password_reset(self):
        url_request = reverse("password_reset_request")
        response = self.client.post(url_request, {"email": self.user.email})
        self.assertEqual(response.status_code, 200)
        # Aquí deberías simular el envío de token y confirmar el cambio

    def test_user_crud(self):
        self.authenticate(self.admin)
        url = reverse("usuarios-list")
        data = {"username": "nuevo", "password": "pass", "email": "nuevo@example.com"}
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 201)

    def test_role_crud(self):
        self.authenticate(self.admin)
        url = reverse("roles-list")
        data = {"nombre": "Supervisor"}
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 201)

    def test_2fa_enable_and_verify(self):
        self.authenticate(self.user)
        url_enable = reverse("2fa-enable")
        response = self.client.post(url_enable)
        self.assertEqual(response.status_code, 200)

        totp = pyotp.TOTP(self.user.mfa_secret)
        code = totp.now()
        url_verify = reverse("2fa-verify")
        response = self.client.post(url_verify, {"code": code})
        self.assertEqual(response.status_code, 200)


# --- /home/runner/workspace/accounts/tests/test_security.py ---
from rest_framework.test import APITestCase
from django.urls import reverse
from accounts.models import Usuario
from rest_framework_simplejwt.tokens import RefreshToken
import pyotp

class SeguridadTests(APITestCase):
    def setUp(self):
        self.user = Usuario.objects.create_user(
            username="testuser", password="Test1234", email="test@example.com"
        )

    def test_login_fail_auditoria(self):
        url = reverse("login")
        response = self.client.post(url, {"username": "wrong", "password": "bad"})
        self.assertEqual(response.status_code, 401)

    def test_login_con_mfa(self):
        self.user.mfa_enabled = True
        self.user.mfa_secret = pyotp.random_base32()
        self.user.save()

        url = reverse("login")
        response = self.client.post(url, {"username": "testuser", "password": "Test1234"})
        self.assertEqual(response.status_code, 202)
        self.assertIn("temp_token", response.data)

        # MFA TOTP correcto
        totp = pyotp.TOTP(self.user.mfa_secret)
        code = totp.now()
        verify_url = reverse("mfa-verify-login")
        response = self.client.post(verify_url, {"temp_token": response.data["temp_token"], "code": code})
        self.assertEqual(response.status_code, 200)
        self.assertIn("access", response.data)

# CORS correctamente configurado:
# Solo responde a dominios permitidos:


# // En frontend en local
# fetch('https://api.tusitio.com/api/login')
# → debe fallar si el dominio no está en CORS_ALLOWED_ORIGINS
# Rate Limiting activado:
# Lanza 10 peticiones rápidas y ve si responde:


# {
#   "detail": "Request was throttled. Expected available in X seconds."
# }


# --- /home/runner/workspace/accounts/migrations/__init__.py ---



# --- /home/runner/workspace/accounts/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
import django.utils.timezone
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Usuario',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('mfa_enabled', models.BooleanField(default=False)),
                ('mfa_secret', models.CharField(blank=True, max_length=32, null=True)),
                ('username', models.CharField(max_length=150, unique=True)),
                ('email', models.EmailField(max_length=254, unique=True)),
                ('activo', models.BooleanField(default=True)),
                ('is_active', models.BooleanField(default=True)),
                ('is_staff', models.BooleanField(default=False)),
                ('is_superuser', models.BooleanField(default=False)),
                ('fecha_creacion', models.DateTimeField(default=django.utils.timezone.now)),
                ('foto', models.URLField(blank=True, null=True)),
                ('telefono', models.CharField(blank=True, max_length=30, null=True)),
                ('direccion', models.TextField(blank=True, null=True)),
                ('idioma', models.CharField(default='es', max_length=10)),
                ('tema', models.CharField(default='claro', max_length=50)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='usuarios', to='core.empresa')),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('sucursal_actual', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='usuarios_actuales', to='core.sucursal')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'Usuario',
                'verbose_name_plural': 'Usuarios',
                'ordering': ['username'],
            },
        ),
        migrations.CreateModel(
            name='Auditoria',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('username_intentado', models.CharField(blank=True, help_text='Nombre de usuario usado en caso de login fallido', max_length=150, null=True)),
                ('accion', models.CharField(max_length=255)),
                ('tabla_afectada', models.CharField(max_length=255)),
                ('registro_afectado', models.TextField()),
                ('timestamp', models.DateTimeField(auto_now_add=True)),
                ('usuario', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='auditorias', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Auditoría',
                'verbose_name_plural': 'Auditorías',
                'ordering': ['-timestamp'],
            },
        ),
        migrations.CreateModel(
            name='Rol',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nombre', models.CharField(max_length=100, unique=True)),
                ('descripcion', models.TextField(blank=True, null=True)),
                ('grupo', models.OneToOneField(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='auth.group')),
            ],
            options={
                'verbose_name': 'Rol',
                'verbose_name_plural': 'Roles',
                'ordering': ['nombre'],
            },
        ),
        migrations.AddField(
            model_name='usuario',
            name='rol',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='usuarios', to='accounts.rol'),
        ),
        migrations.AddIndex(
            model_name='usuario',
            index=models.Index(fields=['empresa', 'username'], name='accounts_us_empresa_e6cf50_idx'),
        ),
        migrations.AddIndex(
            model_name='usuario',
            index=models.Index(fields=['rol', 'activo'], name='accounts_us_rol_id_e34ea6_idx'),
        ),
    ]



# --- /home/runner/workspace/accounts/utils/auditoria.py ---
def registrar_auditoria(usuario=None, accion="", tabla="", registro="", username_intentado=None):
    from accounts.models import Auditoria

    if not usuario and not username_intentado:
        raise ValueError("Se debe proporcionar 'usuario' o 'username_intentado' para la auditoría.")

    Auditoria.objects.create(
        usuario=usuario if hasattr(usuario, 'id') else None,
        username_intentado=username_intentado,
        accion=accion,
        tabla_afectada=tabla,
        registro_afectado=str(registro)
    )

# def registrar_auditoria(usuario, accion, tabla, registro):
#   from accounts.models import Auditoria

#   Auditoria.objects.create(
#       usuario=usuario if hasattr(usuario, 'id') else None,
#       accion=accion,
#       tabla_afectada=tabla,
#       registro_afectado=str(registro)
#   )



# --- /home/runner/workspace/accounts/utils/assign_group_by_rol.py ---
from django.contrib.auth.models import Group

def assign_group_by_rol(user):
    if user.rol:
        group, _ = Group.objects.get_or_create(name=user.rol.nombre)
        user.groups.set([group])



# --- /home/runner/workspace/accounts/utils/__init__.py ---



# --- /home/runner/workspace/accounts/serializers/auth_serializers.py ---
from rest_framework import serializers
from django.contrib.auth import authenticate
from ..models import Usuario

class LoginSerializer(serializers.Serializer):
    username = serializers.CharField()
    password = serializers.CharField(write_only=True)

    def validate(self, data):
        username = data.get('username')
        password = data.get('password')

        if not username or not password:
            raise serializers.ValidationError("Usuario y contraseña son obligatorios.")

        user = authenticate(username=username, password=password)

        if user is None:
            raise serializers.ValidationError("Credenciales inválidas.")

        if not user.activo:
            raise serializers.ValidationError("La cuenta está inactiva. Contacta al administrador.")

        data['user'] = user
        return data


class PasswordResetRequestSerializer(serializers.Serializer):
    email = serializers.EmailField()


class PasswordResetConfirmSerializer(serializers.Serializer):
    uidb64 = serializers.CharField()
    token = serializers.CharField()
    password = serializers.CharField(min_length=8)



# --- /home/runner/workspace/accounts/serializers/mfa_serializers.py ---
from rest_framework import serializers

class EnableMFASerializer(serializers.Serializer):
    method = serializers.ChoiceField(choices=["totp", "sms"])


class VerifyMFASerializer(serializers.Serializer):
    code = serializers.CharField()


class MFAEnableSerializer(serializers.Serializer):
    pass


class MFAVerifySerializer(serializers.Serializer):
    code = serializers.CharField(max_length=6)


class MFADisableSerializer(serializers.Serializer):
    code = serializers.CharField(max_length=6)



# --- /home/runner/workspace/accounts/serializers/auditoria_serializers.py ---
from rest_framework import serializers
from ..models import Auditoria

class AuditoriaSerializer(serializers.ModelSerializer):
    usuario = serializers.StringRelatedField()

    class Meta:
        model = Auditoria
        fields = [
            'id',
            'usuario',
            'accion',
            'tabla_afectada',
            'registro_afectado',
            'timestamp',
        ]



# --- /home/runner/workspace/accounts/serializers/__init__.py ---
from .auth_serializers import *
from .user_serializers import *
from .mfa_serializers import *
from .auditoria_serializers import *
from .rol_serializers import *


# --- /home/runner/workspace/accounts/serializers/rol_serializers.py ---
from rest_framework import serializers
from accounts.models import Rol  # Importa el modelo correctamente

class RoleSerializer(serializers.ModelSerializer):
    class Meta:
        model = Rol
        fields = '__all__'



# --- /home/runner/workspace/accounts/serializers/user_serializers.py ---
from rest_framework import serializers
from ..models import Usuario, Rol
from core.models import Empresa

class UsuarioRegistroSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, min_length=8)

    class Meta:
        model = Usuario
        fields = ['empresa', 'rol', 'username', 'email', 'password']

    def validate_email(self, value):
        # Validar que el email no esté registrado
        if Usuario.objects.filter(email=value).exists():
            raise serializers.ValidationError("El correo ya está registrado.")
        return value

    def validate_username(self, value):
        # Validar que el username sea único
        if Usuario.objects.filter(username=value).exists():
            raise serializers.ValidationError("El nombre de usuario ya está en uso.")
        return value

    def create(self, validated_data):
        return Usuario.objects.create_user(**validated_data)


class UsuarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Usuario
        exclude = ['password']


class UsuarioDetailSerializer(serializers.ModelSerializer):
    empresa_nombre = serializers.CharField(source='empresa.nombre', read_only=True)
    rol_nombre = serializers.CharField(source='rol.nombre', read_only=True)

    class Meta:
        model = Usuario
        exclude = ['password']
        read_only_fields = ['id', 'fecha_creacion', 'empresa_nombre', 'rol_nombre']


class UsuarioCreateSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, min_length=8)
    rol = serializers.PrimaryKeyRelatedField(queryset=Rol.objects.all(), required=False)

    class Meta:
        model = Usuario
        fields = ['rol', 'username', 'email', 'password']

    def validate_email(self, value):
        # Evitar duplicados al crear usuarios
        if Usuario.objects.filter(email=value).exists():
            raise serializers.ValidationError("El correo ya está registrado.")
        return value

    def validate_username(self, value):
        if Usuario.objects.filter(username=value).exists():
            raise serializers.ValidationError("El nombre de usuario ya está en uso.")
        return value

    def validate(self, data):
        user = self.context['request'].user

        # Solo superusuarios pueden asignar rol manualmente
        if not user.is_superuser and data.get('rol'):
            raise serializers.ValidationError("No tienes permiso para asignar un rol manualmente.")

        return data

    def create(self, validated_data):
        password = validated_data.pop('password')
        request_user = self.context['request'].user

        # Solo superusuarios pueden asignar empresa en validated_data (aunque no está en fields)
        empresa = request_user.empresa if not request_user.is_superuser else validated_data.get('empresa', None)

        user = Usuario(**validated_data)
        user.empresa = empresa
        user.set_password(password)
        user.save()
        return user

# from rest_framework import serializers
# from ..models import Usuario, Rol
# from core.models import Empresa

# class UsuarioRegistroSerializer(serializers.ModelSerializer):
#     password = serializers.CharField(write_only=True)

#     class Meta:
#         model = Usuario
#         fields = ['empresa', 'rol', 'username', 'email', 'password']

#     def create(self, validated_data):
#         return Usuario.objects.create_user(**validated_data)


# class UsuarioSerializer(serializers.ModelSerializer):
#     class Meta:
#         model = Usuario
#         exclude = ['password']




# class UsuarioDetailSerializer(serializers.ModelSerializer):  # mejor nombre estándar
#     empresa_nombre = serializers.CharField(source='empresa.nombre', read_only=True)
#     rol_nombre = serializers.CharField(source='rol.nombre', read_only=True)

#     class Meta:
#         model = Usuario
#         exclude = ['password']
#         read_only_fields = ['id', 'fecha_creacion', 'empresa_nombre', 'rol_nombre']

# class UsuarioCreateSerializer(serializers.ModelSerializer):
#     password = serializers.CharField(write_only=True, min_length=8)
#     rol = serializers.PrimaryKeyRelatedField(queryset=Rol.objects.all(), required=False)

#     class Meta:
#         model = Usuario
#         fields = ['rol', 'username', 'email', 'password']

#     def validate(self, data):
#         user = self.context['request'].user

#         # Solo superusuarios pueden asignar rol manualmente
#         if not user.is_superuser and data.get('rol'):
#             raise serializers.ValidationError("No tienes permiso para asignar un rol manualmente.")

#         return data

#     def create(self, validated_data):
#         password = validated_data.pop('password')
#         request_user = self.context['request'].user

#         # Solo superusuarios pueden asignar empresa en validated_data (aunque no está en fields)
#         empresa = request_user.empresa if not request_user.is_superuser else validated_data.get('empresa', None)

#         user = Usuario(**validated_data)
#         user.empresa = empresa
#         user.set_password(password)
#         user.save()
#         return user


# --- /home/runner/workspace/accounts/serializers/group_permission_serializers.py ---
from django.contrib.auth.models import Group, Permission
from rest_framework import serializers

class PermissionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Permission
        fields = ['id', 'name', 'codename', 'content_type']

class GroupSerializer(serializers.ModelSerializer):
    permissions = serializers.PrimaryKeyRelatedField(
        many=True,
        queryset=Permission.objects.all()
    )

    class Meta:
        model = Group
        fields = ['id', 'name', 'permissions']






# === Archivo: inventario_combined.py ===

# --- /home/runner/workspace/inventario/__init__.py ---



# --- /home/runner/workspace/inventario/admin.py ---
from django.contrib import admin

# Register your models here.



# --- /home/runner/workspace/inventario/apps.py ---
from django.apps import AppConfig


class InventarioConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'inventario'



# --- /home/runner/workspace/inventario/tests.py ---
from django.test import TestCase

# Create your tests here.



# --- /home/runner/workspace/inventario/views.py ---
from django.shortcuts import render

# Create your views here.



# --- /home/runner/workspace/inventario/urls.py ---
from rest_framework.routers import DefaultRouter
from django.urls import path
from inventario.views.producto import ProductoViewSet
from inventario.views.categoria import CategoriaViewSet  # Asumido: Vista para categorías
from inventario.views.inventario import InventarioViewSet
from inventario.views.movimiento import MovimientoInventarioViewSet
from inventario.views.stock_alerts import StockAlertView
from inventario.views.batches import BatchView

# Crear un enrutador para el registro de vistas (ViewSets)
router = DefaultRouter()
router.register(r'products', ProductoViewSet, basename='product')  # Endpoint para productos
router.register(r'categories', CategoriaViewSet, basename='category')  # Endpoint para categorías
router.register(r'inventory', InventarioViewSet, basename='inventory')  # Endpoint para inventario
router.register(r'movements', MovimientoInventarioViewSet, basename='inventory-movement')  # Endpoint para movimientos

# Lista de URLs que combinan las rutas generadas por el router con otras rutas personalizadas
urlpatterns = router.urls + [
    # Rutas personalizadas adicionales (las nuevas que mencionabas)
    path('stock-alerts/', StockAlertView.as_view(), name='stock-alerts'),  # Rutas para las alertas de stock
    path('batches/', BatchView.as_view(), name='inventory-batches'),  # Rutas para lotes de inventario
]


# from rest_framework.routers import DefaultRouter
# from django.urls import path
# from inventario.views.producto import ProductoViewSet
# from inventario.views.inventario import InventarioViewSet
# from inventario.views.movimiento import MovimientoInventarioViewSet
# from inventario.views.stock_alerts import StockAlertView
# from inventario.views.batches import BatchView

# # Crear un enrutador para el registro de vistas (ViewSets)
# router = DefaultRouter()
# router.register(r'products', ProductoViewSet, basename='product')
# router.register(r'inventory', InventarioViewSet, basename='inventory')
# router.register(r'movements', MovimientoInventarioViewSet, basename='inventory-movement')


# # Lista de URLs que combinan las rutas generadas por el router con otras rutas personalizadas
# urlpatterns = router.urls + [
#     # Rutas personalizadas adicionales
#     path('inventory/stock-alerts/', StockAlertView.as_view(), name='stock-alerts'),
#     path('inventory/batches/', BatchView.as_view(), name='inventory-batches'),
# ]
# # from rest_framework.routers import DefaultRouter
# # from django.urls import path
# # from inventario.views.producto import ProductoViewSet
# # from inventario.views.inventario import InventarioViewSet
# # from inventario.views.movimiento import MovimientoInventarioViewSet
# # from inventario.views.stock_alerts import StockAlertView
# # from inventario.views.batches import BatchView

# # # Crear un enrutador para el registro de vistas (ViewSets)
# # router = DefaultRouter()
# # router.register(r'products', ProductoViewSet, basename='product')
# # router.register(r'inventory', InventarioViewSet, basename='inventory')
# # router.register(r'inventory/movements', MovimientoInventarioViewSet, basename='inventory-movement')


# # # Lista de URLs que combinan las rutas generadas por el router con otras rutas personalizadas
# # urlpatterns = router.urls + [
# #     # Rutas personalizadas adicionales
# #     path('inventory/stock-alerts/', StockAlertView.as_view(), name='stock-alerts'),
# #     path('inventory/batches/', BatchView.as_view(), name='inventory-batches'),
# # ]
# # # inventario/urls.py

# # from rest_framework.routers import DefaultRouter
# # from django.urls import path
# # from inventario.views.producto import ProductoViewSet
# # from inventario.views.inventario import InventarioViewSet
# # from inventario.views.movimiento import MovimientoInventarioViewSet
# # from inventario.views.stock_alerts import StockAlertView
# # from inventario.views.batches import BatchView

# # router = DefaultRouter()
# # router.register(r'products', ProductoViewSet, basename='product')
# # router.register(r'inventory', InventarioViewSet, basename='inventory')
# # router.register(r'inventory/movements', MovimientoInventarioViewSet, basename='inventory-movement')

# # urlpatterns = router.urls + [
# #     path('inventory/stock-alerts/', StockAlertView.as_view(), name='stock-alerts'),
# #     path('inventory/batches/', BatchView.as_view(), name='inventory-batches'),
# # ]


# # inventario

# # 🔹 4. /movimientos/ → MovimientoInventarioViewSet
# # Método	Ruta	Acción
# # GET	/api/inventario/movimientos/	Listar movimientos
# # POST	/api/inventario/movimientos/	Crear nuevo movimiento
# # GET	/api/inventario/movimientos/{id}/	Ver detalle de movimiento
# # PUT	/api/inventario/movimientos/{id}/	❌ No recomendado (stock ya movido)
# # PATCH	/api/inventario/movimientos/{id}/	❌ Idem anterior
# # DELETE	/api/inventario/movimientos/{id}/	❌ No recomendado (auditoría)

# # # inventario/urls.py

# # from rest_framework.routers import DefaultRouter
# # from django.urls import path, include

# # from inventario.views.categoria import CategoriaViewSet
# # from inventario.views.producto import ProductoViewSet
# # from inventario.views.inventario import InventarioViewSet
# # from inventario.views.movimiento import MovimientoInventarioViewSet

# # router = DefaultRouter()
# # router.register(r'categorias', CategoriaViewSet, basename='categoria')
# # router.register(r'productos', ProductoViewSet, basename='producto')
# # router.register(r'inventarios', InventarioViewSet, basename='inventario')
# # router.register(r'movimientos', MovimientoInventarioViewSet, basename='movimiento-inventario')

# # urlpatterns = [
# #     path('', include(router.urls)),
# # ]



# --- /home/runner/workspace/inventario/filters.py ---
import django_filters
from inventario.models import Producto
from django.db.models import Q
from django_filters import rest_framework as filters
from inventario.models import Inventario

class ProductoFilter(filters.FilterSet):
    nombre = filters.CharFilter(field_name='nombre', lookup_expr='icontains', label='Nombre contiene')
    descripcion = filters.CharFilter(field_name='descripcion', lookup_expr='icontains', label='Descripción contiene')
    precio_min = filters.NumberFilter(field_name='precio_venta', lookup_expr='gte', label='Precio mínimo')
    precio_max = filters.NumberFilter(field_name='precio_venta', lookup_expr='lte', label='Precio máximo')
    stock_min = filters.NumberFilter(field_name='stock', lookup_expr='gte', label='Stock mínimo')
    stock_max = filters.NumberFilter(field_name='stock', lookup_expr='lte', label='Stock máximo')
    fecha_vencimiento_desde = filters.DateFilter(field_name='fecha_vencimiento', lookup_expr='gte')
    fecha_vencimiento_hasta = filters.DateFilter(field_name='fecha_vencimiento', lookup_expr='lte')
    activo = filters.BooleanFilter(field_name='activo')
    categoria = filters.NumberFilter(field_name='categoria_id')
    proveedor = filters.NumberFilter(field_name='proveedor_id')

    class Meta:
        model = Producto
        fields = []



class InventarioFilter(django_filters.FilterSet):
    producto = django_filters.CharFilter(field_name='producto__nombre', lookup_expr='icontains', label="Nombre del producto")
    sucursal = django_filters.NumberFilter(field_name='sucursal__id', label="ID de sucursal")
    cantidad_min = django_filters.NumberFilter(field_name='cantidad', lookup_expr='gte', label="Cantidad mínima")
    cantidad_max = django_filters.NumberFilter(field_name='cantidad', lookup_expr='lte', label="Cantidad máxima")

    class Meta:
        model = Inventario
        fields = ['producto', 'sucursal', 'cantidad_min', 'cantidad_max']


# --- /home/runner/workspace/inventario/models.py ---
# inventario/models.py

from django.db import models
from django.core.exceptions import ValidationError
from django.utils import timezone

class ClaveSATUnidad(models.Model):
    clave = models.CharField(max_length=10, unique=True)  # ej: "H87"
    descripcion = models.CharField(max_length=255)

    class Meta:
        verbose_name = "Clave SAT Unidad"
        verbose_name_plural = "Claves SAT Unidades"
        ordering = ['clave']

    def __str__(self):
        return f"{self.clave} - {self.descripcion}"

class ClaveSATProducto(models.Model):
    clave = models.CharField(max_length=20, unique=True)  # ej: "01010101"
    descripcion = models.CharField(max_length=255)
    unidad = models.ForeignKey(ClaveSATUnidad, on_delete=models.PROTECT, related_name='claves_productos')

    class Meta:
        verbose_name = "Clave SAT Producto"
        verbose_name_plural = "Claves SAT Productos"
        ordering = ['clave']

    def __str__(self):
        return f"{self.clave} - {self.descripcion} ({self.unidad.clave})"




class Categoria(models.Model):
    empresa = models.ForeignKey('core.Empresa', on_delete=models.CASCADE, related_name='categorias')
    nombre = models.CharField(max_length=100)
    descripcion = models.TextField(blank=True, null=True)

    class Meta:
        verbose_name = "Categoría"
        verbose_name_plural = "Categorías"
        ordering = ['nombre']
        indexes = [
            models.Index(fields=['empresa', 'nombre']),
        ]

    def __str__(self):
        return self.nombre


class Producto(models.Model):
    empresa = models.ForeignKey('core.Empresa', on_delete=models.CASCADE, related_name='productos')
    codigo = models.CharField(max_length=50, unique=True)
    nombre = models.CharField(max_length=100)
    descripcion = models.TextField(blank=True, null=True)

    # En vez de usar unidad_medida de texto libre, se apunta a clave SAT unidad
    unidad_medida = models.ForeignKey(
        ClaveSATUnidad,
        on_delete=models.PROTECT,
        related_name='productos',
        null=True,
        blank=True,
        help_text="Clave SAT de unidad de medida"
    )

    categoria = models.ForeignKey(Categoria, on_delete=models.CASCADE, related_name='productos')
    precio_compra = models.DecimalField(max_digits=10, decimal_places=2)
    precio_venta = models.DecimalField(max_digits=10, decimal_places=2)
    stock_minimo = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    activo = models.BooleanField(default=True)

    # Clave SAT del producto (por ejemplo para facturación electrónica)
    clave_sat = models.ForeignKey(
        ClaveSATProducto,
        on_delete=models.PROTECT,
        related_name='productos',
        null=True,
        blank=True,
        help_text="Clave SAT del producto o servicio"
    )

    def clean(self):
        if self.precio_venta < self.precio_compra:
            raise ValidationError("El precio de venta no puede ser menor que el precio de compra.")
        if self.precio_compra < 0 or self.precio_venta < 0:
            raise ValidationError("Los precios no pueden ser negativos.")
        if self.stock_minimo < 0:
            raise ValidationError("El stock mínimo no puede ser negativo.")

    class Meta:
        verbose_name = "Producto"
        verbose_name_plural = "Productos"
        ordering = ['nombre']
        indexes = [
            models.Index(fields=['empresa', 'codigo']),
            models.Index(fields=['categoria']),
        ]

    def __str__(self):
        return self.nombre


class Inventario(models.Model):
    producto = models.ForeignKey(Producto, on_delete=models.CASCADE, related_name='inventarios')
    sucursal = models.ForeignKey('core.Sucursal', on_delete=models.CASCADE, related_name='inventarios')
    lote = models.CharField(max_length=100, blank=True, null=True)
    fecha_vencimiento = models.DateField(blank=True, null=True)
    cantidad = models.DecimalField(max_digits=10, decimal_places=2)

    def clean(self):
        if self.cantidad < 0:
            raise ValidationError("La cantidad en inventario no puede ser negativa.")
        if self.fecha_vencimiento and self.fecha_vencimiento < timezone.now().date():
            raise ValidationError("La fecha de vencimiento no puede estar en el pasado.")


    class Meta:
        unique_together = ('producto', 'sucursal', 'lote', 'fecha_vencimiento')
        verbose_name = "Inventario"
        verbose_name_plural = "Inventarios"
        indexes = [
            models.Index(fields=['producto', 'sucursal']),
            models.Index(fields=['fecha_vencimiento']),
        ]
        ordering = ['producto']

    def __str__(self):
        return f"{self.producto.nombre} - {self.sucursal.nombre}"


class MovimientoInventario(models.Model):
    TIPO_CHOICES = [
        ('entrada', 'Entrada'),
        ('salida', 'Salida'),
        ('ajuste', 'Ajuste'),
    ]

    inventario = models.ForeignKey(Inventario, on_delete=models.CASCADE, related_name='movimientos')
    tipo_movimiento = models.CharField(max_length=10, choices=TIPO_CHOICES)
    cantidad = models.DecimalField(max_digits=14, decimal_places=2)
    fecha = models.DateTimeField(auto_now_add=True)
    usuario = models.ForeignKey('accounts.Usuario', on_delete=models.PROTECT, related_name='movimientos_inventario')

    class Meta:
        verbose_name = "Movimiento de Inventario"
        verbose_name_plural = "Movimientos de Inventario"
        ordering = ['-fecha']
        indexes = [
            models.Index(fields=['inventario', 'fecha']),
            models.Index(fields=['tipo_movimiento']),
        ]

    def __str__(self):
        return f"{self.get_tipo_movimiento_display()} - {self.cantidad} unidades - {self.fecha}"


# --- /home/runner/workspace/inventario/migrations/__init__.py ---



# --- /home/runner/workspace/inventario/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ClaveSATUnidad',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('clave', models.CharField(max_length=10, unique=True)),
                ('descripcion', models.CharField(max_length=255)),
            ],
            options={
                'verbose_name': 'Clave SAT Unidad',
                'verbose_name_plural': 'Claves SAT Unidades',
                'ordering': ['clave'],
            },
        ),
        migrations.CreateModel(
            name='Categoria',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nombre', models.CharField(max_length=100)),
                ('descripcion', models.TextField(blank=True, null=True)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='categorias', to='core.empresa')),
            ],
            options={
                'verbose_name': 'Categoría',
                'verbose_name_plural': 'Categorías',
                'ordering': ['nombre'],
            },
        ),
        migrations.CreateModel(
            name='ClaveSATProducto',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('clave', models.CharField(max_length=20, unique=True)),
                ('descripcion', models.CharField(max_length=255)),
                ('unidad', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='claves_productos', to='inventario.clavesatunidad')),
            ],
            options={
                'verbose_name': 'Clave SAT Producto',
                'verbose_name_plural': 'Claves SAT Productos',
                'ordering': ['clave'],
            },
        ),
        migrations.CreateModel(
            name='Inventario',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('lote', models.CharField(blank=True, max_length=100, null=True)),
                ('fecha_vencimiento', models.DateField(blank=True, null=True)),
                ('cantidad', models.DecimalField(decimal_places=2, max_digits=10)),
                ('sucursal', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='inventarios', to='core.sucursal')),
            ],
            options={
                'verbose_name': 'Inventario',
                'verbose_name_plural': 'Inventarios',
                'ordering': ['producto'],
            },
        ),
        migrations.CreateModel(
            name='MovimientoInventario',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('tipo_movimiento', models.CharField(choices=[('entrada', 'Entrada'), ('salida', 'Salida'), ('ajuste', 'Ajuste')], max_length=10)),
                ('cantidad', models.DecimalField(decimal_places=2, max_digits=14)),
                ('fecha', models.DateTimeField(auto_now_add=True)),
                ('inventario', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='movimientos', to='inventario.inventario')),
                ('usuario', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='movimientos_inventario', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Movimiento de Inventario',
                'verbose_name_plural': 'Movimientos de Inventario',
                'ordering': ['-fecha'],
            },
        ),
        migrations.CreateModel(
            name='Producto',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('codigo', models.CharField(max_length=50, unique=True)),
                ('nombre', models.CharField(max_length=100)),
                ('descripcion', models.TextField(blank=True, null=True)),
                ('precio_compra', models.DecimalField(decimal_places=2, max_digits=10)),
                ('precio_venta', models.DecimalField(decimal_places=2, max_digits=10)),
                ('stock_minimo', models.DecimalField(decimal_places=2, default=0, max_digits=10)),
                ('activo', models.BooleanField(default=True)),
                ('categoria', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='productos', to='inventario.categoria')),
                ('clave_sat', models.ForeignKey(blank=True, help_text='Clave SAT del producto o servicio', null=True, on_delete=django.db.models.deletion.PROTECT, related_name='productos', to='inventario.clavesatproducto')),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='productos', to='core.empresa')),
                ('unidad_medida', models.ForeignKey(blank=True, help_text='Clave SAT de unidad de medida', null=True, on_delete=django.db.models.deletion.PROTECT, related_name='productos', to='inventario.clavesatunidad')),
            ],
            options={
                'verbose_name': 'Producto',
                'verbose_name_plural': 'Productos',
                'ordering': ['nombre'],
            },
        ),
        migrations.AddField(
            model_name='inventario',
            name='producto',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='inventarios', to='inventario.producto'),
        ),
        migrations.AddIndex(
            model_name='categoria',
            index=models.Index(fields=['empresa', 'nombre'], name='inventario__empresa_ef6442_idx'),
        ),
        migrations.AddIndex(
            model_name='movimientoinventario',
            index=models.Index(fields=['inventario', 'fecha'], name='inventario__inventa_c73e96_idx'),
        ),
        migrations.AddIndex(
            model_name='movimientoinventario',
            index=models.Index(fields=['tipo_movimiento'], name='inventario__tipo_mo_89d562_idx'),
        ),
        migrations.AddIndex(
            model_name='producto',
            index=models.Index(fields=['empresa', 'codigo'], name='inventario__empresa_800e68_idx'),
        ),
        migrations.AddIndex(
            model_name='producto',
            index=models.Index(fields=['categoria'], name='inventario__categor_32aa4f_idx'),
        ),
        migrations.AddIndex(
            model_name='inventario',
            index=models.Index(fields=['producto', 'sucursal'], name='inventario__product_1e48f1_idx'),
        ),
        migrations.AddIndex(
            model_name='inventario',
            index=models.Index(fields=['fecha_vencimiento'], name='inventario__fecha_v_7b1ec0_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='inventario',
            unique_together={('producto', 'sucursal', 'lote', 'fecha_vencimiento')},
        ),
    ]



# --- /home/runner/workspace/inventario/views/__init__.py ---



# --- /home/runner/workspace/inventario/views/producto.py ---
from rest_framework import viewsets, filters
from django_filters.rest_framework import DjangoFilterBackend
from inventario.models import Producto
from inventario.serializers import ProductoSerializer
from inventario.filters import ProductoFilter
from rest_framework.permissions import IsAuthenticated

from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsInventario, OrPermissions

class ProductoViewSet(viewsets.ModelViewSet):
    serializer_class = ProductoSerializer
    permission_classes = [IsAuthenticated, OrPermissions(IsSuperAdmin, IsEmpresaAdmin, IsInventario)]

    queryset = Producto.objects.all()
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_class = ProductoFilter

    search_fields = ['codigo', 'nombre', 'descripcion', 'codigo_barras', 'lote']
    ordering_fields = ['nombre', 'precio_venta', 'stock', 'fecha_vencimiento']
    ordering = ['nombre']

    def get_queryset(self):
        return Producto.objects.filter(empresa=self.request.user.empresa)






# --- /home/runner/workspace/inventario/views/categoria.py ---
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from inventario.models import Categoria
from inventario.serializers import CategoriaSerializer

from accounts.permissions import IsAdminOrReadOnly

class CategoriaViewSet(viewsets.ModelViewSet):
    queryset = Categoria.objects.all()
    serializer_class = CategoriaSerializer
    permission_classes = [IsAuthenticated, IsAdminOrReadOnly]

    def get_queryset(self):
        # Multitenencia: cada usuario solo ve categorías de su empresa
        user = self.request.user
        return self.queryset.filter(empresa=user.empresa)

# from rest_framework import viewsets
# from rest_framework.permissions import IsAuthenticated
# from inventario.models import Categoria
# from inventario.serializers import CategoriaSerializer

# from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsInventario, OrPermissions

# class CategoriaViewSet(viewsets.ModelViewSet):
#     queryset = Categoria.objects.all()
#     serializer_class = CategoriaSerializer
#     permission_classes = [IsAuthenticated, OrPermissions(IsSuperAdmin, IsEmpresaAdmin, IsInventario)]

#     def get_queryset(self):
#         # Multitenencia: cada usuario solo ve categorías de su empresa
#         user = self.request.user
#         return self.queryset.filter(empresa=user.empresa)





# --- /home/runner/workspace/inventario/views/inventario.py ---
# inventario/views/inventario.py

from rest_framework import viewsets, filters
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend

from inventario.models import Inventario
from inventario.serializers import InventarioSerializer
from inventario.filters import InventarioFilter
from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsInventario, OrPermissions

class InventarioViewSet(viewsets.ModelViewSet):
    queryset = Inventario.objects.select_related('producto', 'sucursal')
    serializer_class = InventarioSerializer
    permission_classes = [IsAuthenticated, OrPermissions(IsSuperAdmin, IsEmpresaAdmin, IsInventario)]

    filter_backends = [DjangoFilterBackend, filters.OrderingFilter, filters.SearchFilter]
    filterset_class = InventarioFilter
    search_fields = ['producto__nombre', 'sucursal__nombre']  # Búsqueda libre
    ordering_fields = ['cantidad', 'producto__nombre', 'sucursal__nombre']
    ordering = ['-cantidad']  # Orden por defecto

    def get_queryset(self):
        user = self.request.user
        return self.queryset.filter(producto__empresa=user.empresa)

# from rest_framework import viewsets
# from rest_framework.permissions import IsAuthenticated
# from inventario.models import Inventario
# from inventario.serializers import InventarioSerializer

# from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsInventario, OrPermissions

# class InventarioViewSet(viewsets.ModelViewSet):
#     queryset = Inventario.objects.select_related('producto', 'sucursal')
#     serializer_class = InventarioSerializer
#     permission_classes = [IsAuthenticated, OrPermissions(IsSuperAdmin, IsEmpresaAdmin, IsInventario)]

#     def get_queryset(self):
#         user = self.request.user
#         return self.queryset.filter(producto__empresa=user.empresa)



# --- /home/runner/workspace/inventario/views/movimiento.py ---
from rest_framework import viewsets, serializers
from rest_framework.permissions import IsAuthenticated
from inventario.models import MovimientoInventario, Inventario
from inventario.serializers import MovimientoInventarioSerializer

from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsInventario, OrPermissions
from accounts.models import Auditoria  # 👈 Auditoría personalizada


class MovimientoInventarioViewSet(viewsets.ModelViewSet):
    serializer_class = MovimientoInventarioSerializer
    permission_classes = [IsAuthenticated, OrPermissions(IsSuperAdmin, IsEmpresaAdmin, IsInventario)]

    def get_queryset(self):
        user = self.request.user
        return MovimientoInventario.objects.filter(inventario__producto__empresa=user.empresa).order_by('-fecha')

    def perform_create(self, serializer):
        movimiento = serializer.save(usuario=self.request.user)
        inventario = movimiento.inventario
        cantidad = movimiento.cantidad

        if movimiento.tipo_movimiento == 'salida':
            if cantidad > inventario.cantidad:
                raise serializers.ValidationError("No hay suficiente inventario para esta salida.")
            inventario.cantidad -= cantidad

        elif movimiento.tipo_movimiento == 'entrada':
            inventario.cantidad += cantidad

        elif movimiento.tipo_movimiento == 'ajuste':
            # Lógica personalizada según sea necesario
            pass

        inventario.full_clean()
        inventario.save()

        # 📝 Auditoría
        Auditoria.objects.create(
            usuario=self.request.user,
            accion='crear',
            tabla_afectada='MovimientoInventario',
            registro_afectado=f"ID: {movimiento.id}, Tipo: {movimiento.tipo_movimiento}, Cantidad: {movimiento.cantidad}"
        )

    def perform_update(self, serializer):
        movimiento = serializer.save()

        # No se actualiza inventario directamente desde aquí (recomendado)
        # Pero puedes auditar igual:
        Auditoria.objects.create(
            usuario=self.request.user,
            accion='actualizar',
            tabla_afectada='MovimientoInventario',
            registro_afectado=f"ID: {movimiento.id}, Tipo: {movimiento.tipo_movimiento}, Cantidad: {movimiento.cantidad}"
        )

    def perform_destroy(self, instance):
        # Guarda info antes de borrar
        info = f"ID: {instance.id}, Tipo: {instance.tipo_movimiento}, Cantidad: {instance.cantidad}"
        instance.delete()

        Auditoria.objects.create(
            usuario=self.request.user,
            accion='eliminar',
            tabla_afectada='MovimientoInventario',
            registro_afectado=info
        )






# from rest_framework import viewsets, serializers
# from rest_framework.permissions import IsAuthenticated
# from inventario.models import MovimientoInventario, Inventario
# from inventario.serializers import MovimientoInventarioSerializer

# from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsInventario, OrPermissions

# class MovimientoInventarioViewSet(viewsets.ModelViewSet):
#     serializer_class = MovimientoInventarioSerializer
#     permission_classes = [IsAuthenticated, OrPermissions(IsSuperAdmin, IsEmpresaAdmin, IsInventario)]

#     def get_queryset(self):
#         user = self.request.user
#         return MovimientoInventario.objects.filter(inventario__producto__empresa=user.empresa).order_by('-fecha')

#     def perform_create(self, serializer):
#         movimiento = serializer.save(usuario=self.request.user)
#         inventario = movimiento.inventario
#         cantidad = movimiento.cantidad

#         if movimiento.tipo_movimiento == 'salida':
#             if cantidad > inventario.cantidad:
#                 raise serializers.ValidationError("No hay suficiente inventario para esta salida.")
#             inventario.cantidad -= cantidad

#         elif movimiento.tipo_movimiento == 'entrada':
#             inventario.cantidad += cantidad

#         elif movimiento.tipo_movimiento == 'ajuste':
#             # Puedes definir reglas personalizadas si se desea
#             pass

#         # Validación final y guardado
#         inventario.full_clean()
#         inventario.save()



# # from rest_framework import viewsets
# # from rest_framework.permissions import IsAuthenticated
# # from inventario.models import MovimientoInventario
# # from inventario.serializers import MovimientoInventarioSerializer

# # from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsInventario, OrPermissions

# # class MovimientoInventarioViewSet(viewsets.ModelViewSet):
# #     serializer_class = MovimientoInventarioSerializer
# #     permission_classes = [IsAuthenticated, OrPermissions(IsSuperAdmin, IsEmpresaAdmin, IsInventario)]

# #     def get_queryset(self):
# #         user = self.request.user
# #         return MovimientoInventario.objects.filter(producto__empresa=user.empresa).order_by('-fecha')

# # # inventario/views/movimiento.py

# # from rest_framework import viewsets
# # from inventario.models import MovimientoInventario
# # from inventario.serializers import MovimientoInventarioSerializer

# # class MovimientoInventarioViewSet(viewsets.ModelViewSet):  # ✅ debe ser ModelViewSet
# #     queryset = MovimientoInventario.objects.all()
# #     serializer_class = MovimientoInventarioSerializer



# --- /home/runner/workspace/inventario/views/batches.py ---
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from inventario.models import Inventario
from inventario.serializers import InventarioSerializer, BatchSerializer
from django.utils import timezone

from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsInventario, OrPermissions
from datetime import timedelta

class BatchView(APIView):
    permission_classes = [IsAuthenticated, OrPermissions(IsSuperAdmin, IsEmpresaAdmin, IsInventario)]

    def get(self, request):
        user = request.user
        hoy = timezone.now().date()
        alerta_hasta = hoy + timedelta(days=30)

        inventarios = Inventario.objects.select_related('producto').filter(
            producto__empresa=user.empresa,
            fecha_vencimiento__isnull=False,
            fecha_vencimiento__gte=hoy,
            fecha_vencimiento__lte=alerta_hasta
        ).order_by('fecha_vencimiento')

        serializer = BatchSerializer(inventarios, many=True)
        return Response(serializer.data)






# # inventario/views/batches.py

# from rest_framework.views import APIView
# from rest_framework.response import Response
# from rest_framework.permissions import IsAuthenticated
# from inventario.models import Inventario
# from inventario.serializers import InventarioSerializer
# from django.utils import timezone

# class BatchView(APIView):
#     permission_classes = [IsAuthenticated]

#     def get(self, request):
#         empresa = request.user.empresa
#         hoy = timezone.now().date()
#         inventarios = Inventario.objects.filter(
#             producto__empresa=empresa,
#             fecha_vencimiento__isnull=False
#         ).order_by('fecha_vencimiento')

#         serializer = InventarioSerializer(inventarios, many=True)
#         return Response(serializer.data)



# --- /home/runner/workspace/inventario/views/stock_alerts.py ---
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.db.models import F

from inventario.models import Producto
from inventario.serializers import ProductoSerializer

from accounts.permissions import IsSuperAdminOrEmpresaAdmin, IsInventario
from django.db.models import Sum

# inventario/views/stock_alerts.py (o donde prefieras)

from datetime import date, timedelta
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

# from inventario.models import Batch
from inventario.serializers import BatchSerializer

from accounts.permissions import IsSuperAdminOrEmpresaAdmin, IsInventario

class ExpirationAlertView(APIView):
    permission_classes = [IsAuthenticated & (IsSuperAdminOrEmpresaAdmin | IsInventario)]

    def get(self, request):
        empresa = request.user.empresa
        hoy = date.today()
        alerta_hasta = hoy + timedelta(days=30)  # Próximos 30 días

        lotes_proximos_a_vencer = Batch.objects.filter(
            empresa=empresa,
            activo=True,
            fecha_vencimiento__lte=alerta_hasta,
            fecha_vencimiento__gte=hoy
        ).order_by('fecha_vencimiento')

        serializer = BatchSerializer(lotes_proximos_a_vencer, many=True)
        return Response(serializer.data)

class StockAlertView(APIView):
    permission_classes = [IsAuthenticated & (IsSuperAdminOrEmpresaAdmin | IsInventario)]

    def get(self, request):
        empresa = request.user.empresa
        productos_alerta = Producto.objects.filter(
            empresa=empresa,
            activo=True
        ).annotate(
            stock_total=Sum('inventarios__cantidad')
        ).filter(
            stock_total__lt=F('stock_minimo')
        )

        serializer = ProductoSerializer(productos_alerta, many=True)
        return Response(serializer.data)



# from rest_framework.views import APIView
# from rest_framework.response import Response
# from rest_framework.permissions import IsAuthenticated
# from django.db.models import F

# from inventario.models import Producto
# from inventario.serializers import ProductoSerializer

# from accounts.permissions import IsSuperAdminOrEmpresaAdmin, IsInventario

# class StockAlertView(APIView):
#     permission_classes = [IsAuthenticated & (IsSuperAdminOrEmpresaAdmin | IsInventario)]

#     def get(self, request):
#         empresa = request.user.empresa
#         productos_alerta = Producto.objects.filter(
#             empresa=empresa,
#             activo=True,
#             inventarios__cantidad__lt=F('stock_minimo')
#         ).distinct()

#         serializer = ProductoSerializer(productos_alerta, many=True)
#         return Response(serializer.data)



# --- /home/runner/workspace/inventario/serializers/inventario_serializers.py ---
from rest_framework import serializers
from inventario.models import Inventario

class InventarioSerializer(serializers.ModelSerializer):
    producto_nombre = serializers.CharField(source='producto.nombre', read_only=True)
    sucursal_nombre = serializers.CharField(source='sucursal.nombre', read_only=True)

    class Meta:
        model = Inventario
        fields = [
            'id', 'producto', 'producto_nombre', 'sucursal', 'sucursal_nombre',
            'lote', 'fecha_vencimiento', 'cantidad'
        ]
        read_only_fields = ['id']

    def validate_cantidad(self, value):
        if value < 0:
            raise serializers.ValidationError("La cantidad no puede ser negativa.")
        return value



# --- /home/runner/workspace/inventario/serializers/categoria_serializers.py ---
from rest_framework import serializers
from inventario.models import Categoria

class CategoriaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Categoria
        fields = '__all__'
        read_only_fields = ['id']



# --- /home/runner/workspace/inventario/serializers/batch_serializer.py ---
# inventario/serializers.py
from rest_framework import serializers
from inventario.models import Inventario

class BatchSerializer(serializers.ModelSerializer):
    producto_nombre = serializers.CharField(source='producto.nombre', read_only=True)

    class Meta:
        model = Inventario
        fields = ['id', 'producto', 'producto_nombre', 'cantidad', 'fecha_vencimiento', 'ubicacion']



# --- /home/runner/workspace/inventario/serializers/__init__.py ---
from .categoria_serializers import CategoriaSerializer
from .producto_serializers import ProductoSerializer
from .inventario_serializers import InventarioSerializer
from .movimiento_inventario_serializers import MovimientoInventarioSerializer
from .batch_serializer import BatchSerializer

__all__ = [
    'CategoriaSerializer',
    'ProductoSerializer',
    'InventarioSerializer',
    'MovimientoInventarioSerializer',
    'BatchSerializer',
]


# --- /home/runner/workspace/inventario/serializers/movimiento_inventario_serializers.py ---
from rest_framework import serializers
from inventario.models import MovimientoInventario

class MovimientoInventarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = MovimientoInventario
        fields = '__all__'

    def validate(self, data):
        producto = data['producto']
        tipo = data['tipo']
        cantidad = data['cantidad']

        if tipo == 'salida' and producto.stock < cantidad:
            raise serializers.ValidationError("Stock insuficiente para salida.")

        return data

    def create(self, validated_data):
        producto = validated_data['producto']
        tipo = validated_data['tipo']
        cantidad = validated_data['cantidad']

        if tipo == 'entrada':
            producto.stock += cantidad
        elif tipo == 'salida':
            producto.stock -= cantidad
        elif tipo == 'ajuste':
            producto.stock = cantidad  # Ajuste directo

        producto.save()
        return super().create(validated_data)



# --- /home/runner/workspace/inventario/serializers/producto_serializers.py ---
from rest_framework import serializers
from inventario.models import Producto

class ProductoSerializer(serializers.ModelSerializer):
    categoria_nombre = serializers.CharField(source='categoria.nombre', read_only=True)

    class Meta:
        model = Producto
        fields = [
            'id', 'empresa', 'codigo', 'nombre', 'descripcion', 'unidad_medida', 'categoria',
            'categoria_nombre', 'precio_compra', 'precio_venta', 'stock_minimo', 'activo', 'clave_sat'
        ]
        read_only_fields = ['id']

    def validate(self, data):
        precio_venta = data.get('precio_venta', getattr(self.instance, 'precio_venta', None))
        precio_compra = data.get('precio_compra', getattr(self.instance, 'precio_compra', None))

        if precio_venta is not None and precio_compra is not None:
            if precio_venta < precio_compra:
                raise serializers.ValidationError("El precio de venta no puede ser menor que el de compra.")

        return data





# === Archivo: ventas_combined.py ===

# --- /home/runner/workspace/ventas/__init__.py ---



# --- /home/runner/workspace/ventas/admin.py ---
from django.contrib import admin

# Register your models here.



# --- /home/runner/workspace/ventas/apps.py ---
from django.apps import AppConfig


class VentasConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ventas'



# --- /home/runner/workspace/ventas/tests.py ---
from django.test import TestCase

# Create your tests here.



# --- /home/runner/workspace/ventas/signals.py ---
# ventas/signals.py

from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.db.models import Sum, F
from .models import DetalleVenta, Venta

def actualizar_total_venta(venta_id):
    try:
        venta = Venta.objects.get(id=venta_id)
    except Venta.DoesNotExist:
        return  # Si no existe, nada que hacer

    total = venta.detalles.aggregate(
        total=Sum(F('cantidad') * F('precio_unitario'))
    )['total'] or 0

    # Actualizar solo si cambió para evitar saves innecesarios
    if venta.total != total:
        venta.total = total
        venta.save(update_fields=['total'])

@receiver(post_save, sender=DetalleVenta)
def detalleventa_guardado(sender, instance, **kwargs):
    actualizar_total_venta(instance.venta_id)

@receiver(post_delete, sender=DetalleVenta)
def detalleventa_eliminado(sender, instance, **kwargs):
    actualizar_total_venta(instance.venta_id)



# --- /home/runner/workspace/ventas/app.py ---
# ventas/apps.py

from django.apps import AppConfig

class VentasConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'ventas'

    def ready(self):
        import ventas.signals



# --- /home/runner/workspace/ventas/utils.py ---
import xml.etree.ElementTree as ET
from django.core.files.base import ContentFile
from django.utils import timezone

def generar_xml_desde_comprobante(comprobante):
    """
    Genera un XML básico desde un objeto comprobante.
    Ajusta esto según el estándar fiscal (ej. CFDI, UBL, etc.).
    """
    # Estructura básica del XML
    root = ET.Element("Comprobante")
    ET.SubElement(root, "UUID").text = comprobante.uuid if hasattr(comprobante, 'uuid') else "UUID-Generico"
    ET.SubElement(root, "Fecha").text = timezone.now().isoformat()
    ET.SubElement(root, "Total").text = str(comprobante.total)

    # Agrega otros campos relevantes aquí
    # ...

    # Convierte el árbol a una cadena de bytes
    xml_string = ET.tostring(root, encoding="utf-8", method="xml")

    # Opcional: Guarda el XML en el modelo (si tiene campo FileField)
    if hasattr(comprobante, 'archivo_xml'):
        comprobante.archivo_xml.save(f"{comprobante.id}.xml", ContentFile(xml_string), save=True)

    return xml_string


# --- /home/runner/workspace/ventas/urls.py ---
# ventas/urls.py

from rest_framework.routers import DefaultRouter
from django.urls import path
from ventas.views import ClienteViewSet, VentaViewSet, DetalleVentaViewSet
from ventas.views.dashboard import VentaDashboardAPIView  # Asegúrate de importar desde el archivo correcto
# from ventas.views.facturar_venta import FacturarVentaAPIView  # Asegúrate que esta vista existe y está bien importada
# Instanciamos el router
router = DefaultRouter()
router.register(r'costumers', ClienteViewSet)
router.register(r'orders', VentaViewSet)
router.register(r'details', DetalleVentaViewSet)

# Añadimos el endpoint del dashboard de ventas fuera del router
urlpatterns = router.urls + [
    path('dashboard/', VentaDashboardAPIView.as_view(), name='venta-dashboard'),
    # path('invoice-sale/<int:id>/', FacturarVentaAPIView.as_view(), name='facturar-venta'),
]




# --- /home/runner/workspace/ventas/models.py ---
# ventas/models.py (completado)

from django.db import models
from django.core.exceptions import ValidationError
from django.utils import timezone
from decimal import Decimal
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver

class Cliente(models.Model):
    empresa = models.ForeignKey('core.Empresa', on_delete=models.CASCADE, related_name='clientes')
    nombre = models.CharField(max_length=200)
    apellido_paterno = models.CharField(max_length=100, blank=True, null=True)
    apellido_materno = models.CharField(max_length=100, blank=True, null=True)
    rfc = models.CharField(max_length=13, blank=True, null=True)
    correo = models.EmailField(blank=True, null=True)
    telefono = models.CharField(max_length=20, blank=True, null=True)
    creado_en = models.DateTimeField(auto_now_add=True)
    actualizado_en = models.DateTimeField(auto_now=True)
    uso_cfdi = models.CharField(max_length=3, blank=True, null=True, help_text="Uso CFDI SAT (G03, S01, etc.)")
    regimen_fiscal = models.CharField(max_length=3, blank=True, null=True, help_text="Régimen fiscal del receptor")

    direccion_calle = models.CharField(max_length=150, blank=True, null=True)
    direccion_num_ext = models.CharField(max_length=10, blank=True, null=True)
    direccion_num_int = models.CharField(max_length=10, blank=True, null=True)
    direccion_colonia = models.CharField(max_length=100, blank=True, null=True)
    direccion_municipio = models.CharField(max_length=100, blank=True, null=True)
    direccion_estado = models.CharField(max_length=100, blank=True, null=True)
    direccion_pais = models.CharField(max_length=50, default='MEX')
    direccion_codigo_postal = models.CharField(max_length=10, blank=True, null=True)

    class Meta:
        verbose_name = "Cliente"
        verbose_name_plural = "Clientes"
        ordering = ['nombre']
        indexes = [
            models.Index(fields=['empresa', 'nombre']),
        ]

    @property
    def nombre_completo(self):
        apellidos = ' '.join(filter(None, [self.apellido_paterno, self.apellido_materno]))
        return f"{self.nombre} {apellidos}".strip()

    def clean(self):
        if self.rfc and self.uso_cfdi == "P01" and self.rfc != "XAXX010101000":
            raise ValidationError("El uso CFDI 'P01' solo es válido con RFC genérico.")

    def __str__(self):
        return self.nombre


class Venta(models.Model):
    ESTADO_CHOICES = [
        ('PENDIENTE', 'Pendiente'),
        ('COMPLETADA', 'Completada'),
        ('CANCELADA', 'Cancelada'),
    ]

    empresa = models.ForeignKey('core.Empresa', on_delete=models.CASCADE, related_name='ventas')
    cliente = models.ForeignKey(Cliente, on_delete=models.PROTECT, related_name='ventas')
    fecha = models.DateTimeField(auto_now_add=True)
    total = models.DecimalField(max_digits=14, decimal_places=2)
    estado = models.CharField(max_length=10, choices=ESTADO_CHOICES, default='PENDIENTE')
    usuario = models.ForeignKey('accounts.Usuario', on_delete=models.PROTECT, related_name='ventas')
    condiciones_pago = models.CharField(max_length=100, blank=True, null=True, help_text="Ej: Contado, Crédito 30 días")
    moneda = models.CharField(max_length=5, blank=True, null=True, default="MXN", help_text="Ej: MXN, USD")

    FORMA_PAGO_CHOICES = [
        ('01', 'Efectivo'),
        ('02', 'Cheque nominativo'),
        ('03', 'Transferencia electrónica de fondos'),
        ('04', 'Tarjeta de crédito'),
        ('05', 'Monedero electrónico'),
        ('06', 'Dinero electrónico'),
        ('08', 'Vales de despensa'),
        ('12', 'Dación en pago'),
        ('13', 'Pago por subrogación'),
        ('14', 'Pago por consignación'),
        ('15', 'Condonación'),
        ('17', 'Compensación'),
        ('23', 'Novación'),
        ('24', 'Confusión'),
        ('25', 'Remisión de deuda'),
        ('26', 'Prescripción o caducidad'),
        ('27', 'A satisfacción del acreedor'),
        ('28', 'Tarjeta de débito'),
        ('29', 'Tarjeta de servicios'),
        ('30', 'Aplicación de anticipos'),
        ('31', 'Intermediario pagos'),
        ('99', 'Por definir'),
    ]

    METODO_PAGO_CHOICES = [
        ('PUE', 'Pago en una sola exhibición'),
        ('PPD', 'Pago en parcialidades o diferido'),
    ]

    forma_pago = models.CharField(
        max_length=2,
        choices=FORMA_PAGO_CHOICES,
        default='01'
    )

    metodo_pago = models.CharField(
        max_length=3,
        choices=METODO_PAGO_CHOICES,
        default='PUE'
    )

    def calcular_total(self):
        # Solo calcular si ya tenemos un ID (la venta ya fue guardada)
        if self.pk:
            self.total = sum(detalle.precio_unitario * detalle.cantidad for detalle in self.detalles.all())
        else:
            # Si no tiene ID, establecer total en 0 inicialmente
            self.total = 0

    def save(self, *args, **kwargs):
        if not self.pk:
            self.total = 0
        super().save(*args, **kwargs)

    class Meta:
        verbose_name = "Venta"
        verbose_name_plural = "Ventas"
        ordering = ['-fecha']
        indexes = [
            models.Index(fields=['empresa', 'fecha']),
            models.Index(fields=['estado']),
        ]

    def __str__(self):
        return f"Venta {self.id} - {self.cliente.nombre} - {self.estado}"


class DetalleVenta(models.Model):
    venta = models.ForeignKey(Venta, on_delete=models.CASCADE, related_name='detalles')
    producto = models.ForeignKey('inventario.Producto', on_delete=models.PROTECT, related_name='ventas_detalle')
    cantidad = models.DecimalField(max_digits=14, decimal_places=2)
    precio_unitario = models.DecimalField(max_digits=14, decimal_places=2)

    @property
    def importe(self):
        return Decimal(self.precio_unitario) * Decimal(self.cantidad)


    def clean(self):
        if self.cantidad <= 0:
            raise ValidationError("La cantidad debe ser mayor a cero.")
        if self.precio_unitario <= 0:
            raise ValidationError("El precio unitario debe ser mayor a cero.")

    class Meta:
        verbose_name = "Detalle de Venta"
        verbose_name_plural = "Detalles de Venta"
        indexes = [
            models.Index(fields=['producto']),
        ]

    def __str__(self):
        return f"{self.cantidad} x {self.producto.nombre} @ {self.precio_unitario}"

@receiver([post_save, post_delete], sender=DetalleVenta)
def actualizar_total_venta(sender, instance, **kwargs):
    venta = instance.venta
    total = venta.detalles.aggregate(
        total=models.Sum(models.F('precio_unitario') * models.F('cantidad'))
    )['total'] or 0
    venta.total = total
    venta.save(update_fields=['total'])


# --- /home/runner/workspace/ventas/migrations/__init__.py ---



# --- /home/runner/workspace/ventas/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
        ('inventario', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Cliente',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nombre', models.CharField(max_length=200)),
                ('apellido_paterno', models.CharField(blank=True, max_length=100, null=True)),
                ('apellido_materno', models.CharField(blank=True, max_length=100, null=True)),
                ('rfc', models.CharField(blank=True, max_length=13, null=True)),
                ('correo', models.EmailField(blank=True, max_length=254, null=True)),
                ('telefono', models.CharField(blank=True, max_length=20, null=True)),
                ('creado_en', models.DateTimeField(auto_now_add=True)),
                ('actualizado_en', models.DateTimeField(auto_now=True)),
                ('uso_cfdi', models.CharField(blank=True, help_text='Uso CFDI SAT (G03, S01, etc.)', max_length=3, null=True)),
                ('regimen_fiscal', models.CharField(blank=True, help_text='Régimen fiscal del receptor', max_length=3, null=True)),
                ('direccion_calle', models.CharField(blank=True, max_length=150, null=True)),
                ('direccion_num_ext', models.CharField(blank=True, max_length=10, null=True)),
                ('direccion_num_int', models.CharField(blank=True, max_length=10, null=True)),
                ('direccion_colonia', models.CharField(blank=True, max_length=100, null=True)),
                ('direccion_municipio', models.CharField(blank=True, max_length=100, null=True)),
                ('direccion_estado', models.CharField(blank=True, max_length=100, null=True)),
                ('direccion_pais', models.CharField(default='MEX', max_length=50)),
                ('direccion_codigo_postal', models.CharField(blank=True, max_length=10, null=True)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='clientes', to='core.empresa')),
            ],
            options={
                'verbose_name': 'Cliente',
                'verbose_name_plural': 'Clientes',
                'ordering': ['nombre'],
            },
        ),
        migrations.CreateModel(
            name='Venta',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('fecha', models.DateTimeField(auto_now_add=True)),
                ('total', models.DecimalField(decimal_places=2, max_digits=14)),
                ('estado', models.CharField(choices=[('PENDIENTE', 'Pendiente'), ('COMPLETADA', 'Completada'), ('CANCELADA', 'Cancelada')], default='PENDIENTE', max_length=10)),
                ('condiciones_pago', models.CharField(blank=True, help_text='Ej: Contado, Crédito 30 días', max_length=100, null=True)),
                ('moneda', models.CharField(blank=True, default='MXN', help_text='Ej: MXN, USD', max_length=5, null=True)),
                ('forma_pago', models.CharField(choices=[('01', 'Efectivo'), ('02', 'Cheque nominativo'), ('03', 'Transferencia electrónica de fondos'), ('04', 'Tarjeta de crédito'), ('05', 'Monedero electrónico'), ('06', 'Dinero electrónico'), ('08', 'Vales de despensa'), ('12', 'Dación en pago'), ('13', 'Pago por subrogación'), ('14', 'Pago por consignación'), ('15', 'Condonación'), ('17', 'Compensación'), ('23', 'Novación'), ('24', 'Confusión'), ('25', 'Remisión de deuda'), ('26', 'Prescripción o caducidad'), ('27', 'A satisfacción del acreedor'), ('28', 'Tarjeta de débito'), ('29', 'Tarjeta de servicios'), ('30', 'Aplicación de anticipos'), ('31', 'Intermediario pagos'), ('99', 'Por definir')], default='01', max_length=2)),
                ('metodo_pago', models.CharField(choices=[('PUE', 'Pago en una sola exhibición'), ('PPD', 'Pago en parcialidades o diferido')], default='PUE', max_length=3)),
                ('cliente', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='ventas', to='ventas.cliente')),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='ventas', to='core.empresa')),
                ('usuario', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='ventas', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Venta',
                'verbose_name_plural': 'Ventas',
                'ordering': ['-fecha'],
            },
        ),
        migrations.CreateModel(
            name='DetalleVenta',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cantidad', models.DecimalField(decimal_places=2, max_digits=14)),
                ('precio_unitario', models.DecimalField(decimal_places=2, max_digits=14)),
                ('producto', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='ventas_detalle', to='inventario.producto')),
                ('venta', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='detalles', to='ventas.venta')),
            ],
            options={
                'verbose_name': 'Detalle de Venta',
                'verbose_name_plural': 'Detalles de Venta',
            },
        ),
        migrations.AddIndex(
            model_name='cliente',
            index=models.Index(fields=['empresa', 'nombre'], name='ventas_clie_empresa_dbb1c0_idx'),
        ),
        migrations.AddIndex(
            model_name='venta',
            index=models.Index(fields=['empresa', 'fecha'], name='ventas_vent_empresa_f0b283_idx'),
        ),
        migrations.AddIndex(
            model_name='venta',
            index=models.Index(fields=['estado'], name='ventas_vent_estado_b0d674_idx'),
        ),
        migrations.AddIndex(
            model_name='detalleventa',
            index=models.Index(fields=['producto'], name='ventas_deta_product_0f454d_idx'),
        ),
    ]



# --- /home/runner/workspace/ventas/filters/clientes.py ---
# ventas/filters/clientes.py
import django_filters
from ventas.models import Cliente

class ClienteFilter(django_filters.FilterSet):
    nombre = django_filters.CharFilter(lookup_expr='icontains')
    rfc = django_filters.CharFilter(lookup_expr='icontains')
    correo = django_filters.CharFilter(lookup_expr='icontains')
    telefono = django_filters.CharFilter(lookup_expr='icontains')
    creado_en = django_filters.DateFromToRangeFilter()

    class Meta:
        model = Cliente
        fields = ['empresa', 'nombre', 'rfc', 'correo', 'telefono', 'creado_en']



# --- /home/runner/workspace/ventas/serializers/cliente_serializer.py ---
from rest_framework import serializers
from ventas.models import Cliente

class ClienteSerializer(serializers.ModelSerializer):
    class Meta:
        model = Cliente
        fields = [
            'id',
            'empresa',
            'nombre',
            'rfc',
            'correo',
            'telefono',
            'direccion',
            'creado_en',
            'actualizado_en',
        ]
        read_only_fields = ['id', 'creado_en', 'actualizado_en']



# --- /home/runner/workspace/ventas/serializers/__init__.py ---
from .cliente_serializer import ClienteSerializer
from .detalle_venta_serializer import DetalleVentaSerializer
from .venta_serializer import VentaSerializer


# --- /home/runner/workspace/ventas/serializers/detalle_venta_serializer.py ---
from rest_framework import serializers
from ventas.models import DetalleVenta
from inventario.models import Inventario

class DetalleVentaSerializer(serializers.ModelSerializer):
    producto_nombre = serializers.CharField(source='producto.nombre', read_only=True)
    subtotal = serializers.SerializerMethodField()

    class Meta:
        model = DetalleVenta
        fields = [
            'id',
            'producto',
            'producto_nombre',
            'cantidad',
            'precio_unitario',
            'subtotal',
        ]

    def get_subtotal(self, obj):
        return obj.cantidad * obj.precio_unitario

    def validate(self, data):
        cantidad = data.get('cantidad')
        precio_unitario = data.get('precio_unitario')
        producto = data.get('producto')

        if cantidad is None or cantidad <= 0:
            raise serializers.ValidationError("La cantidad debe ser mayor a cero.")
        if precio_unitario is None or precio_unitario <= 0:
            raise serializers.ValidationError("El precio unitario debe ser mayor a cero.")
        if producto is None:
            raise serializers.ValidationError("El producto es obligatorio.")

        # Obtener todos los inventarios asociados al producto
        inventarios = Inventario.objects.filter(producto=producto)

        # Sumar la cantidad disponible de los inventarios
        stock_disponible = sum(inventario.cantidad for inventario in inventarios)

        # Verificar si hay suficiente stock
        if stock_disponible < cantidad:
            raise serializers.ValidationError(
                f"No hay suficiente stock para el producto '{producto.nombre}'. Stock disponible: {stock_disponible}"
            )

        return data



# --- /home/runner/workspace/ventas/serializers/venta_serializer.py ---
from rest_framework import serializers
from ventas.models import Venta, DetalleVenta
from .detalle_venta_serializer import DetalleVentaSerializer
from inventario.models import Producto, Inventario
from contabilidad.helpers.asientos import generar_asiento_para_venta
from django.db import transaction
from datetime import timedelta
from decimal import Decimal, ROUND_HALF_UP
from django.db.models import F
from django.conf import settings
import base64
from django.core.files.base import ContentFile
from django.utils import timezone
from rest_framework.exceptions import ValidationError as DRFValidationError
from facturacion.models import MetodoPagoChoices, FormaPagoChoices, ComprobanteFiscal
from facturacion.services.facturama import FacturamaService
from facturacion.utils.build_facturama_payload import build_facturama_payload
# from facturacion.utils.build_facturama_payload import MetodoPagoChoices
from finanzas.models import CuentaPorCobrar
from django.db.models import TextChoices

from facturacion.services.timbrado_helpers import intentar_timbrado_comprobante

def redondear_decimal(valor, decimales=2):
    if not isinstance(valor, Decimal):
        valor = Decimal(str(valor))
    return valor.quantize(Decimal('1.' + '0' * decimales), rounding=ROUND_HALF_UP)

class VentaSerializer(serializers.ModelSerializer):
    detalles = DetalleVentaSerializer(many=True)
    cliente_nombre = serializers.CharField(source='cliente.nombre', read_only=True)
    usuario_username = serializers.CharField(source='usuario.username', read_only=True)

    class Meta:
        model = Venta
        fields = [
            'id',
            'empresa',
            'cliente',
            'cliente_nombre',
            'usuario',
            'usuario_username',
            'fecha',
            'total',
            'estado',
            'forma_pago',
            'metodo_pago',
            'condiciones_pago',
            'detalles'
        ]
        read_only_fields = ['id', 'fecha', 'total']

    @transaction.atomic
    def create(self, validated_data):
        detalles_data = validated_data.pop('detalles')

        request = self.context.get('request')
        usuario = request.user if request else None
        empresa = getattr(usuario, 'empresa', None)

        if usuario is None:
            raise DRFValidationError("Usuario no autenticado.")
        if empresa is None:
            raise DRFValidationError("El usuario no tiene una empresa asignada.")

        # 1. Crear la venta
        venta = Venta(**validated_data)
        venta.usuario = usuario
        venta.empresa = empresa
        venta.save()

        # 2. Crear detalles y actualizar inventario
        total_calculado = Decimal('0.00')
        detalles = []

        for detalle_data in detalles_data:
            producto = detalle_data['producto']
            cantidad = detalle_data.get('cantidad')
            precio_unitario = detalle_data.get('precio_unitario')

            inventario = Inventario.objects.select_for_update().filter(
                producto=producto,
                sucursal__empresa=empresa
            ).first()

            if not inventario:
                raise DRFValidationError(f"No hay inventario para el producto {producto.nombre}")

            if inventario.cantidad < cantidad:
                raise DRFValidationError(f"Stock insuficiente para producto {producto.nombre}")

            inventario.cantidad = F('cantidad') - cantidad
            inventario.save()
            inventario.refresh_from_db()

            detalle = DetalleVenta(venta=venta, **detalle_data)
            detalles.append(detalle)

            total_calculado += cantidad * precio_unitario

        DetalleVenta.objects.bulk_create(detalles)

        venta.total = redondear_decimal(total_calculado)
        venta.save(update_fields=['total'])

        

        # 3. Crear ComprobanteFiscal en PENDIENTE
        def generar_folio(empresa):
            ultimo = ComprobanteFiscal.objects.filter(empresa=empresa, serie='A').order_by('-folio').first()
            return (ultimo.folio + 1) if ultimo and ultimo.folio else 1
            
        serie = 'A'
        folio = generar_folio(empresa)


        # Guardar primero para asegurar que comprobante.id esté disponible
        comprobante = ComprobanteFiscal.objects.create(
            empresa=empresa,
            venta=venta,
            estado='PENDIENTE',
            tipo='FACTURA',
            serie=serie,
            folio=folio
        )

        # Forzar guardado si estás inseguro de que tenga ID
        if not comprobante.id:
            comprobante.save()




        try:
            # intentar_timbrado_comprobante(comprobante)
            intentar_timbrado_comprobante(comprobante, request=request)
        except Exception as e:
            raise DRFValidationError(f"Error al timbrar comprobante: {str(e)}")

        # 5. Crear CuentaPorCobrar
        fecha_vencimiento = venta.fecha + timedelta(days=30)
        CuentaPorCobrar.objects.create(
            empresa=empresa,
            venta=venta,
            monto=venta.total,
            fecha_vencimiento=fecha_vencimiento,
            estado='PENDIENTE'
        )

        # 6. Generar asiento contable
        try:
            generar_asiento_para_venta(venta, usuario)
        except Exception as e:
            raise DRFValidationError(f"Error al generar asiento contable: {str(e)}")



        return venta


# --- /home/runner/workspace/ventas/views/__init__.py ---
from .clientes import ClienteViewSet
from .ventas import VentaViewSet
from .detallesventa import DetalleVentaViewSet


# --- /home/runner/workspace/ventas/views/detallesventa.py ---



from rest_framework import viewsets, permissions, filters
from django_filters.rest_framework import DjangoFilterBackend
from ventas.models import DetalleVenta
from ventas.serializers import DetalleVentaSerializer
from accounts.permissions import IsVendedor, IsEmpresaAdmin
from rest_framework.pagination import PageNumberPagination
import django_filters

# Clase de paginación personalizada
class DetalleVentaPagination(PageNumberPagination):
    page_size = 10  # Número de resultados por página
    page_size_query_param = 'page_size'
    max_page_size = 100  # Máximo número de resultados por página

# Filtro personalizado para Detalles de Venta
class DetalleVentaFilter(django_filters.FilterSet):
    # Filtro por fecha de la venta
    fecha_inicio = django_filters.DateFilter(field_name='venta__fecha', lookup_expr='gte', label='Fecha desde')
    fecha_fin = django_filters.DateFilter(field_name='venta__fecha', lookup_expr='lte', label='Fecha hasta')

    class Meta:
        model = DetalleVenta
        fields = ['venta', 'producto', 'fecha_inicio', 'fecha_fin']

class DetalleVentaViewSet(viewsets.ModelViewSet):
    """
    CRUD para Detalles de Venta
    """
    queryset = DetalleVenta.objects.all().select_related('venta', 'producto')
    serializer_class = DetalleVentaSerializer
    permission_classes = [permissions.IsAuthenticated & (IsVendedor | IsEmpresaAdmin)]
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    filterset_class = DetalleVentaFilter  # Filtro personalizado
    pagination_class = DetalleVentaPagination  # Paginación personalizada

    # Permitimos ordenar por cantidad y precio_unitario
    ordering_fields = ['cantidad', 'precio_unitario']
    ordering = ['-cantidad']  # Orden predeterminado por cantidad descendente

    def get_queryset(self):
        user = self.request.user
        if user.rol.nombre == "Superadministrador":
            return self.queryset
        # Filtrar detalles solo de ventas pertenecientes a la empresa del usuario
        return self.queryset.filter(venta__empresa=user.empresa)

    def perform_create(self, serializer):
        serializer.save(usuario=self.request.user)









# from rest_framework import viewsets, permissions
# from django_filters.rest_framework import DjangoFilterBackend
# from ventas.models import DetalleVenta
# from ventas.serializers import DetalleVentaSerializer
# from accounts.permissions import IsVendedor, IsEmpresaAdmin

# class DetalleVentaViewSet(viewsets.ModelViewSet):
#     """
#     CRUD para Detalles de Venta
#     """
#     queryset = DetalleVenta.objects.all().select_related('venta', 'producto')
#     serializer_class = DetalleVentaSerializer
#     permission_classes = [permissions.IsAuthenticated & (IsVendedor | IsEmpresaAdmin)]
#     filter_backends = [DjangoFilterBackend]
#     filterset_fields = ['venta', 'producto']

#     def get_queryset(self):
#         user = self.request.user
#         if user.rol.nombre == "Superadministrador":
#             return self.queryset
#         # Filtrar detalles solo de ventas pertenecientes a la empresa del usuario
#         return self.queryset.filter(venta__empresa=user.empresa)






# from rest_framework import viewsets, permissions
# from django_filters.rest_framework import DjangoFilterBackend
# from ventas.models import DetalleVenta
# from ventas.serializers import DetalleVentaSerializer
# from accounts.permissions import IsVendedor, IsEmpresaAdmin

# class DetalleVentaViewSet(viewsets.ModelViewSet):
#     """
#     CRUD para Detalles de Venta
#     """
#     queryset = DetalleVenta.objects.all().select_related('venta', 'producto')
#     serializer_class = DetalleVentaSerializer
#     permission_classes = [permissions.IsAuthenticated & (IsVendedor | IsEmpresaAdmin)]
#     filter_backends = [DjangoFilterBackend]
#     filterset_fields = ['venta', 'producto']


# --- /home/runner/workspace/ventas/views/dashboard.py ---
from rest_framework.views import APIView
from rest_framework.response import Response
from ventas.models import Venta, DetalleVenta
from inventario.models import Producto, Inventario, MovimientoInventario
from django.db.models import Sum, F, Count
from django.db.models.functions import TruncDate, TruncWeek, TruncMonth
from datetime import timedelta
from django.utils import timezone

class VentaDashboardAPIView(APIView):
    """
    Vista para obtener estadísticas del dashboard de ventas.
    """

    def get(self, request, *args, **kwargs):
        # Obtener los parámetros 'fecha' y 'periodo' de la URL
        fecha_param = request.query_params.get('fecha')
        periodo_param = request.query_params.get('periodo', 'diario')  # El valor predeterminado es 'diario'

        # Si el parámetro 'fecha' es 'hoy', usamos la fecha actual
        if fecha_param == 'hoy':
            fecha_param = timezone.now().date()
        elif fecha_param:  # Si 'fecha_param' no es None o vacío
            # Intentamos usar la fecha proporcionada en formato 'YYYY-MM-DD'
            try:
                fecha_param = timezone.datetime.strptime(fecha_param, '%Y-%m-%d').date()
            except ValueError:
                return Response({"error": "Fecha no válida. Usa el formato YYYY-MM-DD o 'hoy'."})
        else:
            # Si no se pasa ninguna fecha, usamos la fecha actual
            fecha_param = timezone.now().date()

        # Filtramos las ventas por la fecha proporcionada
        ventas_filtradas = Venta.objects.filter(fecha__date=fecha_param)

        # Total de ventas
        total_ventas = ventas_filtradas.aggregate(total=Sum('total'))['total'] or 0

        # Ventas agrupadas por estado
        ventas_por_estado = ventas_filtradas.values('estado').annotate(total=Sum('total'))

        # Ventas por vendedor
        ventas_por_vendedor = ventas_filtradas.values('usuario__username').annotate(total=Sum('total'))

        # Promedio de ventas por transacción
        promedio_venta = ventas_filtradas.aggregate(promedio=Sum('total') / Count('id'))['promedio'] or 0

        # Ventas de los últimos 30 días
        fecha_limite = timezone.now() - timedelta(days=30)
        ventas_ultimos_30_dias = ventas_filtradas.filter(fecha__gte=fecha_limite).aggregate(total=Sum('total'))['total'] or 0

        # Top 5 productos más vendidos (en base a las ventas por detalle)
        top_productos = DetalleVenta.objects.filter(venta__fecha__date=fecha_param).values('producto__nombre').annotate(
            total_ventas=Sum(F('cantidad') * F('precio_unitario'))
        ).order_by('-total_ventas')[:5]

        # Ingresos y margen por producto (basado en costo y precio)
        ingresos_y_margen = DetalleVenta.objects.filter(venta__fecha__date=fecha_param).values('producto__nombre').annotate(
            total_ingresos=Sum(F('cantidad') * F('precio_unitario')),
            margen=Sum(F('cantidad') * (F('precio_unitario') - F('producto__precio_compra')))  # Cambio de costo a precio_compra
        ).order_by('-total_ingresos')[:5]

        # Ventas por cliente
        ventas_por_cliente = ventas_filtradas.values('cliente__nombre').annotate(total=Sum('total')).order_by('-total')[:5]

        # Calcular el stock disponible por producto
        stock_disponible = Inventario.objects.filter(
            producto__empresa__in=ventas_filtradas.values('empresa')
        ).values('producto__nombre').annotate(
            total_stock=Sum(F('cantidad')),
            stock_minimo=F('producto__stock_minimo')
        ).order_by('producto__nombre')

        # Identificar productos con bajo stock
        productos_bajo_stock = stock_disponible.filter(
            total_stock__lte=F('stock_minimo')
        ).order_by('total_stock')

        # Promedio de precio de venta y precio de compra por producto
        precios_promedio = Producto.objects.values('nombre').annotate(
            promedio_precio_venta=Sum('precio_venta') / Count('id'),
            promedio_precio_compra=Sum('precio_compra') / Count('id')
        )

        # Agrupación de ventas por periodo
        if periodo_param == 'semanal':
            ventas_por_periodo = ventas_filtradas.annotate(
                semana=TruncWeek('fecha')
            ).values('semana').annotate(total=Sum('total')).order_by('semana')

        elif periodo_param == 'mensual':
            ventas_por_periodo = ventas_filtradas.annotate(
                mes=TruncMonth('fecha')
            ).values('mes').annotate(total=Sum('total')).order_by('mes')

        else:  # Por defecto, agrupamos por día
            ventas_por_periodo = ventas_filtradas.annotate(
                dia=TruncDate('fecha')
            ).values('dia').annotate(total=Sum('total')).order_by('dia')

        # Devolviendo los resultados con stock y precios promedios
        return Response({
            "total_ventas": total_ventas,
            "ventas_por_estado": ventas_por_estado,
            "ventas_por_vendedor": ventas_por_vendedor,
            "promedio_venta": promedio_venta,
            "ventas_ultimos_30_dias": ventas_ultimos_30_dias,
            "top_productos": top_productos,
            "ingresos_y_margen": ingresos_y_margen,
            "ventas_por_cliente": ventas_por_cliente,
            "stock_disponible": stock_disponible,
            "productos_bajo_stock": productos_bajo_stock,
            "precios_promedio": precios_promedio,
            "ventas_por_periodo": ventas_por_periodo
        })











# from rest_framework.views import APIView
# from rest_framework.response import Response
# from ventas.models import Venta, DetalleVenta
# from inventario.models import Producto, Inventario, MovimientoInventario
# from django.db.models import Sum, F, Count, ExpressionWrapper, DecimalField
# from datetime import timedelta
# from django.utils import timezone


# class VentaDashboardAPIView(APIView):
#     """
#     Vista para obtener estadísticas del dashboard de ventas.
#     """

#     def get(self, request, *args, **kwargs):
#         # Obtener el parámetro 'fecha' de la URL, por ejemplo, "fecha__date=hoy"
#         fecha_param = request.query_params.get('fecha')

#         # Si el parámetro 'fecha' es 'hoy', usamos la fecha actual
#         if fecha_param == 'hoy':
#             fecha_param = timezone.now().date()
#         else:
#             # Si no, intentamos usar la fecha proporcionada en formato 'YYYY-MM-DD'
#             try:
#                 fecha_param = timezone.datetime.strptime(fecha_param, '%Y-%m-%d').date()
#             except ValueError:
#                 return Response({"error": "Fecha no válida. Usa el formato YYYY-MM-DD o 'hoy'."})

#         # Filtramos las ventas por la fecha proporcionada
#         ventas_filtradas = Venta.objects.filter(fecha__date=fecha_param)

#         # Total de ventas
#         total_ventas = ventas_filtradas.aggregate(total=Sum('total'))['total'] or 0

#         # Ventas agrupadas por estado
#         ventas_por_estado = ventas_filtradas.values('estado').annotate(total=Sum('total'))

#         # Ventas por vendedor
#         ventas_por_vendedor = ventas_filtradas.values('usuario__username').annotate(total=Sum('total'))

#         # Promedio de ventas por transacción
#         promedio_venta = ventas_filtradas.aggregate(promedio=Sum('total') / Count('id'))['promedio'] or 0

#         # Ventas de los últimos 30 días
#         fecha_limite = timezone.now() - timedelta(days=30)
#         ventas_ultimos_30_dias = ventas_filtradas.filter(fecha__gte=fecha_limite).aggregate(total=Sum('total'))['total'] or 0

#         # Top 5 productos más vendidos (en base a las ventas por detalle)
#         top_productos = DetalleVenta.objects.filter(venta__fecha__date=fecha_param).values('producto__nombre').annotate(
#             total_ventas=Sum(F('cantidad') * F('precio_unitario'))
#         ).order_by('-total_ventas')[:5]

#         # Ingresos y margen por producto (basado en costo y precio)
#         ingresos_y_margen = DetalleVenta.objects.filter(venta__fecha__date=fecha_param).values('producto__nombre').annotate(
#             total_ingresos=Sum(F('cantidad') * F('precio_unitario')),
#             margen=Sum(F('cantidad') * (F('precio_unitario') - F('producto__precio_compra')))  # Cambio de costo a precio_compra
#         ).order_by('-total_ingresos')[:5]

#         # Ventas por cliente
#         ventas_por_cliente = ventas_filtradas.values('cliente__nombre').annotate(total=Sum('total')).order_by('-total')[:5]

#         # Calcular el stock disponible por producto
#         stock_disponible = Inventario.objects.filter(
#             producto__empresa__in=ventas_filtradas.values('empresa')
#         ).values('producto__nombre').annotate(
#             total_stock=Sum(F('cantidad')),
#             stock_minimo=F('producto__stock_minimo')
#         ).order_by('producto__nombre')

#         # Identificar productos con bajo stock
#         productos_bajo_stock = stock_disponible.filter(
#             total_stock__lte=F('stock_minimo')
#         ).order_by('total_stock')

#         # Promedio de precio de venta y precio de compra por producto
#         precios_promedio = Producto.objects.values('nombre').annotate(
#             promedio_precio_venta=Sum('precio_venta') / Count('id'),
#             promedio_precio_compra=Sum('precio_compra') / Count('id')
#         )

#         # Devolviendo los resultados con stock y precios promedios
#         return Response({
#             "total_ventas": total_ventas,
#             "ventas_por_estado": ventas_por_estado,
#             "ventas_por_vendedor": ventas_por_vendedor,
#             "promedio_venta": promedio_venta,
#             "ventas_ultimos_30_dias": ventas_ultimos_30_dias,
#             "top_productos": top_productos,
#             "ingresos_y_margen": ingresos_y_margen,
#             "ventas_por_cliente": ventas_por_cliente,
#             "stock_disponible": stock_disponible,
#             "productos_bajo_stock": productos_bajo_stock,
#             "precios_promedio": precios_promedio
#         })





#from rest_framework.views import APIView
# from rest_framework.response import Response
# from ventas.models import Venta, DetalleVenta
# from django.db.models import Sum, Count
# from datetime import timedelta
# from django.utils import timezone

# class VentaDashboardAPIView(APIView):
#     """
#     Vista para obtener estadísticas del dashboard de ventas
#     """
#     def get(self, request, *args, **kwargs):
#         # Total de ventas
#         total_ventas = Venta.objects.aggregate(total=Sum('total'))['total'] or 0

#         # Ventas agrupadas por estado
#         ventas_por_estado = Venta.objects.values('estado').annotate(total=Sum('total'))

#         # Ventas por vendedor
#         ventas_por_vendedor = Venta.objects.values('usuario__username').annotate(total=Sum('total'))

#         # Promedio de ventas por transacción
#         promedio_venta = Venta.objects.aggregate(promedio=Sum('total') / Count('id'))['promedio'] or 0

#         # Ventas de los últimos 30 días
#         fecha_limite = timezone.now() - timedelta(days=30)
#         ventas_ultimos_30_dias = Venta.objects.filter(fecha__gte=fecha_limite).aggregate(total=Sum('total'))['total'] or 0

#         # Top 5 productos más vendidos (en base a las ventas por detalle)
#         top_productos = DetalleVenta.objects.values('producto__nombre').annotate(total_ventas=Sum('total')).order_by('-total_ventas')[:5]

#         # Ingresos y margen por producto (basado en costo y precio)
#         ingresos_y_margen = DetalleVenta.objects.values('producto__nombre').annotate(
#             total_ingresos=Sum('total'),
#             margen=Sum('total') - Sum('producto__costo')  # Suponiendo que cada detalle tiene un campo de costo
#         ).order_by('-total_ingresos')[:5]

#         # Ventas por cliente
#         ventas_por_cliente = Venta.objects.values('cliente__nombre').annotate(total=Sum('total')).order_by('-total')[:5]

#         # Ventas diarias (Ventas por día)
#         hoy = timezone.now().date()
#         ventas_diarias = Venta.objects.filter(fecha__date=hoy).aggregate(total=Sum('total'))['total'] or 0

#         # Ventas mensuales (Ventas del mes actual)
#         inicio_mes = hoy.replace(day=1)
#         ventas_mensuales = Venta.objects.filter(fecha__gte=inicio_mes).aggregate(total=Sum('total'))['total'] or 0

#         # Devolviendo los resultados
#         return Response({
#             "total_ventas": total_ventas,
#             "ventas_por_estado": ventas_por_estado,
#             "ventas_por_vendedor": ventas_por_vendedor,
#             "promedio_venta": promedio_venta,
#             "ventas_ultimos_30_dias": ventas_ultimos_30_dias,
#             "top_productos": top_productos,
#             "ingresos_y_margen": ingresos_y_margen,
#             "ventas_por_cliente": ventas_por_cliente,
#             "ventas_diarias": ventas_diarias,
#             "ventas_mensuales": ventas_mensuales
#         })


# from rest_framework import viewsets, permissions, filters
# from django_filters.rest_framework import DjangoFilterBackend
# from ventas.models import Venta
# from ventas.serializers import VentaSerializer
# from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsVendedor
# import django_filters
# from rest_framework.pagination import PageNumberPagination
# from rest_framework.response import Response


# # Filtros personalizados para las ventas
# class VentaFilter(django_filters.FilterSet):
#     # Filtro para el RFC del cliente
#     rfc_cliente = django_filters.CharFilter(field_name='cliente__rfc', lookup_expr='icontains', label='RFC del Cliente')

#     # Filtro para el nombre del producto (en los detalles de la venta)
#     nombre_producto = django_filters.CharFilter(field_name='detalles__producto__nombre', lookup_expr='icontains', label='Nombre del Producto')

#     # Filtros de fecha (rango de fechas)
#     fecha_inicio = django_filters.DateFilter(field_name='fecha', lookup_expr='gte', label='Fecha desde')
#     fecha_fin = django_filters.DateFilter(field_name='fecha', lookup_expr='lte', label='Fecha hasta')

#     # Filtro para el vendedor
#     vendedor = django_filters.CharFilter(field_name='usuario__username', lookup_expr='icontains', label='Vendedor')

#     # Filtro para el estado de la venta
#     estado = django_filters.ChoiceFilter(choices=Venta.ESTADO_CHOICES, label='Estado')

#     class Meta:
#         model = Venta
#         fields = ['empresa', 'estado', 'cliente', 'fecha_inicio', 'fecha_fin', 'rfc_cliente', 'nombre_producto', 'vendedor']


# # Clase de paginación personalizada
# class VentaPagination(PageNumberPagination):
#     page_size = 10  # Número de resultados por página
#     page_size_query_param = 'page_size'
#     max_page_size = 100  # Máximo número de resultados por página


# class VentaViewSet(viewsets.ModelViewSet):
#     """
#     CRUD para Ventas, con detalles anidados.
#     """
#     queryset = Venta.objects.all().select_related('cliente', 'usuario', 'empresa').prefetch_related('detalles__producto')
#     serializer_class = VentaSerializer
#     permission_classes = [permissions.IsAuthenticated & (IsSuperAdmin | IsEmpresaAdmin | IsVendedor)]
#     filter_backends = [filters.SearchFilter, DjangoFilterBackend]
#     search_fields = ['cliente__nombre', 'usuario__username', 'estado']
#     filterset_class = VentaFilter  # Usamos el filtro personalizado aquí

#     # Configuramos la paginación
#     pagination_class = VentaPagination

#     # Ordenamiento por fecha o total
#     ordering_fields = ['fecha', 'total']  # Permite ordenar por fecha y total
#     ordering = ['-fecha']  # Orden por defecto: por fecha descendente

#     def get_queryset(self):
#         user = self.request.user
#         if user.rol.nombre == "Superadministrador":
#             return self.queryset
#         return self.queryset.filter(empresa=user.empresa)

#     def perform_create(self, serializer):
#         serializer.save(usuario=self.request.user)

#     def get_latest_sales(self):
#         """
#         Devuelve las últimas n ventas con filtros aplicados.
#         """
#         n = self.request.query_params.get('n', 10)  # Número de ventas a devolver
#         try:
#             n = int(n)
#         except ValueError:
#             n = 10  # Si no se pasa un número válido, devolver las últimas 10 ventas

#         # Filtrar las ventas según los parámetros de búsqueda
#         filtered_sales = self.filter_queryset(self.queryset.order_by('-fecha')[:n])

#         # Devuelve las ventas filtradas y limitadas
#         return filtered_sales

#     def list(self, request, *args, **kwargs):
#         """
#         Sobrescribimos el método `list` para agregar soporte para obtener las últimas 'n' ventas.
#         """
#         # Si se pasa el parámetro 'latest', devolver solo las últimas 'n' ventas
#         if 'latest' in self.request.query_params:
#             latest_sales = self.get_latest_sales()
#             page = self.paginate_queryset(latest_sales)
#             if page is not None:
#                 serializer = self.get_serializer(page, many=True)
#                 return self.get_paginated_response(serializer.data)
#             return Response(self.get_serializer(latest_sales, many=True).data)

#         # Si no se pide 'latest', proceder con la lógica predeterminada
#         return super().list(request, *args, **kwargs)



# --- /home/runner/workspace/ventas/views/clientes.py ---
# ventas/views/clientes.py
from rest_framework import viewsets, permissions, filters
from django_filters.rest_framework import DjangoFilterBackend
from ventas.models import Cliente
from ventas.serializers import ClienteSerializer
from ventas.filters.clientes import ClienteFilter  # 👈 Filtro avanzado para Clientes
from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsVendedor  # 👈 Permisos personalizados

class ClienteViewSet(viewsets.ModelViewSet):
    queryset = Cliente.objects.all().select_related('empresa')
    serializer_class = ClienteSerializer
    permission_classes = [permissions.IsAuthenticated & (IsSuperAdmin | IsEmpresaAdmin | IsVendedor)]
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['nombre', 'rfc', 'correo', 'telefono']
    filterset_class = ClienteFilter

    def get_queryset(self):
        user = self.request.user
        if user.rol.nombre == "Superadministrador":
            # Superadmin ve todos los clientes
            return self.queryset
        else:
            # Los demás solo clientes de su empresa
            return self.queryset.filter(empresa=user.empresa)



# --- /home/runner/workspace/ventas/views/ventas.py ---
from rest_framework import viewsets, permissions, filters
from django_filters.rest_framework import DjangoFilterBackend
from ventas.models import Venta
from ventas.serializers import VentaSerializer
from accounts.permissions import IsSuperAdmin, IsEmpresaAdmin, IsVendedor
import django_filters
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response


# Filtros personalizados para las ventas
class VentaFilter(django_filters.FilterSet):
    # Filtro para el RFC del cliente
    rfc_cliente = django_filters.CharFilter(field_name='cliente__rfc', lookup_expr='icontains', label='RFC del Cliente')

    # Filtro para el nombre del producto (en los detalles de la venta)
    nombre_producto = django_filters.CharFilter(field_name='detalles__producto__nombre', lookup_expr='icontains', label='Nombre del Producto')

    # Filtros de fecha (rango de fechas)
    fecha_inicio = django_filters.DateFilter(field_name='fecha', lookup_expr='gte', label='Fecha desde')
    fecha_fin = django_filters.DateFilter(field_name='fecha', lookup_expr='lte', label='Fecha hasta')

    # Filtro para el vendedor
    vendedor = django_filters.CharFilter(field_name='usuario__username', lookup_expr='icontains', label='Vendedor')

    # Filtro para el estado de la venta
    estado = django_filters.ChoiceFilter(choices=Venta.ESTADO_CHOICES, label='Estado')

    class Meta:
        model = Venta
        fields = ['empresa', 'estado', 'cliente', 'fecha_inicio', 'fecha_fin', 'rfc_cliente', 'nombre_producto', 'vendedor']


# Clase de paginación personalizada
class VentaPagination(PageNumberPagination):
    page_size = 10  # Número de resultados por página
    page_size_query_param = 'page_size'
    max_page_size = 100  # Máximo número de resultados por página


class VentaViewSet(viewsets.ModelViewSet):
    """
    CRUD para Ventas, con detalles anidados.
    """
    queryset = Venta.objects.all().select_related('cliente', 'usuario', 'empresa').prefetch_related('detalles__producto')
    serializer_class = VentaSerializer
    permission_classes = [permissions.IsAuthenticated & (IsSuperAdmin | IsEmpresaAdmin | IsVendedor)]
    filter_backends = [filters.SearchFilter, DjangoFilterBackend]
    search_fields = ['cliente__nombre', 'usuario__username', 'estado']
    filterset_class = VentaFilter  # Usamos el filtro personalizado aquí

    # Configuramos la paginación
    pagination_class = VentaPagination

    # Ordenamiento por fecha o total
    ordering_fields = ['fecha', 'total']  # Permite ordenar por fecha y total
    ordering = ['-fecha']  # Orden por defecto: por fecha descendente

    def get_queryset(self):
        user = self.request.user
        if user.rol.nombre == "Superadministrador":
            return self.queryset
        return self.queryset.filter(empresa=user.empresa)

    def perform_create(self, serializer):
        serializer.save(usuario=self.request.user)

    def get_latest_sales(self):
        """
        Devuelve las últimas n ventas con filtros aplicados.
        """
        n = self.request.query_params.get('n', 10)  # Número de ventas a devolver
        try:
            n = int(n)
        except ValueError:
            n = 10  # Si no se pasa un número válido, devolver las últimas 10 ventas

        # Filtrar las ventas según los parámetros de búsqueda
        filtered_sales = self.filter_queryset(self.queryset.order_by('-fecha')[:n])

        # Devuelve las ventas filtradas y limitadas
        return filtered_sales

    def list(self, request, *args, **kwargs):
        """
        Sobrescribimos el método `list` para agregar soporte para obtener las últimas 'n' ventas.
        """
        # Si se pasa el parámetro 'latest', devolver solo las últimas 'n' ventas
        if 'latest' in self.request.query_params:
            latest_sales = self.get_latest_sales()
            page = self.paginate_queryset(latest_sales)
            if page is not None:
                serializer = self.get_serializer(page, many=True)
                return self.get_paginated_response(serializer.data)
            return Response(self.get_serializer(latest_sales, many=True).data)

        # Si no se pide 'latest', proceder con la lógica predeterminada
        return super().list(request, *args, **kwargs)






# === Archivo: compras_combined.py ===

# --- /home/runner/workspace/compras/__init__.py ---



# --- /home/runner/workspace/compras/admin.py ---
from django.contrib import admin

# Register your models here.



# --- /home/runner/workspace/compras/apps.py ---
from django.apps import AppConfig


class ComprasConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'compras'



# --- /home/runner/workspace/compras/urls.py ---
from compras.views.proveedor_views import ProveedorViewSet


from rest_framework import routers
from django.urls import path, include
from compras.views.compra_views import CompraViewSet, ReceivePurchase , CompraReceiveView, CompraRecepcionParcialAPIView, CompraCancelarAPIView

router = routers.DefaultRouter()
router.register(r'providers', ProveedorViewSet, basename='proveedor')
router.register(r'purchases', CompraViewSet, basename='purchases')

urlpatterns = [
    path('', include(router.urls)),
    # path('purchases/<int:id>/receive/', ReceivePurchase.as_view(), name='receive_purchase')
    path('purchases/<int:pk>/receive/', CompraReceiveView.as_view(), name='compra-receive'),
    path('purchases/<int:pk>/partial-reception/', CompraRecepcionParcialAPIView.as_view(), name='compra-recepcion-parcial'),
    path('purchases/<int:pk>/cancelar/', CompraCancelarAPIView.as_view(), name='cancelar_compra'),
]


# --- /home/runner/workspace/compras/filters.py ---
# compras/filters.py

import django_filters
from compras.models import Compra

class CompraFilter(django_filters.FilterSet):
    # Rango de fechas
    fecha_min = django_filters.DateFilter(field_name='fecha', lookup_expr='gte')
    fecha_max = django_filters.DateFilter(field_name='fecha', lookup_expr='lte')

    # Rango de totales
    total_min = django_filters.NumberFilter(field_name='total', lookup_expr='gte')
    total_max = django_filters.NumberFilter(field_name='total', lookup_expr='lte')

    # Filtro exacto por nombre de producto
    nombre_producto = django_filters.CharFilter(method='filter_nombre_producto')

    # Filtros por ID o múltiples productos
    producto_id = django_filters.NumberFilter(field_name='detalles__producto__id')
    producto_id__in = django_filters.BaseInFilter(field_name='detalles__producto__id', lookup_expr='in')

    class Meta:
        model = Compra
        fields = ['empresa', 'proveedor', 'estado']

    def filter_nombre_producto(self, queryset, name, value):
        return queryset.filter(detalles__producto__nombre__icontains=value).distinct()


# --- /home/runner/workspace/compras/tests.py ---
# compras/tests.py
from django.test import TestCase
from rest_framework.test import APIClient
from django.urls import reverse
from accounts.models import Usuario, Empresa
from compras.models import Compra, DetalleCompra
from inventario.models import Producto
from datetime import date

class CompraTests(TestCase):
    def setUp(self):
        self.client = APIClient()
        self.empresa = Empresa.objects.create(nombre="Empresa Test")
        self.usuario = Usuario.objects.create_user(username="user1", password="pass123", empresa=self.empresa)
        self.producto1 = Producto.objects.create(nombre="Producto 1", activo=True)
        self.producto2 = Producto.objects.create(nombre="Producto 2", activo=True)

        self.client.force_authenticate(user=self.usuario)

    def test_crear_compra_con_detalles_y_total(self):
        url = reverse('compra-list')  # O el nombre correcto de tu ruta
        data = {
            "proveedor": 1,  # crea un proveedor antes o usa uno válido
            "detalles": [
                {"producto": self.producto1.id, "cantidad": 10, "precio_unitario": "5.00"},
                {"producto": self.producto2.id, "cantidad": 2, "precio_unitario": "20.00"}
            ]
        }
        response = self.client.post(url, data, format='json')
        self.assertEqual(response.status_code, 201)
        self.assertEqual(response.data['total'], '90.00')  # 10*5 + 2*20

    def test_actualizar_compra_y_recalcular_total(self):
        compra = Compra.objects.create(
            empresa=self.empresa,
            proveedor_id=1,  # igual, un proveedor válido
            usuario=self.usuario,
            total=0
        )
        DetalleCompra.objects.create(compra=compra, producto=self.producto1, cantidad=1, precio_unitario=10)
        url = reverse('compra-detail', args=[compra.id])

        data = {
            "detalles": [
                {"producto": self.producto1.id, "cantidad": 3, "precio_unitario": "15.00"}
            ],
            "estado": "pendiente"
        }
        response = self.client.put(url, data, format='json')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['total'], '45.00')  # 3*15

    def test_subtotal_detalle(self):
        compra = Compra.objects.create(empresa=self.empresa, proveedor_id=1, usuario=self.usuario, total=0)
        detalle = DetalleCompra.objects.create(compra=compra, producto=self.producto1, cantidad=4, precio_unitario=7.5)
        self.assertEqual(detalle.subtotal, 30.0)



# --- /home/runner/workspace/compras/models.py ---
# compras/models.py
from django.db import models
from django.utils import timezone
from accounts.models import Usuario, Empresa
from inventario.models import Producto
from django.core.exceptions import ValidationError
from django.utils import timezone

class Proveedor(models.Model):
    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE, related_name='proveedores')
    nombre = models.CharField(max_length=255)
    rfc = models.CharField(max_length=13)
    correo = models.EmailField(blank=True, null=True)
    telefono = models.CharField(max_length=30, blank=True, null=True)
    direccion = models.TextField(blank=True, null=True)
    creado_en = models.DateTimeField(auto_now_add=True)
    actualizado_en = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Proveedor"
        verbose_name_plural = "Proveedores"
        unique_together = ('empresa', 'rfc')
        ordering = ['nombre']

    def __str__(self):
        return self.nombre



class Compra(models.Model):
    ESTADO_CHOICES = [
        ('pendiente', 'Pendiente'),  # La compra está pendiente de ser recibida
        ('parcial', 'Parcial'),      # La compra está parcialmente recibida
        ('recibida', 'Recibida'),    # La compra ha sido completamente recibida
        ('cancelada', 'Cancelada'),  # En caso de que la compra sea cancelada
    ]

    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE, related_name='compras')
    proveedor = models.ForeignKey(Proveedor, on_delete=models.PROTECT, related_name='compras')
    fecha = models.DateTimeField(default=timezone.now)
    total = models.DecimalField(max_digits=14, decimal_places=2)
    estado = models.CharField(max_length=20, choices=ESTADO_CHOICES, default='pendiente')
    usuario = models.ForeignKey(Usuario, on_delete=models.SET_NULL, null=True, blank=True, related_name='compras_creadas')

    def calcular_total(self):
        return sum(det.subtotal for det in self.detalles.all())

    def save(self, *args, **kwargs):
        # Si es una nueva instancia sin PK, guardar primero sin calcular total
        if not self.pk:
            # Para nuevas instancias, asignar total 0 temporalmente
            if not hasattr(self, 'total') or self.total is None:
                self.total = 0
            super().save(*args, **kwargs)
            return

        # Solo calcular total si ya existe en la base de datos
        total_calculado = self.calcular_total()
        if self.total != total_calculado:
            self.total = total_calculado
            super().save(update_fields=['total'])
        else:
            super().save(*args, **kwargs)

    class Meta:
        verbose_name = "Compra"
        verbose_name_plural = "Compras"
        ordering = ['-fecha']
        indexes = [
            models.Index(fields=['empresa', 'fecha']),
            models.Index(fields=['estado']),
        ]

    def __str__(self):
        return f'Compra #{self.id} - {self.proveedor.nombre} - {self.fecha.strftime("%Y-%m-%d")}'

class DetalleCompra(models.Model):
    compra = models.ForeignKey(Compra, on_delete=models.CASCADE, related_name='detalles')
    producto = models.ForeignKey(Producto, on_delete=models.PROTECT, related_name='detalles_compra')
    cantidad = models.DecimalField(max_digits=12, decimal_places=2)
    precio_unitario = models.DecimalField(max_digits=14, decimal_places=2)
    lote = models.CharField(max_length=100, blank=True, null=True)
    fecha_vencimiento = models.DateField(blank=True, null=True)
    cantidad_recibida = models.DecimalField(max_digits=10, decimal_places=2, default=0)  # nuevo campo

    @property
    def subtotal(self):
        return self.cantidad * self.precio_unitario
    
    def clean(self):
        if self.cantidad <= 0:
            raise ValidationError("La cantidad debe ser mayor a cero.")
        if self.precio_unitario <= 0:
            raise ValidationError("El precio unitario debe ser mayor a cero.")


    class Meta:
        verbose_name = "Detalle de Compra"
        verbose_name_plural = "Detalles de Compras"
        # unique_together = ('compra', 'producto')
        unique_together = ('compra', 'producto', 'lote', 'fecha_vencimiento')

    def __str__(self):
        return f'{self.producto.nombre} - {self.cantidad} x {self.precio_unitario}'




# --- /home/runner/workspace/compras/migrations/__init__.py ---



# --- /home/runner/workspace/compras/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
import django.utils.timezone
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
        ('inventario', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Proveedor',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nombre', models.CharField(max_length=255)),
                ('rfc', models.CharField(max_length=13)),
                ('correo', models.EmailField(blank=True, max_length=254, null=True)),
                ('telefono', models.CharField(blank=True, max_length=30, null=True)),
                ('direccion', models.TextField(blank=True, null=True)),
                ('creado_en', models.DateTimeField(auto_now_add=True)),
                ('actualizado_en', models.DateTimeField(auto_now=True)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='proveedores', to='core.empresa')),
            ],
            options={
                'verbose_name': 'Proveedor',
                'verbose_name_plural': 'Proveedores',
                'ordering': ['nombre'],
                'unique_together': {('empresa', 'rfc')},
            },
        ),
        migrations.CreateModel(
            name='Compra',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('fecha', models.DateTimeField(default=django.utils.timezone.now)),
                ('total', models.DecimalField(decimal_places=2, max_digits=14)),
                ('estado', models.CharField(choices=[('pendiente', 'Pendiente'), ('parcial', 'Parcial'), ('recibida', 'Recibida'), ('cancelada', 'Cancelada')], default='pendiente', max_length=20)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='compras', to='core.empresa')),
                ('usuario', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='compras_creadas', to=settings.AUTH_USER_MODEL)),
                ('proveedor', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='compras', to='compras.proveedor')),
            ],
            options={
                'verbose_name': 'Compra',
                'verbose_name_plural': 'Compras',
                'ordering': ['-fecha'],
            },
        ),
        migrations.CreateModel(
            name='DetalleCompra',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cantidad', models.DecimalField(decimal_places=2, max_digits=12)),
                ('precio_unitario', models.DecimalField(decimal_places=2, max_digits=14)),
                ('lote', models.CharField(blank=True, max_length=100, null=True)),
                ('fecha_vencimiento', models.DateField(blank=True, null=True)),
                ('cantidad_recibida', models.DecimalField(decimal_places=2, default=0, max_digits=10)),
                ('compra', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='detalles', to='compras.compra')),
                ('producto', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='detalles_compra', to='inventario.producto')),
            ],
            options={
                'verbose_name': 'Detalle de Compra',
                'verbose_name_plural': 'Detalles de Compras',
                'unique_together': {('compra', 'producto', 'lote', 'fecha_vencimiento')},
            },
        ),
        migrations.AddIndex(
            model_name='compra',
            index=models.Index(fields=['empresa', 'fecha'], name='compras_com_empresa_147b8e_idx'),
        ),
        migrations.AddIndex(
            model_name='compra',
            index=models.Index(fields=['estado'], name='compras_com_estado_d26ae1_idx'),
        ),
    ]



# --- /home/runner/workspace/compras/views/proveedor_views.py ---
# compras/views/proveedor_views.py
from rest_framework import viewsets, filters
from rest_framework.permissions import IsAuthenticated, AllowAny
from django_filters.rest_framework import DjangoFilterBackend
from compras.models import Proveedor
from compras.serializers import ProveedorSerializer
from accounts.permissions import IsSuperAdminOrCompras
from rest_framework import serializers

class ProveedorViewSet(viewsets.ModelViewSet):
    queryset = Proveedor.objects.all()
    serializer_class = ProveedorSerializer
    # permission_classes = [IsSuperAdminOrCompras] # 👈 Asegúrate de tener este permiso
    permission_classes = [AllowAny]

    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['empresa', 'rfc', 'correo', 'telefono']
    search_fields = ['nombre', 'rfc', 'correo']
    ordering_fields = ['nombre', 'creado_en', 'actualizado_en']
    ordering = ['nombre']

    def get_queryset(self):
        user = self.request.user
        empresa = getattr(user, 'empresa_actual', None)
        if empresa:
            return Proveedor.objects.filter(empresa=empresa)
        return Proveedor.objects.none()

    def perform_create(self, serializer):
        empresa = getattr(self.request.user, 'empresa', None)
        print("Empresa actual del usuario:", empresa)
        if empresa is None:
            # Si no hay empresa, puedes lanzar excepción o manejar el error
            raise serializers.ValidationError("No se encontró empresa asignada al usuario")
        serializer.save(empresa=empresa)



# --- /home/runner/workspace/compras/views/__init_.py ---
from .proveedor_views import ProveedorViewSet

__all__ = ['ProveedorViewSet']


# --- /home/runner/workspace/compras/views/compra_views.py ---
from rest_framework import viewsets, filters
from rest_framework.permissions import AllowAny, IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend
from compras.models import Compra
from compras.serializers import CompraSerializer
from accounts.permissions import IsSuperAdminOrCompras
from rest_framework import serializers
from decimal import Decimal
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from compras.models import Compra, DetalleCompra
from django.shortcuts import get_object_or_404
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import ValidationError
from inventario.models import Inventario
from django.utils import timezone
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.db import transaction
from django.shortcuts import get_object_or_404
from inventario.models import Inventario, MovimientoInventario
from compras.models import Compra, DetalleCompra
from datetime import datetime
from compras.filters import CompraFilter  # Importa el filtro
from contabilidad.helpers.asientos import generar_asiento_para_compra
import django_filters  # Asegúrate de que esta línea esté presente

from finanzas.models import CuentaPorPagar




class CompraReceiveView(APIView):
    def patch(self, request, pk):
        compra = get_object_or_404(Compra, pk=pk)

        if compra.estado == 'recibida':
            return Response({"detail": "Esta compra ya fue recibida."}, status=status.HTTP_400_BAD_REQUEST)

        detalles = DetalleCompra.objects.filter(compra=compra).select_for_update()

        with transaction.atomic():
            for detalle in detalles:
                cantidad_pendiente = detalle.cantidad - detalle.cantidad_recibida
                if cantidad_pendiente <= 0:
                    continue  # Ya recibido, no sumar más

                inventario, _ = Inventario.objects.select_for_update().get_or_create(
                    producto=detalle.producto,
                    sucursal=compra.usuario.sucursal_actual,
                    lote=detalle.lote or None,
                    fecha_vencimiento=detalle.fecha_vencimiento or None,
                    defaults={"cantidad": 0}
                )
                inventario.cantidad += cantidad_pendiente
                inventario.save()

                MovimientoInventario.objects.create(
                    inventario=inventario,
                    tipo_movimiento='entrada',
                    cantidad=cantidad_pendiente,
                    fecha=datetime.now(),
                    usuario=compra.usuario
                )

                detalle.cantidad_recibida = detalle.cantidad
                detalle.save()

            # Actualiza estado
            if all(d.cantidad_recibida >= d.cantidad for d in compra.detalles.all()):
                compra.estado = 'recibida'
            elif any(d.cantidad_recibida > 0 for d in compra.detalles.all()):
                compra.estado = 'parcial'
            else:
                compra.estado = 'pendiente'
            compra.save()

        return Response({"detail": "Compra recibida correctamente."}, status=status.HTTP_200_OK)


class ReceivePurchase(APIView):
    permission_classes = [IsAuthenticated]

    def patch(self, request, id):
        # Buscar la compra por ID
        compra = get_object_or_404(Compra, id=id)

        # Validar si el estado es "pendiente" o "parcial", no debería estar ya "recibida"
        if compra.estado not in ['pendiente', 'parcial']:
            raise ValidationError("La compra ya ha sido recibida o está cancelada.")

        # Actualizar el estado a 'recibida' (si ya es parcial o pendiente)
        compra.estado = 'recibida'
        compra.save()

        # Verificar que el usuario tiene sucursal asignada
        sucursal = request.user.sucursal_actual
        if not sucursal:
            raise ValidationError("El usuario no tiene una sucursal asignada.")

        # Actualizar el stock de los productos en inventario
        for detalle in compra.detalles.all():
            producto = detalle.producto
            cantidad = detalle.cantidad

            # Obtener el inventario para esa sucursal, lote y producto
            inventario, creado = Inventario.objects.get_or_create(
                producto=producto,
                sucursal=sucursal,  # Sucursal obtenida del usuario
                lote=detalle.lote,
                fecha_vencimiento=detalle.fecha_vencimiento,
                defaults={'cantidad': 0}
            )

            # Incrementar la cantidad en el inventario
            inventario.cantidad += cantidad
            inventario.save()

        return Response({"message": "Compra recibida y stock actualizado."}, status=status.HTTP_200_OK)

# Personaliza la respuesta de los errores de validación
def custom_exception_handler(exc, context):
    response = exception_handler(exc, context)

    if response is not None:
        # Personaliza el formato de la respuesta de error
        if isinstance(exc, ValidationError):
            response.data = {"detail": response.data[0]}  # Cambia el arreglo por un mensaje directo

    return response


# class CompraFilter(django_filters.FilterSet):
#     fecha_compra = django_filters.DateFilter(field_name='fecha', lookup_expr='exact')
#     fecha_min = django_filters.DateFilter(field_name='fecha', lookup_expr='gte')
#     fecha_max = django_filters.DateFilter(field_name='fecha', lookup_expr='lte')
#     total_min = django_filters.NumberFilter(field_name='total', lookup_expr='gte')
#     total_max = django_filters.NumberFilter(field_name='total', lookup_expr='lte')
#     nombre_producto = django_filters.CharFilter(method='filter_nombre_producto')
#     producto_id = django_filters.NumberFilter(field_name='detalles__producto__id')
#     producto_id__in = django_filters.BaseInFilter(field_name='detalles__producto__id', lookup_expr='in')

#     class Meta:
#         model = Compra
#         fields = ['empresa', 'proveedor', 'estado', 'fecha_compra']

#     def filter_nombre_producto(self, queryset, name, value):
#         return queryset.filter(detalles__producto__nombre__icontains=value).distinct()

# class CompraFilter(django_filters.FilterSet):
#     fecha_compra = django_filters.DateFilter(field_name='fecha', lookup_expr='exact')
#     nombre_producto = django_filters.CharFilter(method='filter_nombre_producto')

#     class Meta:
#         model = Compra
#         fields = ['empresa', 'proveedor', 'fecha_compra']

#     def filter_nombre_producto(self, queryset, name, value):
#         # Aquí usamos Q para hacer una búsqueda en la relación detalles -> producto -> nombre
#         return queryset.filter(
#             Q(detalles__producto__nombre__icontains=value)
#         ).distinct()  # Evita duplicados de compras que contienen varios productos coincidentes


# from rest_framework import viewsets, filters
# from django_filters.rest_framework import DjangoFilterBackend
# from .models import Compra
# from .serializers import CompraSerializer
# from .filters import CompraFilter


# /api/purchases/purchases/?search=camiseta
# /api/purchases/purchases/?proveedor=3
# /api/purchases/purchases/?fecha_min=2025-07-01&fecha_max=2025-07-31
# /api/purchases/purchases/?total_min=100&total_max=1000
# /api/purchases/purchases/?producto_id=7
# /api/purchases/purchases/?producto_id__in=5,7,8
# /api/purchases/purchases/?ordering=total
# /api/purchases/purchases/?ordering=-fecha


class CompraViewSet(viewsets.ModelViewSet):
    # queryset = Compra.objects.all()
    serializer_class = CompraSerializer

    filter_backends = [
        DjangoFilterBackend,       # Para filtros personalizados
        filters.SearchFilter,      # Para búsqueda general
        filters.OrderingFilter     # Para ordenamiento
    ]

    filterset_class = CompraFilter

    # Búsqueda tipo Google
    search_fields = [
        'detalles__producto__nombre',
        'detalles__producto__codigo',
        'proveedor__nombre',
        'detalles__lote'
    ]

    # Campos que se pueden ordenar
    ordering_fields = ['fecha', 'total']
    ordering = ['-fecha']  # Por defecto, mostrar compras recientes primero

    def get_queryset(self):
        usuario = self.request.user
        empresa = getattr(usuario, 'empresa', None)
        if empresa:
            return Compra.objects.filter(empresa=empresa)
        return Compra.objects.none()

    def perform_create(self, serializer):
        serializer.save()  # sin lógica extra aquí
        # usuario = self.request.user
        # empresa = usuario.empresa
        # if not getattr(usuario, 'sucursal_actual', None):
        #     raise serializers.ValidationError("El usuario no tiene una sucursal asignada.")

        # try:
        #     with transaction.atomic():
        #         compra = serializer.save()

        #         # Calcular total con precisión ahora que detalles están guardados
        #         total = sum(
        #             det.cantidad * det.precio_unitario
        #             for det in compra.detalles.all()
        #         )

        #         # Crear CuentaPorPagar
        #         fecha_vencimiento = compra.fecha + timedelta(days=30)
        #         CuentaPorPagar.objects.create(
        #             empresa=empresa,
        #             compra=compra,
        #             monto=total,
        #             fecha_vencimiento=fecha_vencimiento,
        #             estado='PENDIENTE'
        #         )

        #         # Crear asiento contable
        #         generar_asiento_para_compra(compra, usuario)

        # except Exception as e:
        #     raise serializers.ValidationError(f"Error al generar asiento contable: {str(e)}")



class CompraRecepcionParcialAPIView(APIView):
    def patch(self, request, pk):
        try:
            compra = Compra.objects.select_for_update().get(pk=pk)
        except Compra.DoesNotExist:
            return Response({'detail': 'Compra no encontrada.'}, status=404)

        data = request.data.get("items", [])
        if not data:
            return Response({'detail': 'No se enviaron productos a recibir.'}, status=400)

        resultados = []
        cambios_realizados = False

        with transaction.atomic():
            for item in data:
                detalle_id = item.get('detalle_id')
                recibido = item.get('recibido')

                if not detalle_id or recibido is None:
                    resultados.append({
                        'detalle_id': detalle_id,
                        'status': 'error',
                        'message': 'Faltan datos de detalle o cantidad recibida.'
                    })
                    continue

                try:
                    recibido = Decimal(recibido)
                except:
                    resultados.append({
                        'detalle_id': detalle_id,
                        'status': 'error',
                        'message': 'Cantidad recibida inválida.'
                    })
                    continue

                if recibido <= 0:
                    resultados.append({
                        'detalle_id': detalle_id,
                        'status': 'error',
                        'message': 'Cantidad recibida debe ser mayor a cero.'
                    })
                    continue

                try:
                    detalle = DetalleCompra.objects.select_for_update().get(id=detalle_id, compra=compra)
                except DetalleCompra.DoesNotExist:
                    resultados.append({
                        'detalle_id': detalle_id,
                        'status': 'error',
                        'message': 'Detalle no encontrado.'
                    })
                    continue

                cantidad_pendiente = detalle.cantidad - detalle.cantidad_recibida

                if cantidad_pendiente <= 0:
                    resultados.append({
                        'detalle_id': detalle_id,
                        'status': 'sin_cambios',
                        'message': 'Ya se recibió la cantidad completa para este detalle.'
                    })
                    continue

                recibido_real = min(recibido, cantidad_pendiente)

                # Actualiza cantidad recibida solo con lo que falta
                detalle.cantidad_recibida += recibido_real
                detalle.save()

                lote = detalle.lote or None
                vencimiento = detalle.fecha_vencimiento or None

                inventario, _ = Inventario.objects.select_for_update().get_or_create(
                    producto=detalle.producto,
                    sucursal=compra.usuario.sucursal_actual,
                    lote=lote,
                    fecha_vencimiento=vencimiento,
                    defaults={'cantidad': 0}
                )
                inventario.cantidad += recibido_real
                inventario.save()

                MovimientoInventario.objects.create(
                    inventario=inventario,
                    tipo_movimiento='entrada',
                    cantidad=recibido_real,
                    fecha=timezone.now(),
                    usuario=request.user
                )

                cambios_realizados = True

                resultados.append({
                    'detalle_id': detalle_id,
                    'status': 'recibido',
                    'cantidad_recibida': str(recibido_real),
                    'message': 'Cantidad recibida y stock actualizado.'
                })

            # Luego actualiza estado según cantidades recibidas
            if all(d.cantidad_recibida >= d.cantidad for d in compra.detalles.all()):
                compra.estado = 'recibida'
            elif any(d.cantidad_recibida > 0 for d in compra.detalles.all()):
                compra.estado = 'parcial'
            else:
                compra.estado = 'pendiente'
            compra.save()

        if cambios_realizados:
            return Response({
                'detail': 'Recepción procesada correctamente.',
                'resultados': resultados
            })
        else:
            return Response({
                'detail': 'No se realizaron cambios. Posiblemente todo ya estaba recibido.',
                'resultados': resultados
            }, status=400)


class CompraCancelarAPIView(APIView):
    permission_classes = [IsAuthenticated]

    def patch(self, request, pk):
        compra = get_object_or_404(Compra, pk=pk)

        # Si la compra ya está cancelada, no se debe hacer nada
        if compra.estado == 'cancelada':
            return Response({"detail": "La compra ya está cancelada."}, status=status.HTTP_400_BAD_REQUEST)

        # Verificar si la compra ya fue recibida (parcial o completa)
        if compra.estado == 'recibida' or compra.estado == 'parcial':
            with transaction.atomic():
                for detalle in compra.detalles.all():
                    if detalle.cantidad_recibida > 0:
                        # Ajustar inventario y registrar movimiento de salida (devolución)
                        inventario = Inventario.objects.filter(
                            producto=detalle.producto,
                            sucursal=compra.usuario.sucursal_actual,
                            lote=detalle.lote,
                            fecha_vencimiento=detalle.fecha_vencimiento
                        ).first()

                        if inventario:
                            # Restar del inventario lo recibido
                            inventario.cantidad -= detalle.cantidad_recibida
                            inventario.save()

                            # Registrar el movimiento como salida (devolución)
                            MovimientoInventario.objects.create(
                                inventario=inventario,
                                tipo_movimiento='salida',  # Salida porque es una devolución
                                cantidad=detalle.cantidad_recibida,
                                fecha=timezone.now(),
                                usuario=request.user
                            )

                        # Resetear cantidad recibida a 0
                        detalle.cantidad_recibida = 0
                        detalle.save()

            compra.estado = 'cancelada'
            compra.save()
            return Response({"detail": "Compra cancelada y stock ajustado correctamente."}, status=status.HTTP_200_OK)

        # Si la compra no ha sido recibida aún, solo se cambia el estado a 'cancelada'
        compra.estado = 'cancelada'
        compra.save()

        return Response({"detail": "Compra cancelada correctamente, no se ajustó el inventario."}, status=status.HTTP_200_OK)
            



# --- /home/runner/workspace/compras/serializers/proveedor_serializers.py ---
# compras/serializers.py
from rest_framework import serializers
from compras.models import Proveedor, Compra, DetalleCompra
# from compras.models import Proveedor, Compra, DetalleCompra

from inventario.models import Producto

class ProveedorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Proveedor
        fields = [
            'id', 'empresa', 'nombre', 'rfc', 'correo', 'telefono', 'direccion',
            'creado_en', 'actualizado_en'
        ]
        read_only_fields = ['id', 'creado_en', 'actualizado_en']


# --- /home/runner/workspace/compras/serializers/__init__.py ---
from .proveedor_serializers import ProveedorSerializer
from .detalle_compra_serializers import DetalleCompraSerializer
from .compra_serializers import CompraSerializer

__all__ = [
    'ProveedorSerializer',
    'DetalleCompraSerializer',
    'CompraSerializer',
]
# from .proveedor_serializers import ProveedorSerializer
# from .detalle_compra_serializers import DetalleCompraSerializer
# from .compra_serializers import CompraSerializer

# __all__ = [
#     'ProveedorSerializer',
#     'DetalleCompraSerializer',
#     'CompraSerializer',
# ]


# --- /home/runner/workspace/compras/serializers/detalle_compra_serializers.py ---
# compras/serializers.py
from rest_framework import serializers
# from .models import  DetalleCompra
from compras.models import DetalleCompra
# from compras.serializers.detalle_compra_serializers import DetalleCompraSerializer

from inventario.models import Producto


class DetalleCompraSerializer(serializers.ModelSerializer):
    nombre_producto = serializers.CharField(source='producto.nombre', read_only=True)
    lote = serializers.CharField(required=False, allow_blank=True, allow_null=True)
    fecha_vencimiento = serializers.DateField(required=False, allow_null=True)
    subtotal = serializers.SerializerMethodField()

    class Meta:
        model = DetalleCompra
        fields = [
            'id', 'producto', 'nombre_producto', 'cantidad', 'precio_unitario',
            'lote', 'fecha_vencimiento', 'subtotal'
        ]

    def get_subtotal(self, obj):
        return obj.subtotal
    

    def validate(self, data):
        producto = data.get('producto')
        cantidad = data.get('cantidad')
        precio_unitario = data.get('precio_unitario')

        if producto and not producto.activo:
            raise serializers.ValidationError("El producto seleccionado está inactivo.")

        if cantidad is not None and cantidad <= 0:
            raise serializers.ValidationError("La cantidad debe ser mayor a cero.")

        if precio_unitario is not None and precio_unitario <= 0:
            raise serializers.ValidationError("El precio unitario debe ser mayor a cero.")

        return data


# --- /home/runner/workspace/compras/serializers/compra_serializers.py ---
from rest_framework import serializers
from compras.models import Proveedor, Compra, DetalleCompra
from compras.serializers.detalle_compra_serializers import DetalleCompraSerializer
from inventario.models import Inventario, MovimientoInventario
from django.db import transaction
from finanzas.models import CuentaPorPagar
from datetime import timedelta
from contabilidad.helpers.asientos import generar_asiento_para_compra

class CompraSerializer(serializers.ModelSerializer):
    detalles = DetalleCompraSerializer(many=True)
    total = serializers.SerializerMethodField()
    nombre_proveedor = serializers.CharField(source='proveedor.nombre', read_only=True)

    class Meta:
        model = Compra
        fields = [
            'id', 'empresa', 'proveedor', 'nombre_proveedor', 'fecha', 'estado',
            'usuario', 'total', 'detalles'
        ]
        read_only_fields = ['id', 'total', 'usuario', 'empresa']

    def get_total(self, obj):
        return sum(det.cantidad * det.precio_unitario for det in obj.detalles.all())

    def create(self, validated_data):
        detalles_data = validated_data.pop('detalles')

        request = self.context.get('request')
        usuario = request.user if request else None
        sucursal = getattr(usuario, 'sucursal_actual', None)
        empresa = getattr(usuario, 'empresa', None)

        if not usuario or not usuario.is_authenticated:
            raise serializers.ValidationError("Usuario no autenticado.")
        if not sucursal:
            raise serializers.ValidationError("El usuario no tiene una sucursal asignada.")
        if not empresa:
            raise serializers.ValidationError("El usuario no tiene empresa asignada.")

        with transaction.atomic():
            # Crear compra con total temporal 0
            compra = Compra.objects.create(
                empresa=empresa,
                usuario=usuario,
                proveedor=validated_data['proveedor'],
                fecha=validated_data.get('fecha'),
                estado=validated_data.get('estado', 'PENDIENTE'),
                total=0  # Total temporal
            )

            # Crear los detalles
            for detalle_data in detalles_data:
                DetalleCompra.objects.create(compra=compra, **detalle_data)

            # Recalcular total después de guardar detalles
            compra.total = compra.calcular_total()
            compra.save(update_fields=['total'])

            # ✅ Crear CuentaPorPagar
            fecha_vencimiento = compra.fecha + timedelta(days=30)
            CuentaPorPagar.objects.create(
                empresa=empresa,
                compra=compra,
                monto=compra.total,
                fecha_vencimiento=fecha_vencimiento,
                estado='PENDIENTE'
            )

            # ✅ Generar asiento contable después de todo
            generar_asiento_para_compra(compra, usuario)

        return compra





# === Archivo: finanzas_combined.py ===

# --- /home/runner/workspace/finanzas/__init__.py ---



# --- /home/runner/workspace/finanzas/admin.py ---
from django.contrib import admin

# Register your models here.



# --- /home/runner/workspace/finanzas/constants.py ---
# finanzas/constants.py (nuevo archivo)
ESTADO_CUENTA_CHOICES = [
    ('PENDIENTE', 'Pendiente'),
    ('PAGADO', 'Pagado'),
    ('VENCIDO', 'Vencido'),
]


# --- /home/runner/workspace/finanzas/utils.py ---
# finanzas/utils.py
from django.utils.timezone import now
from datetime import timedelta
from finanzas.models import CuentaPorCobrar

def cuentas_por_vencer():
    hoy = now().date()
    limite = hoy + timedelta(days=3)
    return CuentaPorCobrar.objects.filter(fecha_vencimiento__range=(hoy, limite), estado='PENDIENTE')



# --- /home/runner/workspace/finanzas/urls.py ---
# finanzas/urls.py
from django.urls import path
from rest_framework.routers import DefaultRouter
from finanzas.views.cuentas_por_cobrar import CuentaPorCobrarViewSet
from finanzas.views.cuentas_por_pagar import CuentaPorPagarViewSet
from finanzas.views.pagos import PagoViewSet
from finanzas.views.reportes import (
    CuentasPorCobrarVencidasView,
    FlujoDeCajaView,
    AnalisisPorClienteProveedorView,
    CuentasPorCobrarAvanzadasView,
    FlujoDeCajaProyectadoView,
    RentabilidadClienteProveedorView,
    CicloConversionEfectivoView,
    LiquidezCorrienteView,
)

# Configura el router para las vistas generales de los modelos
router = DefaultRouter()
router.register(r'cuentas_por_pagar', CuentaPorPagarViewSet, basename='cuentas_por_pagar')
router.register(r'cuentas_por_cobrar', CuentaPorCobrarViewSet, basename='cuentas_por_cobrar')
router.register(r'pagos', PagoViewSet, basename='pagos')



urlpatterns = [
    path('reports/overdue_accounts_receivable/', CuentasPorCobrarVencidasView.as_view(), name='overdue_accounts_receivable'),
    path('reports/cash_flow/', FlujoDeCajaView.as_view(), name='cash_flow'),
    path('reports/customer_supplier_analysis/', AnalisisPorClienteProveedorView.as_view(), name='customer_supplier_analysis'),
    path('reports/advanced_accounts_receivable/', CuentasPorCobrarAvanzadasView.as_view(), name='advanced_accounts_receivable'),
    path('reports/projected_cash_flow/', FlujoDeCajaProyectadoView.as_view(), name='projected_cash_flow'),
    path('reports/customer_supplier_profitability/', RentabilidadClienteProveedorView.as_view(), name='customer_supplier_profitability'),
    path('reports/cash_conversion_cycle/', CicloConversionEfectivoView.as_view(), name='cash_conversion_cycle'),
    path('reports/current_liquidity/', LiquidezCorrienteView.as_view(), name='current_liquidity'),
]

# Incluir las rutas del router (esto es para las vistas de los modelos)
urlpatterns += router.urls



# --- /home/runner/workspace/finanzas/apps.py ---
from django.apps import AppConfig

class FinanzasConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'finanzas'

    def ready(self):
        import finanzas.signals


# --- /home/runner/workspace/finanzas/models.py ---
from django.db import models
from django.utils import timezone
from django.core.exceptions import ValidationError
from django.db.models import Sum
from django.db.models import TextChoices
from django.utils.timezone import now
from core.models import Empresa
from ventas.models import Venta
from compras.models import Compra
from accounts.models import Usuario



# ──────────────────────────────────────
# ENUMS: Estados y Métodos de Pago
# ──────────────────────────────────────

class EstadoCuentaChoices(TextChoices):
    PENDIENTE = 'PENDIENTE', 'Pendiente'
    PAGADO = 'PAGADO', 'Pagado'
    VENCIDO = 'VENCIDO', 'Vencido'


class MetodoPagoChoices(TextChoices):
    EFECTIVO = 'EFECTIVO', 'Efectivo'
    TARJETA = 'TARJETA', 'Tarjeta'
    TRANSFERENCIA = 'TRANSFERENCIA', 'Transferencia'
    CHEQUE = 'CHEQUE', 'Cheque'
    OTRO = 'OTRO', 'Otro'


# ──────────────────────────────
# Modelo: Cuenta por Cobrar
# ──────────────────────────────

class CuentaPorCobrar(models.Model):
    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE, related_name='cuentas_por_cobrar', default=4)
    venta = models.ForeignKey(Venta, on_delete=models.CASCADE, related_name='cuentas_por_cobrar')
    monto = models.DecimalField(max_digits=14, decimal_places=2)
    fecha_vencimiento = models.DateField()
    estado = models.CharField(max_length=10, choices=EstadoCuentaChoices.choices, default=EstadoCuentaChoices.PENDIENTE)
    notas = models.TextField(blank=True, null=True)

    def clean(self):
        if self.monto <= 0:
            raise ValidationError("El monto debe ser mayor a cero.")
        if self.fecha_vencimiento < timezone.now().date():
            raise ValidationError("La fecha de vencimiento no puede estar en el pasado.")

    @property
    def monto_pagado(self):
        return self.pagos.aggregate(total=Sum('monto'))['total'] or 0

    @property
    def saldo_pendiente(self):
        return round(self.monto - self.monto_pagado, 2)

    def actualizar_estado(self):
        if self.saldo_pendiente <= 0:
            self.estado = EstadoCuentaChoices.PAGADO
        elif self.fecha_vencimiento < timezone.now().date():
            self.estado = EstadoCuentaChoices.VENCIDO
        else:
            self.estado = EstadoCuentaChoices.PENDIENTE
        self.save()

    class Meta:
        verbose_name = "Cuenta por Cobrar"
        verbose_name_plural = "Cuentas por Cobrar"
        ordering = ['fecha_vencimiento']
        indexes = [
            models.Index(fields=['fecha_vencimiento', 'estado']),
            models.Index(fields=['venta']),
        ]

    def __str__(self):
        return f"CxC Venta #{self.venta.id} - {self.estado} - ${self.monto}"


# ──────────────────────────────
# Modelo: Cuenta por Pagar
# ──────────────────────────────

class CuentaPorPagar(models.Model):
    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE, related_name='cuentas_por_pagar', default=4)
    compra = models.ForeignKey(Compra, on_delete=models.CASCADE, related_name='cuentas_por_pagar')
    monto = models.DecimalField(max_digits=14, decimal_places=2)
    fecha_vencimiento = models.DateField()
    estado = models.CharField(max_length=10, choices=EstadoCuentaChoices.choices, default=EstadoCuentaChoices.PENDIENTE)
    notas = models.TextField(blank=True, null=True)

    def clean(self):
        if self.monto <= 0:
            raise ValidationError("El monto debe ser mayor a cero.")
        if self.fecha_vencimiento < timezone.now().date():
            raise ValidationError("La fecha de vencimiento no puede estar en el pasado.")

    @property
    def monto_pagado(self):
        return self.pagos.aggregate(total=Sum('monto'))['total'] or 0

    @property
    def saldo_pendiente(self):
        return round(self.monto - self.monto_pagado, 2)

    def actualizar_estado(self):
        if self.saldo_pendiente <= 0:
            self.estado = EstadoCuentaChoices.PAGADO
        elif self.fecha_vencimiento < timezone.now().date():
            self.estado = EstadoCuentaChoices.VENCIDO
        else:
            self.estado = EstadoCuentaChoices.PENDIENTE
        self.save()

    class Meta:
        verbose_name = "Cuenta por Pagar"
        verbose_name_plural = "Cuentas por Pagar"
        ordering = ['fecha_vencimiento']
        indexes = [
            models.Index(fields=['fecha_vencimiento', 'estado']),
            models.Index(fields=['compra']),
        ]

    def __str__(self):
        return f"CxP Compra #{self.compra.id} - {self.estado} - ${self.monto}"


# ──────────────────────────────
# Modelo: Pago (CxC o CxP)
# ──────────────────────────────

def hoy_fecha():
    return now().date()

class Pago(models.Model):
    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE, related_name='pagos', default=4)
    cuenta_cobrar = models.ForeignKey(CuentaPorCobrar, on_delete=models.CASCADE, null=True, blank=True, related_name='pagos')
    cuenta_pagar = models.ForeignKey(CuentaPorPagar, on_delete=models.CASCADE, null=True, blank=True, related_name='pagos')
    monto = models.DecimalField(max_digits=14, decimal_places=2)
    fecha = models.DateField(default=hoy_fecha)
    metodo_pago = models.CharField(max_length=20, choices=MetodoPagoChoices.choices)
    observaciones = models.TextField(blank=True, null=True)
    comprobante = models.FileField(upload_to='comprobantes/', null=True, blank=True)
    asiento_contable_creado = models.BooleanField(default=False)
    usuario = models.ForeignKey(Usuario, on_delete=models.SET_NULL, null=True, blank=True)

    def clean(self):
        if self.monto <= 0:
            raise ValidationError("El monto del pago debe ser mayor a cero.")
        if not self.cuenta_cobrar and not self.cuenta_pagar:
            raise ValidationError("El pago debe estar vinculado a una cuenta por cobrar o por pagar.")
        if self.cuenta_cobrar and self.cuenta_pagar:
            raise ValidationError("Un pago no puede estar vinculado a ambas cuentas a la vez.")

        # Verificación de que el pago no exceda el saldo pendiente de la cuenta
        if self.cuenta_cobrar:
            if self.monto > self.cuenta_cobrar.saldo_pendiente:
                raise ValidationError("El monto del pago excede el saldo pendiente de la cuenta por cobrar.")
        if self.cuenta_pagar:
            if self.monto > self.cuenta_pagar.saldo_pendiente:
                raise ValidationError("El monto del pago excede el saldo pendiente de la cuenta por pagar.")

    def save(self, *args, **kwargs):
        self.full_clean()  # Asegura que las validaciones del modelo se ejecuten antes de guardar
        super().save(*args, **kwargs)
        if self.cuenta_cobrar:
            self.cuenta_cobrar.actualizar_estado()
        if self.cuenta_pagar:
            self.cuenta_pagar.actualizar_estado()

    class Meta:
        verbose_name = "Pago"
        verbose_name_plural = "Pagos"
        ordering = ['-fecha']
        indexes = [
            models.Index(fields=['fecha']),
            models.Index(fields=['metodo_pago']),
        ]

    def __str__(self):
        cuenta = 'CxC' if self.cuenta_cobrar else 'CxP'
        referencia = self.cuenta_cobrar_id or self.cuenta_pagar_id or 'N/A'
        return f"Pago {cuenta} #{referencia} - ${self.monto} - {self.fecha}"




# --- /home/runner/workspace/finanzas/signals.py ---
# finanzas/signals.py

from django.db.models.signals import post_delete, post_save
from django.dispatch import receiver
from finanzas.models import Pago
from contabilidad.models import AsientoContable, DetalleAsiento, CuentaContable
from django.core.exceptions import ObjectDoesNotExist

# -------------------------
# Eliminar Asiento al borrar un Pago
# -------------------------

@receiver(post_delete, sender=Pago)
def eliminar_asiento_al_eliminar_pago(sender, instance, **kwargs):
    try:
        AsientoContable.objects.filter(
            referencia_id=instance.id,
            referencia_tipo='Pago',
            empresa=instance.empresa
        ).delete()
    except Exception as e:
        print(f"❌ Error eliminando asiento contable al borrar pago: {e}")


# -------------------------
# Crear Asiento al crear un Pago
# -------------------------

@receiver(post_save, sender=Pago)
def crear_asiento_para_pago(sender, instance, created, **kwargs):
    if not created or instance.asiento_contable_creado:
        return  # Evita duplicados

    try:
        # Buscar cuentas contables relacionadas al pago
        banco_cuenta = CuentaContable.objects.get(codigo='1020', empresa=instance.empresa)
        gasto_cuenta = CuentaContable.objects.get(codigo='6000', empresa=instance.empresa)
    except ObjectDoesNotExist as e:
        print(f"❌ Error: cuenta contable no encontrada: {e}")
        return

    try:
        # Crear asiento contable
        asiento = AsientoContable.objects.create(
            empresa=instance.empresa,
            fecha=instance.fecha,
            concepto=f'Pago automático #{instance.id}',
            usuario=instance.usuario,
            conciliado=False,
            referencia_id=instance.id,
            referencia_tipo='Pago',
            total_debe=instance.monto,
            total_haber=instance.monto,
            es_automatico=True,
        )

        # Cargar detalle del asiento (Banco - Haber)
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=banco_cuenta,
            debe=0,
            haber=instance.monto,
            descripcion='Salida de dinero (Pago)'
        )

        # Cargar detalle del asiento (Gasto - Debe)
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=gasto_cuenta,
            debe=instance.monto,
            haber=0,
            descripcion='Gasto generado por el pago'
        )

        # Marcar pago como ya registrado contablemente
        instance.asiento_contable_creado = True
        instance.save(update_fields=["asiento_contable_creado"])

    except Exception as e:
        print(f"❌ Error creando asiento contable para el pago: {e}")




# # finanzas/signals.py
# from django.db.models.signals import post_delete
# from django.dispatch import receiver
# from finanzas.models import Pago
# from contabilidad.models import AsientoContable

# from django.db.models.signals import post_save
# from django.dispatch import receiver
# from finanzas.models import Pago
# from contabilidad.models import AsientoContable, DetalleAsiento, CuentaContable

# @receiver(post_delete, sender=Pago)
# def eliminar_asiento_al_eliminar_pago(sender, instance, **kwargs):
#     try:
#         AsientoContable.objects.filter(
#             referencia_id=instance.id,
#             referencia_tipo='Pago',
#             empresa=instance.empresa
#         ).delete()
#     except Exception as e:
#         print(f"Error eliminando asiento contable al borrar pago: {e}")



# @receiver(post_save, sender=Pago)
# def crear_asiento_para_pago(sender, instance, created, **kwargs):
#     if not created or instance.asiento_contable_creado:
#         return  # Evitar duplicados

#     banco_cuenta = CuentaContable.objects.get(codigo='1020')  # Ejemplo: Banco
#     gasto_cuenta = CuentaContable.objects.get(codigo='6000')  # Ejemplo: Gasto general

#     asiento = AsientoContable.objects.create(
#         empresa=instance.empresa,
#         fecha=instance.fecha,
#         concepto=f'Pago automático #{instance.id}',
#         usuario=instance.usuario,
#         conciliado=False,
#         referencia_id=instance.id,
#         referencia_tipo='Pago',
#         total_debe=instance.monto,
#         total_haber=instance.monto,
#         es_automatico=True,
#     )

#     DetalleAsiento.objects.create(
#         asiento=asiento,
#         cuenta_contable=banco_cuenta,
#         debe=0,
#         haber=instance.monto,
#         descripcion='Salida de dinero (Pago)'
#     )

#     DetalleAsiento.objects.create(
#         asiento=asiento,
#         cuenta_contable=gasto_cuenta,
#         debe=instance.monto,
#         haber=0,
#         descripcion='Gasto generado por el pago'
#     )

#     # Marcar que ya fue generado para evitar duplicados
#     instance.asiento_contable_creado = True
#     instance.save(update_fields=["asiento_contable_creado"])



# --- /home/runner/workspace/finanzas/migrations/__init__.py ---



# --- /home/runner/workspace/finanzas/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
import finanzas.models
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('compras', '0001_initial'),
        ('core', '0001_initial'),
        ('ventas', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CuentaPorCobrar',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('monto', models.DecimalField(decimal_places=2, max_digits=14)),
                ('fecha_vencimiento', models.DateField()),
                ('estado', models.CharField(choices=[('PENDIENTE', 'Pendiente'), ('PAGADO', 'Pagado'), ('VENCIDO', 'Vencido')], default='PENDIENTE', max_length=10)),
                ('notas', models.TextField(blank=True, null=True)),
                ('empresa', models.ForeignKey(default=4, on_delete=django.db.models.deletion.CASCADE, related_name='cuentas_por_cobrar', to='core.empresa')),
                ('venta', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='cuentas_por_cobrar', to='ventas.venta')),
            ],
            options={
                'verbose_name': 'Cuenta por Cobrar',
                'verbose_name_plural': 'Cuentas por Cobrar',
                'ordering': ['fecha_vencimiento'],
            },
        ),
        migrations.CreateModel(
            name='CuentaPorPagar',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('monto', models.DecimalField(decimal_places=2, max_digits=14)),
                ('fecha_vencimiento', models.DateField()),
                ('estado', models.CharField(choices=[('PENDIENTE', 'Pendiente'), ('PAGADO', 'Pagado'), ('VENCIDO', 'Vencido')], default='PENDIENTE', max_length=10)),
                ('notas', models.TextField(blank=True, null=True)),
                ('compra', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='cuentas_por_pagar', to='compras.compra')),
                ('empresa', models.ForeignKey(default=4, on_delete=django.db.models.deletion.CASCADE, related_name='cuentas_por_pagar', to='core.empresa')),
            ],
            options={
                'verbose_name': 'Cuenta por Pagar',
                'verbose_name_plural': 'Cuentas por Pagar',
                'ordering': ['fecha_vencimiento'],
            },
        ),
        migrations.CreateModel(
            name='Pago',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('monto', models.DecimalField(decimal_places=2, max_digits=14)),
                ('fecha', models.DateField(default=finanzas.models.hoy_fecha)),
                ('metodo_pago', models.CharField(choices=[('EFECTIVO', 'Efectivo'), ('TARJETA', 'Tarjeta'), ('TRANSFERENCIA', 'Transferencia'), ('CHEQUE', 'Cheque'), ('OTRO', 'Otro')], max_length=20)),
                ('observaciones', models.TextField(blank=True, null=True)),
                ('comprobante', models.FileField(blank=True, null=True, upload_to='comprobantes/')),
                ('asiento_contable_creado', models.BooleanField(default=False)),
                ('cuenta_cobrar', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='pagos', to='finanzas.cuentaporcobrar')),
                ('cuenta_pagar', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='pagos', to='finanzas.cuentaporpagar')),
                ('empresa', models.ForeignKey(default=4, on_delete=django.db.models.deletion.CASCADE, related_name='pagos', to='core.empresa')),
                ('usuario', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Pago',
                'verbose_name_plural': 'Pagos',
                'ordering': ['-fecha'],
            },
        ),
        migrations.AddIndex(
            model_name='cuentaporcobrar',
            index=models.Index(fields=['fecha_vencimiento', 'estado'], name='finanzas_cu_fecha_v_ed0862_idx'),
        ),
        migrations.AddIndex(
            model_name='cuentaporcobrar',
            index=models.Index(fields=['venta'], name='finanzas_cu_venta_i_fcf135_idx'),
        ),
        migrations.AddIndex(
            model_name='cuentaporpagar',
            index=models.Index(fields=['fecha_vencimiento', 'estado'], name='finanzas_cu_fecha_v_ec0010_idx'),
        ),
        migrations.AddIndex(
            model_name='cuentaporpagar',
            index=models.Index(fields=['compra'], name='finanzas_cu_compra__fb090c_idx'),
        ),
        migrations.AddIndex(
            model_name='pago',
            index=models.Index(fields=['fecha'], name='finanzas_pa_fecha_24441f_idx'),
        ),
        migrations.AddIndex(
            model_name='pago',
            index=models.Index(fields=['metodo_pago'], name='finanzas_pa_metodo__d75da5_idx'),
        ),
    ]



# --- /home/runner/workspace/finanzas/views/__init_.py ---
from .cuentas_por_pagar import CuentaPorPagarViewSet
from .cuentas_por_cobrar import CuentaPorCobrarViewSet
from .pagos import PagoViewSet

__all__ = [
    "CuentaPorPagarViewSet",
    "CuentaPorCobrarViewSet",
    "PagoViewSet",
]


# --- /home/runner/workspace/finanzas/views/cuentas_por_cobrar.py ---
from finanzas.models import CuentaPorCobrar
from finanzas.serializers import CuentaPorCobrarSerializer
from rest_framework import viewsets, filters
from rest_framework.permissions import IsAuthenticated

class CuentaPorCobrarViewSet(viewsets.ModelViewSet):
    """
    Listar cuentas por cobrar con filtros por cliente, estado y fecha de vencimiento.
    """
    queryset = CuentaPorCobrar.objects.select_related('venta__cliente').all()
    serializer_class = CuentaPorCobrarSerializer
    permission_classes = [IsAuthenticated]

    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    search_fields = ['venta__cliente__nombre']
    ordering_fields = ['fecha_vencimiento', 'estado']
    ordering = ['fecha_vencimiento']

    def get_queryset(self):
        qs = super().get_queryset()
        estado = self.request.query_params.get('estado')
        if estado:
            qs = qs.filter(estado=estado)
        fecha = self.request.query_params.get('fecha_vencimiento')
        if fecha:
            qs = qs.filter(fecha_vencimiento=fecha)
        return qs



# --- /home/runner/workspace/finanzas/views/cuentas_por_pagar.py ---
from rest_framework import viewsets, filters
from finanzas.models import CuentaPorPagar
from finanzas.serializers import CuentaPorPagarSerializer
from rest_framework.permissions import IsAuthenticated

class CuentaPorPagarViewSet(viewsets.ModelViewSet):
    """
    Listar cuentas por pagar con filtros por proveedor, estado y fecha de vencimiento.
    """
    queryset = CuentaPorPagar.objects.select_related('compra__proveedor').all()
    serializer_class = CuentaPorPagarSerializer
    permission_classes = [IsAuthenticated]

    filter_backends = [filters.SearchFilter, filters.OrderingFilter]
    search_fields = ['compra__proveedor__nombre']
    ordering_fields = ['fecha_vencimiento', 'estado']
    ordering = ['fecha_vencimiento']

    def get_queryset(self):
        qs = super().get_queryset()
        # Filtrar por estado
        estado = self.request.query_params.get('estado')
        if estado:
            qs = qs.filter(estado=estado)
        # Filtrar por fecha_vencimiento (fecha exacta o rango?)
        fecha = self.request.query_params.get('fecha_vencimiento')
        if fecha:
            qs = qs.filter(fecha_vencimiento=fecha)
        return qs



# --- /home/runner/workspace/finanzas/views/reportes.py ---
from django.db.models import Sum, Count
from django.utils.dateparse import parse_date
from django.utils.timezone import now
from rest_framework.response import Response
from rest_framework.views import APIView
from datetime import date, timedelta
from django.db.models.functions import TruncMonth
from django.db.models import Avg, F, ExpressionWrapper, DurationField
from rest_framework.exceptions import ValidationError
from finanzas.models import (
    Pago,
    Venta,
    CuentaPorCobrar,
    CuentaPorPagar,
    Compra,
)


class CuentasPorCobrarVencidasView(APIView):
    def get(self, request):
        empresa_id = request.query_params.get('empresa')
        sucursal_id = request.query_params.get('sucursal')
        cliente_id = request.query_params.get('cliente')
        fecha_limite = request.query_params.get('fecha_limite') or date.today()

        cuentas = CuentaPorCobrar.objects.filter(estado='PENDIENTE', fecha_vencimiento__lte=fecha_limite)

        if empresa_id:
            cuentas = cuentas.filter(venta__empresa_id=empresa_id)
        if sucursal_id:
            cuentas = cuentas.filter(venta__sucursal_id=sucursal_id)
        if cliente_id:
            cuentas = cuentas.filter(cliente_id=cliente_id)

        total = cuentas.aggregate(total=Sum('monto'))['total'] or 0
        return Response({"cuentas_por_cobrar_vencidas": total})
        

class FlujoDeCajaView(APIView):
    def get(self, request):
        empresa_id = request.query_params.get('empresa')
        sucursal_id = request.query_params.get('sucursal')

        fecha_inicio_str = request.query_params.get('fecha_inicio')
        fecha_fin_str = request.query_params.get('fecha_fin')

        if fecha_inicio_str and fecha_fin_str:
            try:
                fecha_inicio = parse_date(fecha_inicio_str)
                fecha_fin = parse_date(fecha_fin_str)
                if not fecha_inicio or not fecha_fin:
                    raise ValueError
            except Exception:
                raise ValidationError("Los parámetros 'fecha_inicio' y 'fecha_fin' deben tener formato YYYY-MM-DD.")
        else:
            fecha_inicio = fecha_fin = None

        ingresos = Pago.objects.filter(cuenta_cobrar__isnull=False)
        egresos = Pago.objects.filter(cuenta_pagar__isnull=False)

        if empresa_id:
            ingresos = ingresos.filter(empresa_id=empresa_id)
            egresos = egresos.filter(empresa_id=empresa_id)
        if sucursal_id:
            ingresos = ingresos.filter(sucursal_id=sucursal_id)
            egresos = egresos.filter(sucursal_id=sucursal_id)
        if fecha_inicio and fecha_fin:
            ingresos = ingresos.filter(fecha__range=[fecha_inicio, fecha_fin])
            egresos = egresos.filter(fecha__range=[fecha_inicio, fecha_fin])

        total_ingresos = ingresos.aggregate(total=Sum('monto'))['total'] or 0
        total_egresos = egresos.aggregate(total=Sum('monto'))['total'] or 0

        return Response({
            "ingresos": total_ingresos,
            "egresos": total_egresos,
            "flujo_neto": total_ingresos - total_egresos
        })


class AnalisisPorClienteProveedorView(APIView):
    def get(self, request):
        cliente_id = request.query_params.get('cliente')
        proveedor_id = request.query_params.get('proveedor')

        # Validar que los parámetros de fecha sean strings antes de parsearlos
        fecha_inicio_str = request.query_params.get('fecha_inicio')
        fecha_fin_str = request.query_params.get('fecha_fin')

        fecha_inicio = parse_date(fecha_inicio_str) if fecha_inicio_str else None
        fecha_fin = parse_date(fecha_fin_str) if fecha_fin_str else None

        ventas = Venta.objects.all()
        compras = Compra.objects.all()

        if cliente_id:
            ventas = ventas.filter(cliente_id=cliente_id)
        if proveedor_id:
            compras = compras.filter(proveedor_id=proveedor_id)
        if fecha_inicio and fecha_fin:
            ventas = ventas.filter(fecha__range=[fecha_inicio, fecha_fin])
            compras = compras.filter(fecha__range=[fecha_inicio, fecha_fin])

        total_ventas = ventas.aggregate(total=Sum('total'))['total'] or 0
        total_compras = compras.aggregate(total=Sum('total'))['total'] or 0

        return Response({
            "ventas_cliente": total_ventas,
            "compras_proveedor": total_compras
        })


class CuentasPorCobrarAvanzadasView(APIView):
    def get(self, request):
        empresa_id = request.query_params.get('empresa')
        sucursal_id = request.query_params.get('sucursal')
        cliente_id = request.query_params.get('cliente')

        fecha_inicio_str = request.query_params.get('fecha_inicio')
        fecha_fin_str = request.query_params.get('fecha_fin')

        fecha_inicio = parse_date(fecha_inicio_str) if isinstance(fecha_inicio_str, str) else None
        fecha_fin = parse_date(fecha_fin_str) if isinstance(fecha_fin_str, str) else None

        cxc = CuentaPorCobrar.objects.all()

        if empresa_id:
            cxc = cxc.filter(venta__empresa_id=empresa_id)
        if sucursal_id:
            cxc = cxc.filter(venta__sucursal_id=sucursal_id)
        if cliente_id:
            cxc = cxc.filter(cliente_id=cliente_id)
        if fecha_inicio and fecha_fin:
            cxc = cxc.filter(fecha__range=[fecha_inicio, fecha_fin])

        total = cxc.aggregate(total=Sum('monto'))['total'] or 0
        return Response({"cuentas_por_cobrar": total})


class FlujoDeCajaProyectadoView(APIView):
    def get(self, request):
        empresa_id = request.query_params.get('empresa')

        fecha_inicio_str = request.query_params.get('fecha_inicio')
        fecha_fin_str = request.query_params.get('fecha_fin')

        fecha_inicio = parse_date(fecha_inicio_str) if isinstance(fecha_inicio_str, str) else None
        fecha_fin = parse_date(fecha_fin_str) if isinstance(fecha_fin_str, str) else None


        pagos = Pago.objects.all()

        if empresa_id:
            pagos = pagos.filter(empresa_id=empresa_id)
        if fecha_inicio and fecha_fin:
            pagos = pagos.filter(fecha__range=[fecha_inicio, fecha_fin])

        proyeccion = pagos.annotate(mes=TruncMonth('fecha')).values('mes').annotate(total=Sum('monto')).order_by('mes')

        return Response({"flujo_proyectado": proyeccion})



class RentabilidadClienteProveedorView(APIView):
    def get(self, request):
        cliente_id = request.query_params.get('cliente')
        proveedor_id = request.query_params.get('proveedor')

        fecha_inicio_str = request.query_params.get('fecha_inicio')
        fecha_fin_str = request.query_params.get('fecha_fin')

        fecha_inicio = parse_date(fecha_inicio_str) if isinstance(fecha_inicio_str, str) else None
        fecha_fin = parse_date(fecha_fin_str) if isinstance(fecha_fin_str, str) else None

        ventas = Venta.objects.all()
        compras = Compra.objects.all()

        if cliente_id:
            ventas = ventas.filter(cliente_id=cliente_id)
        if proveedor_id:
            compras = compras.filter(proveedor_id=proveedor_id)

        if fecha_inicio and fecha_fin:
            ventas = ventas.filter(fecha__range=[fecha_inicio, fecha_fin])
            compras = compras.filter(fecha__range=[fecha_inicio, fecha_fin])

        total_ventas = ventas.aggregate(total=Sum('total'))['total'] or 0
        total_compras = compras.aggregate(total=Sum('total'))['total'] or 0
        rentabilidad = total_ventas - total_compras

        return Response({
            "ventas": total_ventas,
            "compras": total_compras,
            "rentabilidad": rentabilidad,
        })



class CicloConversionEfectivoView(APIView):
    def get(self, request):
        empresa_id = request.query_params.get('empresa')
        fecha_inicio = request.query_params.get('fecha_inicio')
        fecha_fin = request.query_params.get('fecha_fin')

        ventas = Venta.objects.all()
        compras = Compra.objects.all()

        if empresa_id:
            ventas = ventas.filter(empresa_id=empresa_id)
            compras = compras.filter(empresa_id=empresa_id)

        if fecha_inicio and fecha_fin:
            ventas = ventas.filter(fecha__range=[fecha_inicio, fecha_fin])
            compras = compras.filter(fecha__range=[fecha_inicio, fecha_fin])

        cxc_qs = CuentaPorCobrar.objects.filter(venta__in=ventas)
        cxc_qs = cxc_qs.annotate(
            dias_para_cobro=ExpressionWrapper(
                F('fecha_vencimiento') - F('venta__fecha'),
                output_field=DurationField()
            )
        )

        cxc_avg = cxc_qs.aggregate(avg=Avg('dias_para_cobro'))['avg']

        if cxc_avg:
            promedio_dias_cobro = cxc_avg.total_seconds() / (60*60*24)
        else:
            promedio_dias_cobro = 0

        cxp_qs = CuentaPorPagar.objects.filter(compra__in=compras)
        cxp_qs = cxp_qs.annotate(
            dias_para_pago=ExpressionWrapper(
                F('fecha_vencimiento') - F('compra__fecha'),
                output_field=DurationField()
            )
        )

        cxp_avg = cxp_qs.aggregate(avg=Avg('dias_para_pago'))['avg']

        if cxp_avg:
            promedio_dias_pago = cxp_avg.total_seconds() / (60*60*24)
        else:
            promedio_dias_pago = 0

        ciclo = round(promedio_dias_cobro - promedio_dias_pago, 2)

        return Response({"ciclo_conversion_efectivo": ciclo})



class LiquidezCorrienteView(APIView):
    """
    Vista para obtener el ratio de liquidez corriente con filtros por fecha, empresa y sucursal.
    """
    def get(self, request):
        empresa_id = request.query_params.get('empresa')
        fecha_inicio = parse_date(request.query_params.get('fecha_inicio'))
        fecha_fin = parse_date(request.query_params.get('fecha_fin'))

        cxc = CuentaPorCobrar.objects.filter(estado='PENDIENTE')
        cxp = CuentaPorPagar.objects.filter(estado='PENDIENTE')

        if empresa_id:
            cxc = cxc.filter(venta__empresa_id=empresa_id)
            cxp = cxp.filter(compra__empresa_id=empresa_id)

        if fecha_inicio and fecha_fin:
            cxc = cxc.filter(fecha_vencimiento__range=[fecha_inicio, fecha_fin])
            cxp = cxp.filter(fecha_vencimiento__range=[fecha_inicio, fecha_fin])

        activos_corrientes = cxc.aggregate(total=Sum('monto'))['total'] or 0
        pasivos_corrientes = cxp.aggregate(total=Sum('monto'))['total'] or 0

        if pasivos_corrientes == 0:
            ratio = "N/A"
        else:
            ratio = round(activos_corrientes / pasivos_corrientes, 2)

        return Response({"liquidez_corriente": ratio})



# --- /home/runner/workspace/finanzas/views/pagos.py ---
from finanzas.models import Pago
from finanzas.serializers import PagoSerializer
from rest_framework import status, viewsets
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from contabilidad.utils.asientos import registrar_asiento_pago
from rest_framework.exceptions import ValidationError
from contabilidad.models import AsientoContable

class PagoViewSet(viewsets.ModelViewSet):
    # ...
    queryset = Pago.objects.all()
    serializer_class = PagoSerializer  # ✅ <-- esta línea es obligatoria
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        pago = serializer.save()

        # Crear asiento contable automático
        try:
            registrar_asiento_pago(pago, request.user)
        except Exception as e:
            # Loguear error en consola (puedes usar logging)
            print(f"Error al registrar asiento contable: {e}")
            # Retornar respuesta exitosa pero con advertencia
            return Response({
                "pago": PagoSerializer(pago).data,
                "advertencia": f"No se pudo registrar el asiento contable: {str(e)}"
            }, status=status.HTTP_201_CREATED)

        return Response(PagoSerializer(pago).data, status=status.HTTP_201_CREATED)


    def destroy(self, request, *args, **kwargs):
        pago = self.get_object()

        asiento = AsientoContable.objects.filter(
            referencia_id=pago.id,
            referencia_tipo='Pago',
            empresa=pago.empresa
        ).first()

        if asiento and asiento.conciliado:
            raise ValidationError("No se puede eliminar este pago porque su asiento contable ya está conciliado o cerrado.")

        return super().destroy(request, *args, **kwargs)

    def update(self, request, *args, **kwargs):
        pago = self.get_object()
        asiento = AsientoContable.objects.filter(
            referencia_id=pago.id,
            referencia_tipo='Pago',
            empresa=pago.empresa
        ).first()

        if asiento and asiento.conciliado:
            return Response(
                {"detail": "No se puede modificar este pago porque su asiento contable ya está conciliado o cerrado."},
                status=status.HTTP_400_BAD_REQUEST
            )
        return super().update(request, *args, **kwargs)




# --- /home/runner/workspace/finanzas/serializers/__init__.py ---
from .cuentas_por_cobrar_serializer import CuentaPorCobrarSerializer
from .cuentas_por_pagar_serializer import CuentaPorPagarSerializer
from .pago_serializer import PagoSerializer



# --- /home/runner/workspace/finanzas/serializers/cuentas_por_cobrar_serializer.py ---
from finanzas.models import CuentaPorCobrar
from rest_framework import serializers

class CuentaPorCobrarSerializer(serializers.ModelSerializer):
    venta = serializers.PrimaryKeyRelatedField(read_only=True)
    monto_pagado = serializers.DecimalField(max_digits=14, decimal_places=2, read_only=True)
    saldo = serializers.DecimalField(max_digits=14, decimal_places=2, read_only=True)

    class Meta:
        model = CuentaPorCobrar
        fields = [
            'id',
            'venta',
            'monto',
            'monto_pagado',
            'saldo',
            'fecha_vencimiento',
            'estado',
            'notas',
        ]
        read_only_fields = ['id', 'monto_pagado', 'saldo', 'estado']



# --- /home/runner/workspace/finanzas/serializers/cuentas_por_pagar_serializer.py ---
from rest_framework import serializers
from finanzas.models import CuentaPorPagar, Pago

class CuentaPorPagarSerializer(serializers.ModelSerializer):
    compra = serializers.PrimaryKeyRelatedField(read_only=True)
    monto_pagado = serializers.DecimalField(max_digits=14, decimal_places=2, read_only=True)
    saldo = serializers.DecimalField(max_digits=14, decimal_places=2, read_only=True)

    class Meta:
        model = CuentaPorPagar
        fields = [
            'id',
            'compra',
            'monto',
            'monto_pagado',
            'saldo',
            'fecha_vencimiento',
            'estado',
            'notas',
        ]
        read_only_fields = ['id', 'monto_pagado', 'saldo', 'estado']



# --- /home/runner/workspace/finanzas/serializers/pago_serializer.py ---
from finanzas.models import Pago, CuentaPorPagar, CuentaPorCobrar
from rest_framework import serializers
from django.core.exceptions import ValidationError

class PagoSerializer(serializers.ModelSerializer):
    cuenta_pagar = serializers.PrimaryKeyRelatedField(
        queryset=CuentaPorPagar.objects.all(), allow_null=True, required=False
    )
    cuenta_cobrar = serializers.PrimaryKeyRelatedField(
        queryset=CuentaPorCobrar.objects.all(), allow_null=True, required=False
    )
    saldo_actual = serializers.SerializerMethodField(read_only=True)
    tipo_cuenta = serializers.SerializerMethodField(read_only=True)
    comprobante = serializers.FileField(required=False, allow_null=True)

    class Meta:
        model = Pago
        fields = [
            'id',
            'cuenta_pagar',
            'cuenta_cobrar',
            'monto',
            'fecha',
            'metodo_pago',
            'saldo_actual',
            'tipo_cuenta',
            'observaciones',
            'comprobante',
        ]
        read_only_fields = ['id', 'saldo_actual', 'tipo_cuenta']

    def get_saldo_actual(self, obj):
        if obj.cuenta_pagar:
            return obj.cuenta_pagar.saldo_pendiente
        if obj.cuenta_cobrar:
            return obj.cuenta_cobrar.saldo_pendiente
        return None

    def get_tipo_cuenta(self, obj):
        if obj.cuenta_pagar:
            return 'CuentaPorPagar'
        if obj.cuenta_cobrar:
            return 'CuentaPorCobrar'
        return None

    def validate(self, data):
        cuenta_pagar = data.get('cuenta_pagar')
        cuenta_cobrar = data.get('cuenta_cobrar')
        monto = data.get('monto')

        if not cuenta_pagar and not cuenta_cobrar:
            raise serializers.ValidationError("El pago debe estar vinculado a una cuenta por pagar o por cobrar.")
        if cuenta_pagar and cuenta_cobrar:
            raise serializers.ValidationError("El pago no puede estar vinculado a ambas cuentas a la vez.")

        # Obtener saldo pendiente para validar monto
        saldo_pendiente = None
        if cuenta_pagar:
            saldo_pendiente = cuenta_pagar.saldo_pendiente
        elif cuenta_cobrar:
            saldo_pendiente = cuenta_cobrar.saldo_pendiente

        if monto is None or monto <= 0:
            raise serializers.ValidationError("El monto del pago debe ser mayor a cero.")
        if saldo_pendiente is not None and monto > saldo_pendiente:
            raise serializers.ValidationError(f"El monto del pago (${monto}) no puede exceder el saldo pendiente (${saldo_pendiente}).")

        return data



# --- /home/runner/workspace/finanzas/tests/__init__.py ---



# --- /home/runner/workspace/finanzas/tests/test_finanzas.py ---

from django.core.exceptions import ValidationError

from django.test import TestCase
from django.utils import timezone
from datetime import timedelta
from accounts.models import Usuario
from core.models import Empresa
from compras.models import Proveedor, Compra
from ventas.models import Venta, Cliente
from finanzas.models import CuentaPorCobrar, CuentaPorPagar, Pago, MetodoPagoChoices
from decimal import Decimal

class FinanzasTests(TestCase):
    def setUp(self):
        # Crear una empresa sin especificar el ID (se asignará automáticamente)
        self.empresa = Empresa.objects.create(
            nombre="Mi Empresa",
            razon_social="Razón Social",
            rfc="ABC1234567890",
            domicilio_fiscal="Calle Ficticia 123",
            regimen_fiscal="General"
        )

        self.fecha_venc = timezone.now().date() + timedelta(days=7)

        # Crear un usuario de prueba usando el modelo 'Usuario' personalizado
        self.usuario = Usuario.objects.create_user(
            username='testuser', 
            password='testpassword', 
            empresa=self.empresa
        )

        # Crear un proveedor antes de la compra
        self.proveedor = Proveedor.objects.create(
            nombre="Proveedor de prueba",
            empresa=self.empresa
        )

        # Crear un cliente antes de la venta (soluciona el problema de clave foránea)
        self.cliente = Cliente.objects.create(
            nombre="Cliente de prueba",
            empresa=self.empresa
        )


        # Simulamos venta y compra con el usuario asignado
        self.venta = Venta.objects.create(cliente_id=self.cliente.id, total=1000, empresa=self.empresa, usuario=self.usuario)
        self.compra = Compra.objects.create(proveedor=self.proveedor, total=500, empresa=self.empresa)

        # Cuentas
        self.cxc = CuentaPorCobrar.objects.create(
            empresa=self.empresa, venta=self.venta, monto=1000, fecha_vencimiento=self.fecha_venc
        )
        self.cxp = CuentaPorPagar.objects.create(
            empresa=self.empresa, compra=self.compra, monto=500, fecha_vencimiento=self.fecha_venc
        )

    def test_crear_cuenta_por_pagar(self):
        self.assertEqual(self.cxp.monto, Decimal('500.00'))
        self.assertEqual(self.cxp.estado, "PENDIENTE")

    def test_crear_cuenta_por_cobrar(self):
        self.assertEqual(self.cxc.monto, Decimal('1000.00'))
        self.assertEqual(self.cxc.estado, "PENDIENTE")

    def test_pago_parcial_cuenta_por_cobrar(self):
        Pago.objects.create(cuenta_cobrar=self.cxc, monto=400, fecha=timezone.now(), metodo_pago=MetodoPagoChoices.EFECTIVO, empresa=self.empresa)
        self.cxc.refresh_from_db()
        self.assertEqual(self.cxc.estado, "PENDIENTE")
        self.assertEqual(self.cxc.saldo_pendiente, Decimal('600.00'))

    def test_pago_total_cuenta_por_pagar(self):
        Pago.objects.create(cuenta_pagar=self.cxp, monto=500, fecha=timezone.now(), metodo_pago=MetodoPagoChoices.TRANSFERENCIA, empresa=self.empresa)
        self.cxp.refresh_from_db()
        self.assertEqual(self.cxp.estado, "PAGADO")
        self.assertEqual(self.cxp.saldo_pendiente, Decimal('0.00'))


    def test_pago_excesivo_lanza_error(self):
        # Intentamos crear un pago cuyo monto excede el saldo pendiente
        with self.assertRaises(ValidationError):  # Aseguramos que se lance una ValidationError
            pago = Pago.objects.create(
                cuenta_pagar=self.cxp,
                monto=600,
                fecha=timezone.now(),
                metodo_pago=MetodoPagoChoices.CHEQUE,
                empresa=self.empresa
            )
            pago.full_clean()  # Esto ejecuta la validación manualmente antes de guardar






# === Archivo: contabilidad_combined.py ===

# --- /home/runner/workspace/contabilidad/__init__.py ---



# --- /home/runner/workspace/contabilidad/admin.py ---
from django.contrib import admin

# Register your models here.



# --- /home/runner/workspace/contabilidad/apps.py ---
from django.apps import AppConfig


class ContabilidadConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'contabilidad'



# --- /home/runner/workspace/contabilidad/app.py ---
# def ready(self):
#   import contabilidad.signals  # cambia por el nombre real

from django.apps import AppConfig

class ContabilidadConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'contabilidad'

    def ready(self):
        import contabilidad.signals


# --- /home/runner/workspace/contabilidad/permissions.py ---
# accounts/permissions.py

from rest_framework import permissions

class EsAdminEmpresa(permissions.BasePermission):
    """
    Permite solo a usuarios con rol administrador de la empresa.
    """
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and request.user.rol and request.user.rol.nombre == 'Administrador'



# --- /home/runner/workspace/contabilidad/models.py ---
from django.db import models
from django.utils import timezone
from accounts.models import Usuario, Empresa
from django.core.exceptions import ValidationError

# ---------------------- MODELO BASE DE CUENTAS ----------------------

class CuentaContable(models.Model):
    """
    Catálogo de cuentas contables según el plan contable de la empresa.
    Puede ser compartido entre empresas o personalizado por empresa.
    """
    CLASIFICACIONES = [
        ('activo', 'Activo'),
        ('pasivo', 'Pasivo'),
        ('patrimonio', 'Patrimonio'),
        ('ingreso', 'Ingreso'),
        ('gasto', 'Gasto'),
    ]

    codigo = models.CharField(max_length=10, help_text="Código único, ej: 1020")
    nombre = models.CharField(max_length=255, help_text="Ej: Banco BBVA")
    clasificacion = models.CharField(max_length=20, choices=CLASIFICACIONES)
    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE, related_name='cuentas_contables')
    es_auxiliar = models.BooleanField(default=True, help_text="Marca si la cuenta es de movimiento o de agrupación")
    padre = models.ForeignKey('self', null=True, blank=True, on_delete=models.SET_NULL, related_name='subcuentas')
    creada_en = models.DateTimeField(auto_now_add=True)

    @property
    def saldo(self):
        debe = sum(m.debe for m in self.movimientos.all())
        haber = sum(m.haber for m in self.movimientos.all())
        return debe - haber

    class Meta:
        verbose_name = "Cuenta Contable"
        verbose_name_plural = "Cuentas Contables"
        ordering = ['codigo']
        unique_together = ('codigo', 'empresa')

    def __str__(self):
        return f"{self.codigo} - {self.nombre}"

    def clean(self):
        super().clean()
        if CuentaContable.objects.filter(
            codigo=self.codigo,
            empresa=self.empresa
        ).exclude(pk=self.pk).exists():
            raise ValidationError(f"Ya existe una cuenta con el código '{self.codigo}' para esta empresa.")

    def save(self, *args, **kwargs):
        self.full_clean()  # <- Esto asegura que clean() se ejecute siempre
        super().save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        if self.movimientos.exists():
            raise ValidationError("No se puede eliminar una cuenta contable que tiene movimientos registrados.")
        super().delete(*args, **kwargs)

# ---------------------- MODELO DE ASIENTOS ----------------------



class AsientoContable(models.Model):
    """
    Representa un asiento contable (doble partida).
    Puede ser generado automáticamente por otros módulos (ej: pagos).
    """
    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE, related_name='asientos_contables')
    fecha = models.DateField(default=timezone.now)
    concepto = models.CharField(max_length=255)
    usuario = models.ForeignKey(Usuario, on_delete=models.SET_NULL, null=True, blank=True, related_name='asientos_creados')
    creado_en = models.DateTimeField(auto_now_add=True)
    conciliado = models.BooleanField(default=False, help_text="Indica si el asiento está conciliado o cerrado")

    # 🔗 Referencia al objeto origen (ej: Pago, Compra, etc.)
    referencia_id = models.PositiveBigIntegerField(null=True, blank=True, help_text="ID del objeto origen (ej: pago, compra, etc.)")
    referencia_tipo = models.CharField(max_length=100, null=True, blank=True, help_text="Tipo de objeto origen (ej: 'Pago', 'Compra')")

    # 🧾 Totales rápidos para reportes
    total_debe = models.DecimalField(max_digits=14, decimal_places=2, default=0)
    total_haber = models.DecimalField(max_digits=14, decimal_places=2, default=0)

    # ⚙️ Indica si fue generado automáticamente
    es_automatico = models.BooleanField(default=False)

    class Meta:
        verbose_name = "Asiento Contable"
        verbose_name_plural = "Asientos Contables"
        ordering = ['-fecha', '-creado_en']
        indexes = [
            models.Index(fields=['empresa', 'fecha']),
            models.Index(fields=['referencia_tipo', 'referencia_id']),
        ]

    def __str__(self):
        return f"Asiento #{self.id} - {self.concepto} ({self.fecha})"

    def save(self, *args, **kwargs):
        self.full_clean()  # Valida antes de guardar
        super().save(*args, **kwargs)

    def clean(self):
        super().clean()
        if not self.pk:
            # No validar detalles si el asiento no está guardado aún
            return

        detalles = list(self.detalles.all())

        if len(detalles) < 2:
            raise ValidationError("El asiento debe tener al menos dos líneas contables.")

        total_debe = sum(detalle.debe for detalle in detalles)
        total_haber = sum(detalle.haber for detalle in detalles)

        if total_debe != total_haber:
            raise ValidationError("La suma del Debe debe ser igual a la del Haber (partida doble).")

    def actualizar_totales(self):
        """
        Suma todos los debe/haber de sus detalles y actualiza los campos total_debe y total_haber.
        """
        self.total_debe = sum(d.debe for d in self.detalles.all())
        self.total_haber = sum(d.haber for d in self.detalles.all())
        self.save(update_fields=['total_debe', 'total_haber'])

# ---------------------- DETALLES DE ASIENTO ----------------------

class DetalleAsiento(models.Model):
    """
    Detalle de una línea contable (debe o haber).
    Usa una cuenta contable como FK.
    """
    asiento = models.ForeignKey(AsientoContable, on_delete=models.CASCADE, related_name='detalles')
    cuenta_contable = models.ForeignKey(CuentaContable, on_delete=models.PROTECT, related_name='movimientos')
    debe = models.DecimalField(max_digits=14, decimal_places=2, default=0)
    haber = models.DecimalField(max_digits=14, decimal_places=2, default=0)
    descripcion = models.TextField(blank=True, null=True, help_text="Descripción opcional para este movimiento.")

    class Meta:
        verbose_name = "Detalle de Asiento"
        verbose_name_plural = "Detalles de Asientos"
        ordering = ['cuenta_contable']
        indexes = [
            models.Index(fields=['asiento', 'cuenta_contable']),
        ]
        constraints = [
            models.CheckConstraint(
                condition=~(models.Q(debe=0) & models.Q(haber=0)),
                name='debe_o_haber_no_pueden_ser_cero',
            )
        ]

    def save(self, *args, **kwargs):
        self.full_clean()  # Ejecuta clean() antes de guardar
        super().save(*args, **kwargs)

    def clean(self):
        if self.debe < 0 or self.haber < 0:
            raise ValidationError("Debe y Haber no pueden ser negativos.")
        if self.debe == 0 and self.haber == 0:
            raise ValidationError("Debe o Haber deben tener un valor distinto de cero.")
        if self.debe > 0 and self.haber > 0:
            raise ValidationError("No puede tener valores en ambos campos a la vez.")

    def __str__(self):
        return f"{self.cuenta_contable.codigo} | Debe: {self.debe} | Haber: {self.haber}"



# --- /home/runner/workspace/contabilidad/urls.py ---
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from contabilidad.views.asiento_contable import AsientoContableViewSet
from contabilidad.views.cuenta_contable import CuentaContableViewSet
from contabilidad.views.reportes_contables import ReportesContablesView

router = DefaultRouter()
router.register(r'entries', AsientoContableViewSet, basename='asiento')
router.register(r'accounts', CuentaContableViewSet, basename='cuenta_contable')


urlpatterns = [
    path('', include(router.urls)),
    path('reports/', ReportesContablesView.as_view(), name='reportes-contables')
]





# --- /home/runner/workspace/contabilidad/signals.py ---
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from .models import DetalleAsiento

@receiver([post_save, post_delete], sender=DetalleAsiento)
def actualizar_totales_asiento(sender, instance, **kwargs):
    print(f"Signal disparado para DetalleAsiento id={instance.id}")
    asiento = instance.asiento
    if not asiento:
        print("¡El detalle no tiene asignado asiento!")
        return
    try:
        asiento.actualizar_totales()
        print(f"Asiento {asiento.id} actualizado: debe={asiento.total_debe}, haber={asiento.total_haber}")
    except Exception as e:
        print(f"Error actualizando totales del asiento {asiento.id}: {e}")


# --- /home/runner/workspace/contabilidad/migrations/__init__.py ---



# --- /home/runner/workspace/contabilidad/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
import django.utils.timezone
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='AsientoContable',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('fecha', models.DateField(default=django.utils.timezone.now)),
                ('concepto', models.CharField(max_length=255)),
                ('creado_en', models.DateTimeField(auto_now_add=True)),
                ('conciliado', models.BooleanField(default=False, help_text='Indica si el asiento está conciliado o cerrado')),
                ('referencia_id', models.PositiveBigIntegerField(blank=True, help_text='ID del objeto origen (ej: pago, compra, etc.)', null=True)),
                ('referencia_tipo', models.CharField(blank=True, help_text="Tipo de objeto origen (ej: 'Pago', 'Compra')", max_length=100, null=True)),
                ('total_debe', models.DecimalField(decimal_places=2, default=0, max_digits=14)),
                ('total_haber', models.DecimalField(decimal_places=2, default=0, max_digits=14)),
                ('es_automatico', models.BooleanField(default=False)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='asientos_contables', to='core.empresa')),
                ('usuario', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='asientos_creados', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Asiento Contable',
                'verbose_name_plural': 'Asientos Contables',
                'ordering': ['-fecha', '-creado_en'],
            },
        ),
        migrations.CreateModel(
            name='CuentaContable',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('codigo', models.CharField(help_text='Código único, ej: 1020', max_length=10)),
                ('nombre', models.CharField(help_text='Ej: Banco BBVA', max_length=255)),
                ('clasificacion', models.CharField(choices=[('activo', 'Activo'), ('pasivo', 'Pasivo'), ('patrimonio', 'Patrimonio'), ('ingreso', 'Ingreso'), ('gasto', 'Gasto')], max_length=20)),
                ('es_auxiliar', models.BooleanField(default=True, help_text='Marca si la cuenta es de movimiento o de agrupación')),
                ('creada_en', models.DateTimeField(auto_now_add=True)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='cuentas_contables', to='core.empresa')),
                ('padre', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='subcuentas', to='contabilidad.cuentacontable')),
            ],
            options={
                'verbose_name': 'Cuenta Contable',
                'verbose_name_plural': 'Cuentas Contables',
                'ordering': ['codigo'],
            },
        ),
        migrations.CreateModel(
            name='DetalleAsiento',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('debe', models.DecimalField(decimal_places=2, default=0, max_digits=14)),
                ('haber', models.DecimalField(decimal_places=2, default=0, max_digits=14)),
                ('descripcion', models.TextField(blank=True, help_text='Descripción opcional para este movimiento.', null=True)),
                ('asiento', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='detalles', to='contabilidad.asientocontable')),
                ('cuenta_contable', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='movimientos', to='contabilidad.cuentacontable')),
            ],
            options={
                'verbose_name': 'Detalle de Asiento',
                'verbose_name_plural': 'Detalles de Asientos',
                'ordering': ['cuenta_contable'],
            },
        ),
        migrations.AddIndex(
            model_name='asientocontable',
            index=models.Index(fields=['empresa', 'fecha'], name='contabilida_empresa_2ddfb3_idx'),
        ),
        migrations.AddIndex(
            model_name='asientocontable',
            index=models.Index(fields=['referencia_tipo', 'referencia_id'], name='contabilida_referen_82230c_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='cuentacontable',
            unique_together={('codigo', 'empresa')},
        ),
        migrations.AddIndex(
            model_name='detalleasiento',
            index=models.Index(fields=['asiento', 'cuenta_contable'], name='contabilida_asiento_f6ba5e_idx'),
        ),
        migrations.AddConstraint(
            model_name='detalleasiento',
            constraint=models.CheckConstraint(condition=models.Q(('debe', 0), ('haber', 0), _negated=True), name='debe_o_haber_no_pueden_ser_cero'),
        ),
    ]



# --- /home/runner/workspace/contabilidad/views/__init__.py ---
from contabilidad.views.asiento_contable import AsientoContableViewSet


# --- /home/runner/workspace/contabilidad/views/detalle_asiento.py ---
from rest_framework import serializers
from contabilidad.models import DetalleAsiento

class DetalleAsientoSerializer(serializers.ModelSerializer):
    class Meta:
        model = DetalleAsiento
        fields = ['id', 'asiento', 'cuenta_contable', 'debe', 'haber', 'descripcion']
        read_only_fields = ['id']

    def validate(self, data):
        debe = data.get('debe', 0)
        haber = data.get('haber', 0)

        if debe < 0 or haber < 0:
            raise serializers.ValidationError("Debe y Haber no pueden ser negativos.")

        if debe == 0 and haber == 0:
            raise serializers.ValidationError("Debe o Haber deben tener un valor distinto de cero.")

        if debe > 0 and haber > 0:
            raise serializers.ValidationError("No puede tener valores en Debe y Haber al mismo tiempo.")

        return data



# --- /home/runner/workspace/contabilidad/views/cuenta_contable.py ---
# contabilidad/views/cuenta_contable.py

from rest_framework import viewsets, permissions
from contabilidad.models import CuentaContable
from contabilidad.serializers.cuenta_contable import CuentaContableSerializer
from django_filters.rest_framework import DjangoFilterBackend

class CuentaContableViewSet(viewsets.ModelViewSet):
    queryset = CuentaContable.objects.all()
    serializer_class = CuentaContableSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['empresa', 'codigo', 'padre']
    serializer_class = CuentaContableSerializer
    permission_classes = [permissions.IsAuthenticated]  # Aquí puedes agregar permisos personalizados

    def get_queryset(self):
        empresa = getattr(self.request.user, 'empresa_actual', None)
        if empresa:
            return CuentaContable.objects.filter(empresa=empresa).order_by('codigo')
        return CuentaContable.objects.none()

    def get_serializer_context(self):
        context = super().get_serializer_context()
        context['empresa'] = getattr(self.request.user, 'empresa_actual', None)
        return context



# --- /home/runner/workspace/contabilidad/views/asiento_contable.py ---
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from rest_framework.permissions import IsAuthenticated
from django_filters.rest_framework import DjangoFilterBackend
from contabilidad.models import AsientoContable
from contabilidad.serializers.asiento_contable import AsientoContableSerializer
from rest_framework.exceptions import ValidationError


class AsientoContableViewSet(viewsets.ModelViewSet):
    queryset = AsientoContable.objects.all()
    serializer_class = AsientoContableSerializer
    filter_backends = [DjangoFilterBackend]
    filterset_fields = ['fecha', 'usuario', 'conciliado']
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        empresa = getattr(self.request.user, 'empresa_actual', None)
        if empresa:
            return AsientoContable.objects.filter(empresa=empresa)\
                .select_related('empresa')\
                .prefetch_related('detalles')
        return AsientoContable.objects.none()

    def get_serializer_context(self):
        context = super().get_serializer_context()
        context['empresa'] = getattr(self.request.user, 'empresa_actual', None)
        return context

    def perform_create(self, serializer):
        empresa = getattr(self.request.user, 'empresa_actual', None)
        if not empresa:
            raise ValidationError("No se ha definido la empresa actual del usuario.")
        serializer.save(empresa=empresa)

    def update(self, request, *args, **kwargs):
        asiento = self.get_object()
        if asiento.conciliado:
            return Response(
                {"detail": "No se puede modificar un asiento contable ya conciliado."},
                status=status.HTTP_400_BAD_REQUEST
            )
        return super().update(request, *args, **kwargs)


    @action(detail=True, methods=['patch'], url_path='conciliar')
    def conciliar(self, request, pk=None):
        asiento = self.get_object()
        if asiento.conciliado:
            return Response({"detail": "Este asiento ya está conciliado."}, status=status.HTTP_400_BAD_REQUEST)

        asiento.conciliado = True
        asiento.save(update_fields=['conciliado'])
        return Response({"detail": "Asiento conciliado correctamente."}, status=status.HTTP_200_OK)


# --- /home/runner/workspace/contabilidad/views/reportes_contables.py ---
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError
from contabilidad.models import AsientoContable, DetalleAsiento, CuentaContable
from django.db.models import Sum, Q


class ReportesContablesView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        empresa = getattr(request.user, 'empresa_actual', None)
        tipo = request.query_params.get('tipo')
        fecha_inicio = request.query_params.get('fecha_inicio')
        fecha_fin = request.query_params.get('fecha_fin')

        if not empresa:
            raise ValidationError("El usuario no tiene empresa_actual definida.")
        if tipo not in ['journal', 'trial_balance', 'income_statement', 'balance_sheet']:
            raise ValidationError("Invalid report type.")

        if tipo == 'journal':
            return self.libro_diario(empresa, fecha_inicio, fecha_fin)
        elif tipo == 'trial_balance':
            return self.balance_comprobacion(empresa, fecha_inicio, fecha_fin)
        elif tipo == 'income_statement':
            return self.estado_resultados(empresa, fecha_inicio, fecha_fin)
        elif tipo == 'balance_sheet':
            return self.balance_general(empresa, fecha_inicio, fecha_fin)

    def libro_diario(self, empresa, fecha_inicio, fecha_fin):
        filtros = Q(empresa=empresa)
        if fecha_inicio:
            filtros &= Q(fecha__gte=fecha_inicio)
        if fecha_fin:
            filtros &= Q(fecha__lte=fecha_fin)

        asientos = AsientoContable.objects.filter(filtros).prefetch_related('detalles')
        resultado = []
        for asiento in asientos:
            resultado.append({
                'id': asiento.id,
                'fecha': asiento.fecha,
                'concepto': asiento.concepto,
                'detalles': [
                    {
                        'cuenta': d.cuenta_contable.codigo,
                        'nombre': d.cuenta_contable.nombre,
                        'debe': float(d.debe),
                        'haber': float(d.haber),
                        'descripcion': d.descripcion
                    } for d in asiento.detalles.all()
                ]
            })
        return Response({'libro_diario': resultado})

    def balance_comprobacion(self, empresa, fecha_inicio, fecha_fin):
        filtros = Q(asiento__empresa=empresa)
        if fecha_inicio:
            filtros &= Q(asiento__fecha__gte=fecha_inicio)
        if fecha_fin:
            filtros &= Q(asiento__fecha__lte=fecha_fin)

        detalles = DetalleAsiento.objects.filter(filtros).values(
            'cuenta_contable__codigo',
            'cuenta_contable__nombre'
        ).annotate(
            total_debe=Sum('debe'),
            total_haber=Sum('haber')
        ).order_by('cuenta_contable__codigo')
        return Response({'balance_comprobacion': list(detalles)})

    def estado_resultados(self, empresa, fecha_inicio, fecha_fin):
        cuentas = CuentaContable.objects.filter(
            empresa=empresa,
            clasificacion__in=['ingreso', 'gasto']
        )
        resultado = []
        total_ingresos = 0
        total_gastos = 0

        for cuenta in cuentas:
            movimientos = cuenta.movimientos.all()
            if fecha_inicio:
                movimientos = movimientos.filter(asiento__fecha__gte=fecha_inicio)
            if fecha_fin:
                movimientos = movimientos.filter(asiento__fecha__lte=fecha_fin)

            debe = movimientos.aggregate(s=Sum('debe'))['s'] or 0
            haber = movimientos.aggregate(s=Sum('haber'))['s'] or 0
            saldo = haber - debe if cuenta.clasificacion == 'ingreso' else debe - haber

            resultado.append({
                'codigo': cuenta.codigo,
                'nombre': cuenta.nombre,
                'clasificacion': cuenta.clasificacion,
                'saldo': float(saldo)
            })

            if cuenta.clasificacion == 'ingreso':
                total_ingresos += saldo
            else:
                total_gastos += saldo

        utilidad_neta = total_ingresos - total_gastos
        return Response({
            'estado_resultados': resultado,
            'totales': {
                'ingresos': float(total_ingresos),
                'gastos': float(total_gastos),
                'utilidad_neta': float(utilidad_neta)
            }
        })

    def balance_general(self, empresa, fecha_inicio, fecha_fin):
        cuentas = CuentaContable.objects.filter(
            empresa=empresa,
            clasificacion__in=['activo', 'pasivo', 'patrimonio']
        )
        resultado = []
        totales = {'activo': 0, 'pasivo': 0, 'patrimonio': 0}

        for cuenta in cuentas:
            movimientos = cuenta.movimientos.all()
            if fecha_inicio:
                movimientos = movimientos.filter(asiento__fecha__gte=fecha_inicio)
            if fecha_fin:
                movimientos = movimientos.filter(asiento__fecha__lte=fecha_fin)

            debe = movimientos.aggregate(s=Sum('debe'))['s'] or 0
            haber = movimientos.aggregate(s=Sum('haber'))['s'] or 0
            saldo = debe - haber if cuenta.clasificacion == 'activo' else haber - debe

            resultado.append({
                'codigo': cuenta.codigo,
                'nombre': cuenta.nombre,
                'clasificacion': cuenta.clasificacion,
                'saldo': float(saldo)
            })

            totales[cuenta.clasificacion] += saldo

        return Response({
            'balance_general': resultado,
            'totales': {k: float(v) for k, v in totales.items()}
        })



# --- /home/runner/workspace/contabilidad/serializers/__init__.py ---
# contabilidad/serializers/__init__.py
from .asiento_contable import AsientoContableSerializer
from .detalle_asiento import DetalleAsientoSerializer


# --- /home/runner/workspace/contabilidad/serializers/detalle_asiento.py ---
from rest_framework import serializers
from contabilidad.models import AsientoContable, DetalleAsiento, CuentaContable
from accounts.models import Usuario
from django.db import transaction


class DetalleAsientoSerializer(serializers.ModelSerializer):
  cuenta_contable_codigo = serializers.ReadOnlyField(source='cuenta_contable.codigo')
  cuenta_contable_nombre = serializers.ReadOnlyField(source='cuenta_contable.nombre')

  class Meta:
      model = DetalleAsiento
      fields = ['id', 'cuenta_contable', 'cuenta_contable_codigo', 'cuenta_contable_nombre', 'debe', 'haber', 'descripcion']

  def validate(self, data):
      debe = data.get('debe', 0)
      haber = data.get('haber', 0)

      if debe < 0 or haber < 0:
          raise serializers.ValidationError("Debe y Haber no pueden ser negativos.")
      if debe == 0 and haber == 0:
          raise serializers.ValidationError("Debe o Haber deben tener un valor distinto de cero.")
      if debe > 0 and haber > 0:
          raise serializers.ValidationError("No puede tener valores en ambos campos a la vez.")

      return data


# --- /home/runner/workspace/contabilidad/serializers/cuenta_contable.py ---
# contabilidad/serializers/cuenta_contable.py

from rest_framework import serializers
from contabilidad.models import CuentaContable

class CuentaContableSerializer(serializers.ModelSerializer):
    class Meta:
        model = CuentaContable
        fields = ['id', 'codigo', 'nombre', 'clasificacion', 'empresa', 'es_auxiliar', 'padre', 'creada_en']
        read_only_fields = ['creada_en', 'empresa']

    def validate_codigo(self, value):
        empresa = self.context.get('empresa')
        if CuentaContable.objects.filter(codigo=value, empresa=empresa).exists():
            raise serializers.ValidationError("Ya existe una cuenta con ese código para esta empresa.")
        return value

    def validate(self, data):
        if data.get('padre') and data['padre'].empresa != self.context.get('empresa'):
            raise serializers.ValidationError("La cuenta padre debe pertenecer a la misma empresa.")
        return data

    def create(self, validated_data):
        empresa = self.context.get('empresa')
        validated_data['empresa'] = empresa
        return super().create(validated_data)

    def update(self, instance, validated_data):
        # No permitimos cambiar empresa en update para evitar inconsistencias
        validated_data.pop('empresa', None)
        return super().update(instance, validated_data)



# --- /home/runner/workspace/contabilidad/serializers/asiento_contable.py ---
from rest_framework import serializers
from contabilidad.models import AsientoContable, DetalleAsiento, CuentaContable
from accounts.models import Usuario
from django.db import transaction
from contabilidad.serializers.detalle_asiento import DetalleAsientoSerializer

class AsientoContableSerializer(serializers.ModelSerializer):
    detalles = DetalleAsientoSerializer(many=True)
    usuario = serializers.PrimaryKeyRelatedField(queryset=Usuario.objects.all(), required=False, allow_null=True)
    empresa = serializers.PrimaryKeyRelatedField(read_only=True)
    total_debe = serializers.DecimalField(read_only=True, max_digits=14, decimal_places=2)
    total_haber = serializers.DecimalField(read_only=True, max_digits=14, decimal_places=2)
    conciliado = serializers.BooleanField(read_only=True)
    es_automatico = serializers.BooleanField(read_only=True)

    class Meta:
        model = AsientoContable
        fields = [
            'id', 'empresa', 'fecha', 'concepto', 'usuario', 'creado_en', 'conciliado',
            'referencia_id', 'referencia_tipo', 'total_debe', 'total_haber', 'es_automatico',
            'detalles'
        ]
        read_only_fields = ['creado_en']

    def validate(self, data):
        # Bloquear modificación si está conciliado
        if self.instance and self.instance.conciliado:
            raise serializers.ValidationError("No se puede modificar un asiento contable ya conciliado.")

        detalles = data.get('detalles', None)

        # Validar detalles solo si vienen en la petición
        if detalles is not None:
            if len(detalles) < 2:
                raise serializers.ValidationError("Debe haber al menos dos detalles en el asiento para cumplir partida doble.")

            total_debe = sum(d.get('debe', 0) for d in detalles)
            total_haber = sum(d.get('haber', 0) for d in detalles)

            if total_debe != total_haber:
                raise serializers.ValidationError(
                    "El total del debe debe ser igual al total del haber (partida doble)."
                )

        return data

    @transaction.atomic
    def create(self, validated_data):
        detalles_data = validated_data.pop('detalles')
        empresa = self.context.get('empresa')
        if empresa:
            validated_data['empresa'] = empresa

        asiento = AsientoContable.objects.create(**validated_data)

        total_debe = 0
        total_haber = 0
        for detalle_data in detalles_data:
            detalle = DetalleAsiento.objects.create(asiento=asiento, **detalle_data)
            total_debe += detalle.debe
            total_haber += detalle.haber

        asiento.total_debe = total_debe
        asiento.total_haber = total_haber
        asiento.save(update_fields=['total_debe', 'total_haber'])
        return asiento

    @transaction.atomic
    def update(self, instance, validated_data):
        # Bloquear actualización si está conciliado
        if instance.conciliado:
            raise serializers.ValidationError("No se puede modificar un asiento contable ya conciliado.")

        detalles_data = validated_data.pop('detalles', None)

        # Actualizar campos permitidos
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()

        if detalles_data is not None:
            instance.detalles.all().delete()
            total_debe = 0
            total_haber = 0
            for detalle_data in detalles_data:
                detalle = DetalleAsiento.objects.create(asiento=instance, **detalle_data)
                total_debe += detalle.debe
                total_haber += detalle.haber

            instance.total_debe = total_debe
            instance.total_haber = total_haber
            instance.save(update_fields=['total_debe', 'total_haber'])

        return instance


        


# --- /home/runner/workspace/contabilidad/utils/asientos.py ---
from contabilidad.models import AsientoContable, DetalleAsiento, CuentaContable

def registrar_asiento_pago(pago, usuario):
    """
    Crea un asiento contable al registrar un pago a proveedor o cliente.
    """
    empresa = pago.empresa
    monto = pago.monto
    cuenta_banco = CuentaContable.objects.get(codigo='1020', empresa=empresa)

    if pago.cuenta_pagar:
        proveedor = pago.cuenta_pagar.proveedor
        cuenta_proveedor = CuentaContable.objects.get(codigo='2010', empresa=empresa)

        concepto = f"Pago a proveedor {proveedor.nombre}"
        descripcion = f"Disminución de cuenta por pagar a {proveedor.nombre}"

        asiento = AsientoContable.objects.create(
            empresa=empresa,
            fecha=pago.fecha,
            concepto=concepto,
            usuario=usuario,
            referencia_id=pago.id,
            referencia_tipo='Pago',
            es_automatico=True,
        )

        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_proveedor,
            debe=monto,
            descripcion=descripcion
        )
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_banco,
            haber=monto,
            descripcion="Pago realizado desde banco"
        )

    elif pago.cuenta_cobrar:
        cliente = pago.cuenta_cobrar.cliente
        cuenta_cliente = CuentaContable.objects.get(codigo='1050', empresa=empresa)

        concepto = f"Pago recibido de cliente {cliente.nombre}"
        descripcion = f"Disminución de cuenta por cobrar de {cliente.nombre}"

        asiento = AsientoContable.objects.create(
            empresa=empresa,
            fecha=pago.fecha,
            concepto=concepto,
            usuario=usuario,
            referencia_id=pago.id,
            referencia_tipo='Pago',
            es_automatico=True,
        )

        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_banco,
            debe=monto,
            descripcion="Ingreso en banco"
        )
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_cliente,
            haber=monto,
            descripcion=descripcion
        )
    else:
        raise ValueError("El pago no está vinculado ni a una cuenta por pagar ni por cobrar.")

    asiento.actualizar_totales()
    return asiento


# --- /home/runner/workspace/contabilidad/tests/__init__.py ---



# --- /home/runner/workspace/contabilidad/tests/test_models.py ---
import pytest
from django.core.exceptions import ValidationError
from contabilidad.models import AsientoContable

@pytest.mark.django_db
def test_no_modificar_conciliado(empresa, usuario):
    asiento = AsientoContable.objects.create(
        fecha="2025-07-21",
        empresa=empresa,
        usuario=usuario,
        conciliado=True,
        concepto="Concepto de prueba"
    )
    with pytest.raises(ValidationError):
        asiento.conciliado = True
        asiento.full_clean()  # dispara validaciones


# --- /home/runner/workspace/contabilidad/tests/conftest.py ---
import pytest
from contabilidad.models import AsientoContable, CuentaContable
from accounts.models import Usuario
from core.models import Empresa

@pytest.fixture
def empresa(db):
    return Empresa.objects.create(nombre="Empresa Test")

@pytest.fixture
def usuario(db, empresa):
    return Usuario.objects.create(username="user1", empresa=empresa)

@pytest.fixture
def cuenta_contable_1(db, empresa):
    return CuentaContable.objects.create(
        codigo="001",  # código único dentro de la empresa
        nombre="Cuenta 1",
        clasificacion="activo",  # debe estar dentro de las opciones válidas
        empresa=empresa
    )

@pytest.fixture
def cuenta_contable_2(db, empresa):
    return CuentaContable.objects.create(
        codigo="002",  # código único dentro de la empresa
        nombre="Cuenta 2",
        clasificacion="activo",  # debe estar dentro de las opciones válidas
        empresa=empresa
    )    

@pytest.fixture
def asiento_data(empresa, usuario, cuenta_contable_1, cuenta_contable_2):
    return {
        "fecha": "2025-07-21",
        "usuario": usuario.id,
        "concepto": "Concepto de prueba",
        "detalles": [
            {"cuenta_contable": cuenta_contable_1.id, "debe": 100, "haber": 0},
            {"cuenta_contable": cuenta_contable_2.id, "debe": 0, "haber": 100},
        ],
    }

@pytest.fixture
def asiento_creado(db, empresa, usuario):
    return AsientoContable.objects.create(
        fecha="2025-07-21",
        empresa=empresa,
        usuario=usuario,
        conciliado=False,
        concepto="test"
    )

@pytest.fixture
def asiento_conciliado(db, empresa, usuario, cuenta_contable_1, cuenta_contable_2):
    asiento = AsientoContable.objects.create(
        fecha="2025-07-21",
        empresa=empresa,
        usuario=usuario,
        conciliado=True,
        concepto="test"
    )
    # Añadir detalles válidos
    from contabilidad.models import DetalleAsiento
    DetalleAsiento.objects.create(
        asiento=asiento,
        cuenta_contable=cuenta_contable_1,
        debe=100,
        haber=0
    )
    DetalleAsiento.objects.create(
        asiento=asiento,
        cuenta_contable=cuenta_contable_2,
        debe=0,
        haber=100
    )
    return asiento


# --- /home/runner/workspace/contabilidad/tests/test_views.py ---
import pytest
from rest_framework.test import APIClient
from django.urls import reverse
from contabilidad.models import AsientoContable, DetalleAsiento

@pytest.mark.django_db
def test_list_asientos_autenticado(usuario, empresa, asiento_creado):
    client = APIClient()
    client.force_authenticate(usuario)
    url = reverse('asiento-list')
    response = client.get(url)
    assert response.status_code == 200
    # Debe mostrar solo asientos de la empresa del usuario
    for item in response.data['results']:
        assert item['empresa'] == empresa.id

@pytest.mark.django_db
def test_update_bloqueado_si_conciliado(usuario, asiento_conciliado):
    client = APIClient()
    client.force_authenticate(usuario)
    url = reverse('asiento-detail', args=[asiento_conciliado.id])
    response = client.put(url, {'fecha': '2025-07-30'})
    assert response.status_code == 400
    assert 'No se puede modificar un asiento contable ya conciliado.' in response.data['detail']

@pytest.mark.django_db
def test_accion_conciliar(usuario, asiento_creado, cuenta_contable_1, cuenta_contable_2):
    DetalleAsiento.objects.create(asiento=asiento_creado, cuenta_contable=cuenta_contable_1, debe=100, haber=0)
    DetalleAsiento.objects.create(asiento=asiento_creado, cuenta_contable=cuenta_contable_2, debe=0, haber=100)

    client = APIClient()
    client.force_authenticate(usuario)
    url = reverse('asiento-conciliar', args=[asiento_creado.id])
    response = client.patch(url)
    assert response.status_code == 200
    assert response.data['detail'] == "Asiento conciliado correctamente."
    
# @pytest.mark.django_db
# def test_accion_conciliar(usuario, asiento_creado):
#     client = APIClient()
#     client.force_authenticate(usuario)
#     url = reverse('asiento-conciliar', args=[asiento_creado.id])
#     response = client.patch(url)
#     assert response.status_code == 200
#     assert response.data['detail'] == "Asiento conciliado correctamente."

@pytest.mark.django_db
def test_accion_conciliar_ya_conciliado(usuario, asiento_conciliado):
    client = APIClient()
    client.force_authenticate(usuario)
    url = reverse('asiento-conciliar', args=[asiento_conciliado.id])
    response = client.patch(url)
    assert response.status_code == 400
    assert response.data['detail'] == "Este asiento ya está conciliado."



# --- /home/runner/workspace/contabilidad/tests/test_serializers.py ---
import pytest
from contabilidad.serializers.asiento_contable import AsientoContableSerializer
from contabilidad.models import AsientoContable, DetalleAsiento

@pytest.mark.django_db
def test_serializer_valido_creacion(asiento_data, empresa, usuario):
    # asiento_data debe ser un dict válido para crear asiento
    serializer = AsientoContableSerializer(data=asiento_data, context={'empresa': empresa})
    assert serializer.is_valid(), serializer.errors
    asiento = serializer.save()
    assert asiento.empresa == empresa

@pytest.mark.django_db
def test_serializer_error_faltan_campos():
    serializer = AsientoContableSerializer(data={})
    assert not serializer.is_valid()
    assert 'fecha' in serializer.errors or 'detalles' in serializer.errors

@pytest.mark.django_db
def test_serializer_no_modificar_conciliado(asiento_conciliado, cuenta_contable_1, cuenta_contable_2):
    # Agregamos detalles válidos
    DetalleAsiento.objects.create(asiento=asiento_conciliado, cuenta_contable=cuenta_contable_1, debe=100, haber=0)
    DetalleAsiento.objects.create(asiento=asiento_conciliado, cuenta_contable=cuenta_contable_2, debe=0, haber=100)

    # ⚠️ Refrescamos el objeto desde la BD para que tenga los detalles correctamente cargados
    asiento_conciliado.refresh_from_db()

    serializer = AsientoContableSerializer(asiento_conciliado, data={'fecha': '2025-07-22'}, partial=True)
    assert not serializer.is_valid()
    assert 'No se puede modificar un asiento contable ya conciliado.' in str(serializer.errors)

# @pytest.mark.django_db
# def test_serializer_no_modificar_conciliado(asiento_conciliado):
#     serializer = AsientoContableSerializer(asiento_conciliado, data={'fecha': '2025-07-22'}, partial=True)
#     assert not serializer.is_valid()
#     assert 'No se puede modificar un asiento contable ya conciliado.' in str(serializer.errors)



# --- /home/runner/workspace/contabilidad/tests/test_reportes.py ---
import pytest
from rest_framework.test import APIClient
from django.urls import reverse
from accounts.models import Usuario
from contabilidad.models import CuentaContable, AsientoContable, DetalleAsiento
from core.models import Empresa
from datetime import date


@pytest.fixture
def setup_contabilidad(db):
    empresa = Empresa.objects.create(nombre="Nova Corp")
    usuario = Usuario.objects.create_user(
        username="testuser", password="1234", empresa=empresa
    )

    cuenta_activo = CuentaContable.objects.create(
        empresa=empresa, codigo="1001", nombre="Caja", clasificacion="activo"
    )
    cuenta_ingreso = CuentaContable.objects.create(
        empresa=empresa, codigo="4001", nombre="Ventas", clasificacion="ingreso"
    )

    asiento = AsientoContable.objects.create(
        empresa=empresa, fecha=date(2025, 7, 1), concepto="Venta inicial", usuario=usuario
    )

    DetalleAsiento.objects.create(
        asiento=asiento, cuenta_contable=cuenta_activo, debe=1000, haber=0, descripcion="Ingreso en caja"
    )
    DetalleAsiento.objects.create(
        asiento=asiento, cuenta_contable=cuenta_ingreso, debe=0, haber=1000, descripcion="Venta realizada"
    )

    return usuario


@pytest.mark.django_db
def test_journal_report(setup_contabilidad):
    client = APIClient()
    client.force_authenticate(user=setup_contabilidad)

    url = reverse('reportes-contables') + '?tipo=journal'
    response = client.get(url)

    assert response.status_code == 200
    assert 'libro_diario' in response.data
    assert isinstance(response.data['libro_diario'], list)


@pytest.mark.django_db
def test_trial_balance_report(setup_contabilidad):
    client = APIClient()
    client.force_authenticate(user=setup_contabilidad)

    url = reverse('reportes-contables') + '?tipo=trial_balance'
    response = client.get(url)

    assert response.status_code == 200
    assert 'balance_comprobacion' in response.data
    assert isinstance(response.data['balance_comprobacion'], list)


@pytest.mark.django_db
def test_income_statement_report(setup_contabilidad):
    client = APIClient()
    client.force_authenticate(user=setup_contabilidad)

    url = reverse('reportes-contables') + '?tipo=income_statement'
    response = client.get(url)

    assert response.status_code == 200
    assert 'estado_resultados' in response.data
    assert 'totales' in response.data


@pytest.mark.django_db
def test_balance_sheet_report(setup_contabilidad):
    client = APIClient()
    client.force_authenticate(user=setup_contabilidad)

    url = reverse('reportes-contables') + '?tipo=balance_sheet'
    response = client.get(url)

    assert response.status_code == 200
    assert 'balance_general' in response.data
    assert 'totales' in response.data



# --- /home/runner/workspace/contabilidad/helpers/asientos.py ---
from decimal import Decimal
from django.db import transaction
from contabilidad.models import AsientoContable, DetalleAsiento, CuentaContable
from decimal import Decimal, ROUND_HALF_UP
from django.core.exceptions import ObjectDoesNotExist
from rest_framework.exceptions import ValidationError

def redondear_decimal(valor, decimales=2):
    if not isinstance(valor, Decimal):
        valor = Decimal(str(valor))
    return valor.quantize(Decimal('1.' + '0' * decimales), rounding=ROUND_HALF_UP)

def generar_asiento_para_venta(venta, usuario):
    empresa = venta.empresa
    try:
        cuenta_clientes = CuentaContable.objects.get(codigo='1050', empresa=empresa)
        cuenta_ingresos = CuentaContable.objects.get(codigo='4010', empresa=empresa)
        cuenta_iva = CuentaContable.objects.get(codigo='2080', empresa=empresa)
    except ObjectDoesNotExist as e:
        raise ValidationError(f"No existe la cuenta contable requerida: {str(e)}")

    # Cálculo del total e IVA
    total = redondear_decimal(venta.total)
    iva_tasa = Decimal("0.16")
    base = redondear_decimal(total / (1 + iva_tasa))
    iva = redondear_decimal(total - base)

    with transaction.atomic():
        asiento = AsientoContable.objects.create(
            empresa=empresa,
            fecha=venta.fecha,
            concepto=f"Venta #{venta.id} a {venta.cliente.nombre}",
            usuario=usuario,
            referencia_id=venta.id,
            referencia_tipo='Venta',
            es_automatico=True,
        )

        # DEBE: Cliente por cobrar (total completo)
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_clientes,
            debe=total,
            haber=Decimal('0.00'),
            descripcion="Venta - Cliente por cobrar"
        )

        # HABER: Ingresos (base sin IVA)
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_ingresos,
            debe=Decimal('0.00'),
            haber=base,
            descripcion="Venta - Ingresos"
        )

        # HABER: IVA por pagar
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_iva,
            debe=Decimal('0.00'),
            haber=iva,
            descripcion="Venta - IVA por pagar"
        )

        asiento.actualizar_totales()
        venta.asiento_contable = asiento
        venta.save()
        return asiento


from decimal import Decimal
from django.core.exceptions import ObjectDoesNotExist, ValidationError
from django.db import transaction

def generar_asiento_para_compra(compra, usuario):
    empresa = compra.empresa
    try:
        cuenta_costo = CuentaContable.objects.get(codigo='5010', empresa=empresa)
        cuenta_iva_acreditar = CuentaContable.objects.get(codigo='1180', empresa=empresa)
        cuenta_proveedores = CuentaContable.objects.get(codigo='2010', empresa=empresa)
    except ObjectDoesNotExist as e:
        raise ValidationError(f"No existe la cuenta contable requerida: {str(e)}")

    # Cálculo del total e IVA
    total = redondear_decimal(compra.total)
    iva_tasa = Decimal("0.16")
    base = redondear_decimal(total / (1 + iva_tasa))
    iva = redondear_decimal(total - base)

    with transaction.atomic():
        asiento = AsientoContable.objects.create(
            empresa=empresa,
            fecha=compra.fecha,
            concepto=f"Compra #{compra.id} de {compra.proveedor.nombre}",
            usuario=usuario,
            referencia_id=compra.id,
            referencia_tipo='Compra',
            es_automatico=True,
        )

        # DEBE: Costo de ventas (base sin IVA)
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_costo,
            debe=base,
            haber=Decimal('0.00'),
            descripcion="Compra - Costo de ventas"
        )

        # DEBE: IVA por acreditar
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_iva_acreditar,
            debe=iva,
            haber=Decimal('0.00'),
            descripcion="Compra - IVA por acreditar"
        )

        # HABER: Proveedores por pagar (total completo)
        DetalleAsiento.objects.create(
            asiento=asiento,
            cuenta_contable=cuenta_proveedores,
            debe=Decimal('0.00'),
            haber=total,
            descripcion="Compra - Proveedores por pagar"
        )

        asiento.actualizar_totales()
        # Se elimina la asignación para evitar error
        # compra.asiento_contable = asiento
        # compra.save()

        return asiento

# def generar_asiento_para_compra(compra, usuario):
#     empresa = compra.empresa
#     try:
#         cuenta_costo = CuentaContable.objects.get(codigo='5010', empresa=empresa)
#         cuenta_iva_acreditar = CuentaContable.objects.get(codigo='1180', empresa=empresa)
#         cuenta_proveedores = CuentaContable.objects.get(codigo='2010', empresa=empresa)
#     except ObjectDoesNotExist as e:
#         raise ValidationError(f"No existe la cuenta contable requerida: {str(e)}")

#     # Cálculo del total e IVA
#     total = redondear_decimal(compra.total)
#     iva_tasa = Decimal("0.16")
#     base = redondear_decimal(total / (1 + iva_tasa))
#     iva = redondear_decimal(total - base)

#     with transaction.atomic():
#         asiento = AsientoContable.objects.create(
#             empresa=empresa,
#             fecha=compra.fecha,
#             concepto=f"Compra #{compra.id} de {compra.proveedor.nombre}",
#             usuario=usuario,
#             referencia_id=compra.id,
#             referencia_tipo='Compra',
#             es_automatico=True,
#         )

#         # DEBE: Costo de ventas (base sin IVA)
#         DetalleAsiento.objects.create(
#             asiento=asiento,
#             cuenta_contable=cuenta_costo,
#             debe=base,
#             haber=Decimal('0.00'),
#             descripcion="Compra - Costo de ventas"
#         )

#         # DEBE: IVA por acreditar
#         DetalleAsiento.objects.create(
#             asiento=asiento,
#             cuenta_contable=cuenta_iva_acreditar,
#             debe=iva,
#             haber=Decimal('0.00'),
#             descripcion="Compra - IVA por acreditar"
#         )

#         # HABER: Proveedores por pagar (total completo)
#         DetalleAsiento.objects.create(
#             asiento=asiento,
#             cuenta_contable=cuenta_proveedores,
#             debe=Decimal('0.00'),
#             haber=total,
#             descripcion="Compra - Proveedores por pagar"
#         )

#         asiento.actualizar_totales()
#         compra.asiento_contable = asiento
#         compra.save()
#         return asiento




# === Archivo: rrhh_combined.py ===

# --- /home/runner/workspace/rrhh/__init__.py ---



# --- /home/runner/workspace/rrhh/admin.py ---
from django.contrib import admin

# Register your models here.



# --- /home/runner/workspace/rrhh/apps.py ---
from django.apps import AppConfig


class RrhhConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'rrhh'



# --- /home/runner/workspace/rrhh/tests.py ---
from django.test import TestCase

# Create your tests here.



# --- /home/runner/workspace/rrhh/models.py ---
# rrhh/models.py

from django.db import models
from django.core.exceptions import ValidationError
from django.utils import timezone

class Empleado(models.Model):
    empresa = models.ForeignKey('core.Empresa', on_delete=models.CASCADE, related_name='empleados')
    nombre = models.CharField(max_length=200)
    rfc = models.CharField(max_length=13, blank=True, null=True)
    puesto = models.CharField(max_length=100)
    salario = models.DecimalField(max_digits=14, decimal_places=2)

    def clean(self):
        if self.salario < 0:
            raise ValidationError("El salario no puede ser negativo.")


    class Meta:
        verbose_name = "Empleado"
        verbose_name_plural = "Empleados"
        ordering = ['nombre']
        indexes = [
            models.Index(fields=['empresa', 'nombre']),
        ]

    def __str__(self):
        return f"{self.nombre} - {self.puesto}"


class Nomina(models.Model):
    ESTADO_CHOICES = [
        ('PENDIENTE', 'Pendiente'),
        ('PAGADA', 'Pagada'),
        ('CANCELADA', 'Cancelada'),
    ]

    empleado = models.ForeignKey(Empleado, on_delete=models.CASCADE, related_name='nominas')
    periodo = models.CharField(max_length=50, help_text="Ejemplo: 'Julio 2025'")
    total = models.DecimalField(max_digits=14, decimal_places=2)
    estado = models.CharField(max_length=10, choices=ESTADO_CHOICES, default='PENDIENTE')

    class Meta:
        verbose_name = "Nómina"
        verbose_name_plural = "Nóminas"
        ordering = ['-periodo']
        indexes = [
            models.Index(fields=['empleado', 'periodo']),
            models.Index(fields=['estado']),
        ]

    def __str__(self):
        return f"Nómina {self.periodo} - {self.empleado.nombre} - {self.estado}"


class Asistencia(models.Model):
    empleado = models.ForeignKey(Empleado, on_delete=models.CASCADE, related_name='asistencias')
    fecha = models.DateField()
    hora_entrada = models.TimeField()
    hora_salida = models.TimeField()

    class Meta:
        verbose_name = "Asistencia"
        verbose_name_plural = "Asistencias"
        ordering = ['-fecha']
        indexes = [
            models.Index(fields=['empleado', 'fecha']),
        ]

    def __str__(self):
        return f"Asistencia {self.empleado.nombre} - {self.fecha}"



# --- /home/runner/workspace/rrhh/migrations/__init__.py ---



# --- /home/runner/workspace/rrhh/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Empleado',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nombre', models.CharField(max_length=200)),
                ('rfc', models.CharField(blank=True, max_length=13, null=True)),
                ('puesto', models.CharField(max_length=100)),
                ('salario', models.DecimalField(decimal_places=2, max_digits=14)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='empleados', to='core.empresa')),
            ],
            options={
                'verbose_name': 'Empleado',
                'verbose_name_plural': 'Empleados',
                'ordering': ['nombre'],
            },
        ),
        migrations.CreateModel(
            name='Asistencia',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('fecha', models.DateField()),
                ('hora_entrada', models.TimeField()),
                ('hora_salida', models.TimeField()),
                ('empleado', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='asistencias', to='rrhh.empleado')),
            ],
            options={
                'verbose_name': 'Asistencia',
                'verbose_name_plural': 'Asistencias',
                'ordering': ['-fecha'],
            },
        ),
        migrations.CreateModel(
            name='Nomina',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('periodo', models.CharField(help_text="Ejemplo: 'Julio 2025'", max_length=50)),
                ('total', models.DecimalField(decimal_places=2, max_digits=14)),
                ('estado', models.CharField(choices=[('PENDIENTE', 'Pendiente'), ('PAGADA', 'Pagada'), ('CANCELADA', 'Cancelada')], default='PENDIENTE', max_length=10)),
                ('empleado', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='nominas', to='rrhh.empleado')),
            ],
            options={
                'verbose_name': 'Nómina',
                'verbose_name_plural': 'Nóminas',
                'ordering': ['-periodo'],
            },
        ),
        migrations.AddIndex(
            model_name='empleado',
            index=models.Index(fields=['empresa', 'nombre'], name='rrhh_emplea_empresa_30960a_idx'),
        ),
        migrations.AddIndex(
            model_name='asistencia',
            index=models.Index(fields=['empleado', 'fecha'], name='rrhh_asiste_emplead_72a5b8_idx'),
        ),
        migrations.AddIndex(
            model_name='nomina',
            index=models.Index(fields=['empleado', 'periodo'], name='rrhh_nomina_emplead_a511c4_idx'),
        ),
        migrations.AddIndex(
            model_name='nomina',
            index=models.Index(fields=['estado'], name='rrhh_nomina_estado_8abe47_idx'),
        ),
    ]



# --- /home/runner/workspace/rrhh/views/__init_.py ---





# === Archivo: documentos_combined.py ===

# --- /home/runner/workspace/documentos/__init__.py ---



# --- /home/runner/workspace/documentos/admin.py ---
from django.contrib import admin

# Register your models here.



# --- /home/runner/workspace/documentos/apps.py ---
from django.apps import AppConfig


class DocumentosConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'documentos'



# --- /home/runner/workspace/documentos/tests.py ---
from django.test import TestCase

# Create your tests here.



# --- /home/runner/workspace/documentos/models.py ---
# documentos/models.py

from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.utils import timezone


class DocumentoFiscal(models.Model):
    TIPO_DOCUMENTO_CHOICES = [
        ('CFDI', 'CFDI'),
        ('XML', 'XML'),
        ('PDF', 'PDF'),
        ('OTRO', 'Otro'),
    ]

    tipo_documento = models.CharField(
        max_length=10,
        choices=TIPO_DOCUMENTO_CHOICES,
        default='CFDI',
        help_text="Tipo de documento fiscal (CFDI, XML, PDF, etc.)"
    )
    content_type = models.ForeignKey(
        ContentType,
        on_delete=models.CASCADE,
        help_text="Tipo de modelo referenciado (venta, compra, asiento, etc.)"
    )
    object_id = models.PositiveIntegerField(
        help_text="ID de la entidad relacionada"
    )
    referencia = GenericForeignKey('content_type', 'object_id')

    archivo = models.FileField(
        upload_to='documentos_fiscales/%Y/%m/%d/',
        help_text="Archivo digital del documento (PDF, XML, etc.)"
    )
    fecha_emision = models.DateField(
        default=timezone.now,
        help_text="Fecha de emisión del documento"
    )

    class Meta:
        verbose_name = "Documento Fiscal"
        verbose_name_plural = "Documentos Fiscales"
        indexes = [
            models.Index(fields=['tipo_documento']),
            models.Index(fields=['content_type', 'object_id']),
        ]
        ordering = ['-fecha_emision']

    def __str__(self):
        return f"{self.get_tipo_documento_display()} - Ref: {self.referencia} - {self.fecha_emision}"



# --- /home/runner/workspace/documentos/migrations/__init__.py ---



# --- /home/runner/workspace/documentos/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('contenttypes', '0002_remove_content_type_name'),
    ]

    operations = [
        migrations.CreateModel(
            name='DocumentoFiscal',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('tipo_documento', models.CharField(choices=[('CFDI', 'CFDI'), ('XML', 'XML'), ('PDF', 'PDF'), ('OTRO', 'Otro')], default='CFDI', help_text='Tipo de documento fiscal (CFDI, XML, PDF, etc.)', max_length=10)),
                ('object_id', models.PositiveIntegerField(help_text='ID de la entidad relacionada')),
                ('archivo', models.FileField(help_text='Archivo digital del documento (PDF, XML, etc.)', upload_to='documentos_fiscales/%Y/%m/%d/')),
                ('fecha_emision', models.DateField(default=django.utils.timezone.now, help_text='Fecha de emisión del documento')),
                ('content_type', models.ForeignKey(help_text='Tipo de modelo referenciado (venta, compra, asiento, etc.)', on_delete=django.db.models.deletion.CASCADE, to='contenttypes.contenttype')),
            ],
            options={
                'verbose_name': 'Documento Fiscal',
                'verbose_name_plural': 'Documentos Fiscales',
                'ordering': ['-fecha_emision'],
                'indexes': [models.Index(fields=['tipo_documento'], name='documentos__tipo_do_1d0d20_idx'), models.Index(fields=['content_type', 'object_id'], name='documentos__content_0ded15_idx')],
            },
        ),
    ]



# --- /home/runner/workspace/documentos/views/__init_.py ---





# === Archivo: core_combined.py ===

# --- /home/runner/workspace/core/admin.py ---
from django.contrib import admin

# Register your models here.



# --- /home/runner/workspace/core/tests.py ---
from django.test import TestCase

# Create your tests here.



# --- /home/runner/workspace/core/signals.py ---
# core/signals.py

from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.utils.timezone import now
from core.models import Empresa
from django.contrib.auth import get_user_model

User = get_user_model()

@receiver(post_save, sender=Empresa)
def log_empresa_save(sender, instance, created, **kwargs):
    accion = "Creada" if created else "Actualizada"
    # Aquí puedes usar instance.modified_by si guardas usuario en el modelo Empresa
    # O dejar "desconocido" si no tienes
    usuario = getattr(instance, 'modified_by', None)
    usuario_str = usuario.username if usuario else 'desconocido'
    print(f"Empresa {accion}: {instance.razon_social} por usuario {usuario_str} en {now()}")

@receiver(post_delete, sender=Empresa)
def log_empresa_delete(sender, instance, **kwargs):
    print(f"Empresa Eliminada: {instance.razon_social} en {now()}")



# --- /home/runner/workspace/core/apps.py ---
# from django.apps import AppConfig


# class CoreConfig(AppConfig):
#     default_auto_field = 'django.db.models.BigAutoField'
#     name = 'core'
from django.apps import AppConfig

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

    def ready(self):
        # Importa signals para que se registren
        import core.signals


# --- /home/runner/workspace/core/__init__.py ---
# core/__init__.py

default_app_config = 'core.apps.CoreConfig'


# --- /home/runner/workspace/core/serializers.py ---
# core/serializers.py
from rest_framework import serializers
from core.models import Empresa, Sucursal
import re

class EmpresaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Empresa
        fields = '__all__'

    def validate_rfc(self, value):
        # Validación básica de formato RFC mexicano
        pattern = r'^([A-ZÑ&]{3,4}) ?-? ?(\d{2})(\d{2})(\d{2}) ?-? ?([A-Z\d]{3})$'
        if not re.match(pattern, value):
            raise serializers.ValidationError("El RFC no tiene un formato válido")
        # Validar que el RFC sea único
        if Empresa.objects.filter(rfc=value).exclude(id=self.instance.id if self.instance else None).exists():
            raise serializers.ValidationError("Este RFC ya está registrado")
        return value


class SucursalSerializer(serializers.ModelSerializer):
    class Meta:
        model = Sucursal
        fields = '__all__'

# from rest_framework import serializers
# from core.models import Empresa
# import re

# class EmpresaSerializer(serializers.ModelSerializer):
#     class Meta:
#         model = Empresa
#         fields = '__all__'

#     def validate_rfc(self, value):
#         # Validación básica de formato RFC mexicano
#         pattern = r'^([A-ZÑ&]{3,4}) ?-? ?(\d{2})(\d{2})(\d{2}) ?-? ?([A-Z\d]{3})$'
#         if not re.match(pattern, value):
#             raise serializers.ValidationError("El RFC no tiene un formato válido")
#         # Validar que el RFC sea único
#         if Empresa.objects.filter(rfc=value).exclude(id=self.instance.id if self.instance else None).exists():
#             raise serializers.ValidationError("Este RFC ya está registrado")
#         return value

#     def validate_razon_social(self, value):
#         # Evitar duplicados de razón social
#         if Empresa.objects.filter(razon_social__iexact=value).exclude(id=self.instance.id if self.instance else None).exists():
#             raise serializers.ValidationError("Esta razón social ya está registrada")
#         return value



# --- /home/runner/workspace/core/urls.py ---
# core/urls.py
from rest_framework.routers import DefaultRouter
from core.views import EmpresaViewSet, SucursalViewSet

router = DefaultRouter()
router.register(r'companies', EmpresaViewSet, basename='empresa')
router.register(r'branches', SucursalViewSet, basename='sucursal')


urlpatterns = router.urls


# --- /home/runner/workspace/core/filters.py ---
# core/filters.py

import django_filters
from core.models import Empresa, Sucursal


class EmpresaFilter(django_filters.FilterSet):
    nombre = django_filters.CharFilter(field_name='nombre', lookup_expr='icontains')
    rfc = django_filters.CharFilter(field_name='rfc', lookup_expr='icontains')
    regimen_fiscal = django_filters.CharFilter(field_name='regimen_fiscal', lookup_expr='icontains')
    creado_en__gte = django_filters.DateTimeFilter(field_name='creado_en', lookup_expr='gte')
    creado_en__lte = django_filters.DateTimeFilter(field_name='creado_en', lookup_expr='lte')

    class Meta:
        model = Empresa
        fields = ['nombre', 'rfc', 'regimen_fiscal', 'creado_en__gte', 'creado_en__lte']


class SucursalFilter(django_filters.FilterSet):
    nombre = django_filters.CharFilter(field_name='nombre', lookup_expr='icontains')
    empresa = django_filters.NumberFilter(field_name='empresa__id')
    creado_en__gte = django_filters.DateTimeFilter(field_name='creado_en', lookup_expr='gte')
    creado_en__lte = django_filters.DateTimeFilter(field_name='creado_en', lookup_expr='lte')

    class Meta:
        model = Sucursal
        fields = ['nombre', 'empresa', 'creado_en__gte', 'creado_en__lte']



# # core/filters.py
# from django_filters import rest_framework as filters
# from core.models import Empresa

# class EmpresaFilter(filters.FilterSet):
#     rfc = filters.CharFilter(field_name='rfc', lookup_expr='icontains')
#     nombre = filters.CharFilter(field_name='nombre', lookup_expr='icontains')

#     class Meta:
#         model = Empresa
#         fields = ['rfc', 'nombre']



# --- /home/runner/workspace/core/views.py ---
from rest_framework import viewsets, filters
from django_filters.rest_framework import DjangoFilterBackend
from core.models import Empresa, Sucursal
from core.serializers import EmpresaSerializer, SucursalSerializer
from rest_framework.permissions import IsAuthenticated
from accounts.permissions import IsSuperAdminOrEmpresaAdmin
from core.filters import EmpresaFilter, SucursalFilter
class EmpresaViewSet(viewsets.ModelViewSet):
    queryset = Empresa.objects.all()
    serializer_class = EmpresaSerializer
    permission_classes = [IsAuthenticated, IsSuperAdminOrEmpresaAdmin]

    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_class = EmpresaFilter  # usa filtro custom
  
    search_fields = ['nombre', 'rfc', 'domicilio_fiscal', 'regimen_fiscal']
    ordering_fields = ['nombre', 'creado_en', 'actualizado_en']
    ordering = ['nombre']




class SucursalViewSet(viewsets.ModelViewSet):
    queryset = Sucursal.objects.all()
    serializer_class = SucursalSerializer
    permission_classes = [IsAuthenticated, IsSuperAdminOrEmpresaAdmin]
    filterset_class = SucursalFilter

    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['empresa']
    search_fields = ['nombre', 'direccion']
    ordering_fields = ['nombre', 'creado_en']
    ordering = ['nombre']


# --- /home/runner/workspace/core/models.py ---
# core/models.py

from django.db import models
from django.utils import timezone


class Empresa(models.Model):
    nombre = models.CharField(max_length=150, unique=True)
    rfc = models.CharField(max_length=13, unique=True)  # RFC México: 12 o 13 caracteres
    domicilio_fiscal = models.TextField()
    regimen_fiscal = models.CharField(max_length=100)
    creado_en = models.DateTimeField(auto_now_add=True)
    actualizado_en = models.DateTimeField(auto_now=True)
    razon_social = models.CharField(max_length=255, blank=True, null=True)  # Añadido razon_social



    domicilio_calle = models.CharField(max_length=150)
    domicilio_num_ext = models.CharField(max_length=10, blank=True, null=True)
    domicilio_num_int = models.CharField(max_length=10, blank=True, null=True)
    domicilio_colonia = models.CharField(max_length=100)
    domicilio_municipio = models.CharField(max_length=100)
    domicilio_estado = models.CharField(max_length=100)
    domicilio_pais = models.CharField(max_length=50, default='MEX')
    domicilio_codigo_postal = models.CharField(max_length=10)

    def get_direccion_formateada(self):
        partes = [
            self.domicilio_calle,
            f"Ext. {self.domicilio_num_ext}" if self.domicilio_num_ext else None,
            f"Int. {self.domicilio_num_int}" if self.domicilio_num_int else None,
            self.domicilio_colonia,
            self.domicilio_municipio,
            self.domicilio_estado,
            self.domicilio_pais,
            self.domicilio_codigo_postal,
        ]
        # Eliminar None o vacíos y unir con coma
        return ", ".join(filter(None, partes))
    

    class Meta:
        verbose_name = "Empresa"
        verbose_name_plural = "Empresas"
        ordering = ['nombre']

    def __str__(self):
        return self.nombre


class Sucursal(models.Model):
    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE, related_name='sucursales')
    nombre = models.CharField(max_length=150)
    creado_en = models.DateTimeField(auto_now_add=True)
    actualizado_en = models.DateTimeField(auto_now=True)

    domicilio_calle = models.CharField(max_length=150)
    domicilio_num_ext = models.CharField(max_length=10, blank=True, null=True)
    domicilio_num_int = models.CharField(max_length=10, blank=True, null=True)
    domicilio_colonia = models.CharField(max_length=100)
    domicilio_municipio = models.CharField(max_length=100)
    domicilio_estado = models.CharField(max_length=100)
    domicilio_pais = models.CharField(max_length=50, default='MEX')
    domicilio_codigo_postal = models.CharField(max_length=10)

    def get_direccion_formateada(self):
        partes = [
            self.domicilio_calle,
            f"Ext. {self.domicilio_num_ext}" if self.domicilio_num_ext else None,
            f"Int. {self.domicilio_num_int}" if self.domicilio_num_int else None,
            self.domicilio_colonia,
            self.domicilio_municipio,
            self.domicilio_estado,
            self.domicilio_pais,
            self.domicilio_codigo_postal,
        ]
        # Eliminar None o vacíos y unir con coma
        return ", ".join(filter(None, partes))

    class Meta:
        verbose_name = "Sucursal"
        verbose_name_plural = "Sucursales"
        unique_together = ('empresa', 'nombre')
        ordering = ['empresa', 'nombre']
        indexes = [
            models.Index(fields=['empresa', 'nombre']),
        ]

    def __str__(self):
        return f"{self.nombre} ({self.empresa.nombre})"



# --- /home/runner/workspace/core/migrations/__init__.py ---



# --- /home/runner/workspace/core/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Empresa',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nombre', models.CharField(max_length=150, unique=True)),
                ('rfc', models.CharField(max_length=13, unique=True)),
                ('domicilio_fiscal', models.TextField()),
                ('regimen_fiscal', models.CharField(max_length=100)),
                ('creado_en', models.DateTimeField(auto_now_add=True)),
                ('actualizado_en', models.DateTimeField(auto_now=True)),
                ('razon_social', models.CharField(blank=True, max_length=255, null=True)),
                ('domicilio_calle', models.CharField(max_length=150)),
                ('domicilio_num_ext', models.CharField(blank=True, max_length=10, null=True)),
                ('domicilio_num_int', models.CharField(blank=True, max_length=10, null=True)),
                ('domicilio_colonia', models.CharField(max_length=100)),
                ('domicilio_municipio', models.CharField(max_length=100)),
                ('domicilio_estado', models.CharField(max_length=100)),
                ('domicilio_pais', models.CharField(default='MEX', max_length=50)),
                ('domicilio_codigo_postal', models.CharField(max_length=10)),
            ],
            options={
                'verbose_name': 'Empresa',
                'verbose_name_plural': 'Empresas',
                'ordering': ['nombre'],
            },
        ),
        migrations.CreateModel(
            name='Sucursal',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('nombre', models.CharField(max_length=150)),
                ('creado_en', models.DateTimeField(auto_now_add=True)),
                ('actualizado_en', models.DateTimeField(auto_now=True)),
                ('domicilio_calle', models.CharField(max_length=150)),
                ('domicilio_num_ext', models.CharField(blank=True, max_length=10, null=True)),
                ('domicilio_num_int', models.CharField(blank=True, max_length=10, null=True)),
                ('domicilio_colonia', models.CharField(max_length=100)),
                ('domicilio_municipio', models.CharField(max_length=100)),
                ('domicilio_estado', models.CharField(max_length=100)),
                ('domicilio_pais', models.CharField(default='MEX', max_length=50)),
                ('domicilio_codigo_postal', models.CharField(max_length=10)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='sucursales', to='core.empresa')),
            ],
            options={
                'verbose_name': 'Sucursal',
                'verbose_name_plural': 'Sucursales',
                'ordering': ['empresa', 'nombre'],
                'indexes': [models.Index(fields=['empresa', 'nombre'], name='core_sucurs_empresa_61cae1_idx')],
                'unique_together': {('empresa', 'nombre')},
            },
        ),
    ]



# --- /home/runner/workspace/core/middleware/auditoria.py ---
# core/middleware/auditoria.py

from accounts.signals import set_audit_user

class AuditoriaMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        if request.user.is_authenticated:
            set_audit_user(request.user)
        response = self.get_response(request)
        return response


# --- /home/runner/workspace/core/middleware/__init__.py ---



# --- /home/runner/workspace/core/api/__init__.py ---



# --- /home/runner/workspace/core/api/auth_viewset.py ---
from drf_spectacular.utils import extend_schema_view, extend_schema, OpenApiResponse
from rest_framework import viewsets

@extend_schema_view(
    post=extend_schema(
        summary="Login",
        description="Autenticación con JWT",
        responses={
            200: OpenApiResponse(description="Login exitoso"),
            400: OpenApiResponse(description="Datos inválidos"),
            401: OpenApiResponse(description="Credenciales incorrectas"),
            500: OpenApiResponse(description="Error interno"),
        },
    ),
    get=extend_schema(
        summary="Ver perfil",
        description="Datos del usuario autenticado",
        responses={
            200: OpenApiResponse(description="Datos del usuario"),
            401: OpenApiResponse(description="Token inválido o no enviado"),
        },
    ),
)
class AuthViewSet(viewsets.ViewSet):
    pass



# --- /home/runner/workspace/core/api/urls.py ---
from rest_framework.routers import DefaultRouter
from django.urls import path, include
from .auth_viewset import AuthViewSet

router = DefaultRouter()
router.register(r'auth', AuthViewSet, basename='auth')

urlpatterns = [
    path('', include(router.urls)),
]




# === Archivo: facturacion_combined.py ===

# --- /home/runner/workspace/facturacion/__init__.py ---



# --- /home/runner/workspace/facturacion/admin.py ---
from django.contrib import admin

# Register your models here.



# --- /home/runner/workspace/facturacion/apps.py ---
from django.apps import AppConfig


class FacturacionConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'facturacion'



# --- /home/runner/workspace/facturacion/tests.py ---
from django.test import TestCase

# Create your tests here.



# --- /home/runner/workspace/facturacion/models.py ---
from django.db import models
from core.models import Empresa
from ventas.models import Venta
from accounts.models import Usuario
from django.utils import timezone
from django.core.exceptions import ValidationError
from django.conf import settings

class TimbradoLog(models.Model):
    comprobante = models.ForeignKey('ComprobanteFiscal', on_delete=models.CASCADE, related_name='logs_timbrado')
    fecha_intento = models.DateTimeField(default=timezone.now)
    exito = models.BooleanField(default=False)
    mensaje_error = models.TextField(blank=True, null=True)
    uuid_obtenido = models.CharField(max_length=36, blank=True, null=True)
    facturama_id = models.CharField(max_length=100, blank=True, null=True)

    class Meta:
        ordering = ['-fecha_intento']

    def __str__(self):
        status = "Éxito" if self.exito else "Error"
        return f"{status} - {self.fecha_intento} - Comprobante {self.comprobante.id}"

class MetodoPagoChoices(models.TextChoices):
    PUE = 'PUE', 'Pago en una sola exhibición'
    PPD = 'PPD', 'Pago en parcialidades o diferido'

# Fuente oficial: Catálogo SAT c_FormaPago vigente al 2025
# https://www.sat.gob.mx/consultas/42930/catalogo-de-forma-de-pago
class FormaPagoChoices(models.TextChoices):
    EFECTIVO = '01', 'Efectivo'
    CHEQUE_NOMINATIVO = '02', 'Cheque nominativo'
    TRANSFERENCIA_ELECTRONICA = '03', 'Transferencia electrónica de fondos'
    TARJETA_CREDITO = '04', 'Tarjeta de crédito'
    MONEDERO_ELECTRONICO = '05', 'Monedero electrónico'
    DINERO_ELECTRONICO = '06', 'Dinero electrónico'
    VALES_DESPENSA = '08', 'Vales de despensa'
    DACION_EN_PAGO = '12', 'Dación en pago'
    PAGO_SUBROGACION = '13', 'Pago por subrogación'
    PAGO_CONSIGNACION = '14', 'Pago por consignación'
    CONDONACION = '15', 'Condonación'
    COMPENSACION = '17', 'Compensación'
    NOVACION = '23', 'Novación'
    CONFUSION = '24', 'Confusión'
    REMISION_DE_DEUDA = '25', 'Remisión de deuda'
    PRESCRIPCION_CADUCIDAD = '26', 'Prescripción o caducidad'
    SATISFACCION_ACREEDOR = '27', 'A satisfacción del acreedor'
    TARJETA_DEBITO = '28', 'Tarjeta de débito'
    TARJETA_SERVICIOS = '29', 'Tarjeta de servicios'
    APLICACION_ANTICIPOS = '30', 'Aplicación de anticipos'
    INTERMEDIARIO_PAGOS = '31', 'Intermediario de pagos'
    POR_DEFINIR = '99', 'Por definir'


class ComprobanteFiscal(models.Model):
    ESTADOS = [
        ('PENDIENTE', 'Pendiente'),
        ('TIMBRADO', 'Timbrado'),
        ('CANCELADO', 'Cancelado'),
        ('ERROR', 'Error'),
    ]
    
    TIPOS_COMPROBANTE = [
        ('FACTURA', 'Factura'),
        ('NOTA_CREDITO', 'Nota de Crédito'),
        ('RECIBO_NOMINA', 'Recibo de Nómina'),
        # Otros tipos CFDI
    ]

    reintentos_timbrado = models.PositiveIntegerField(default=0)
    max_reintentos = 3  # Puedes hacerlo campo o constante

    # Opcional: fecha del último intento
    fecha_ultimo_intento = models.DateTimeField(blank=True, null=True)


    empresa = models.ForeignKey(Empresa, on_delete=models.CASCADE)
    venta = models.OneToOneField(Venta, on_delete=models.CASCADE)
    uuid = models.CharField(max_length=36, unique=True, blank=True, null=True)  # UUID timbrado
    # xml = models.TextField(blank=True, null=True)  # XML CFDI completo
    xml = models.FileField(upload_to="cfdi_xmls/", null=True, blank=True)
    pdf = models.FileField(upload_to='cfdi_pdfs/', blank=True, null=True)  # PDF factura
    fecha_timbrado = models.DateTimeField(blank=True, null=True)
    estado = models.CharField(max_length=20, choices=ESTADOS, default='PENDIENTE')  
    error_mensaje = models.TextField(blank=True, null=True)
    tipo = models.CharField(max_length=20, choices=TIPOS_COMPROBANTE, default='FACTURA')
    serie = models.CharField(max_length=10, blank=True, null=True)
    folio = models.PositiveIntegerField(null=True, blank=True)
    correo_enviado = models.BooleanField(default=False)  # NUEVO CAMPO
    estado_sat = models.CharField(max_length=50, blank=True, null=True)
    fecha_estado_sat = models.DateTimeField(blank=True, null=True)
    acuse_cancelacion_xml = models.FileField(upload_to='cfdi_acuses/', null=True, blank=True)
    metodo_pago = models.CharField(
        max_length=3,
        choices=MetodoPagoChoices.choices,
        blank=True,
        null=True,
        help_text="Método de pago según catálogo SAT (PUE, PPD)"
    )
    forma_pago = models.CharField(
        max_length=3,
        choices=FormaPagoChoices.choices,
        blank=True,
        null=True,
        help_text="Forma de pago clave SAT (Ej: 01 Efectivo, 03 Transferencia)"
    )
    exportacion = models.CharField(
        max_length=2, 
        default='01', 
        choices=[
            ('01', 'No aplica'),
            ('02', 'Definitiva'),
            ('03', 'Temporal'),
        ],
        help_text="Exportación según el catálogo SAT c_Exportacion"
    )
    facturama_id = models.CharField(max_length=100, blank=True, null=True)

    motivo_cancelacion = models.CharField(max_length=3, blank=True, null=True, choices=[
        ('01', 'Comprobante emitido con errores con relación'),
        ('02', 'Comprobante emitido con errores sin relación'),
        ('03', 'No se llevó a cabo la operación'),
        ('04', 'Operación nominativa relacionada en la factura global'),
    ])
    sustitucion_uuid = models.CharField(max_length=36, blank=True, null=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def esta_timbrado(self):
        return self.estado == 'TIMBRADO' and self.uuid is not None

    def clean(self):
        if self.estado == 'TIMBRADO':
            if not self.metodo_pago:
                raise ValidationError({'metodo_pago': "Requerido al estar timbrado."})
            if not self.forma_pago:
                raise ValidationError({'forma_pago': "Requerido al estar timbrado."})
            if not self.empresa or not self.empresa.rfc:
                raise ValidationError({'empresa': "La empresa debe tener RFC."})
            if not self.venta.cliente.rfc:
                raise ValidationError({'venta': "El cliente debe tener RFC para timbrar."})

    class Meta:
      indexes = [
          models.Index(fields=['estado']),
          models.Index(fields=['tipo']),
      ]

  
    def __str__(self):
      venta_id = self.venta.id if self.venta else 'N/A'
      return f"{self.get_tipo_display()} {self.uuid or 'Sin UUID'} - Venta {venta_id}"

class EnvioCorreoCFDI(models.Model):
    comprobante = models.ForeignKey(ComprobanteFiscal, on_delete=models.CASCADE, related_name='envios')
    destinatario = models.EmailField()
    enviado_por = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True)
    fecha_envio = models.DateTimeField(auto_now_add=True)


# --- /home/runner/workspace/facturacion/urls.py ---
from django.urls import path, include
from rest_framework.routers import DefaultRouter
# from facturacion.views.comprobantes import TimbrarComprobanteAPIView
# from facturacion.views.comprobantes import ComprobanteFiscalViewSet
from facturacion.views.lista_comprobantes import ComprobanteFiscalListView
from facturacion.views.cancelar_factura import cancelar_cfdi
from facturacion.views.validaciones import validar_datos_fiscales_view
# from facturacion.utils.validaciones import validar_datos_fiscales
from facturacion.views.timbrado import TimbradoLogListView
from facturacion.views.vista_previa_factura import vista_previa_pdf
from facturacion.views.vista_previa_xml import vista_previa_xml
from facturacion.views.reintentar_timbrado import reintentar_timbrado
from facturacion.views.comprobante_fiscal import ComprobanteFiscalViewSet
from facturacion.views.acuses import descargar_acuse_cancelacion
from facturacion.views.reenviar_email_cfdi import reenviar_email_cfdi
from facturacion.views.envio_cfdi_viewset import EnvioCorreoCFDIViewSet

router = DefaultRouter()
# router.register(r'comprobantes', ComprobanteFiscalViewSet, basename='comprobante')
router.register(r'comprobantes', ComprobanteFiscalViewSet, basename='comprobantes')
router.register(r'envios', EnvioCorreoCFDIViewSet, basename='envios-cfdi')

urlpatterns = [
    path('', include(router.urls)),
    # path("comprobantes/<int:pk>/timbrar/", TimbrarComprobanteAPIView.as_view(), name="timbrar-comprobante"),
    path('comprobantes/', ComprobanteFiscalListView.as_view(), name='comprobante-fiscal-list'),
    path('cancelar-cfdi/<str:uuid>/', cancelar_cfdi, name='cancelar_cfdi'),
    path('validar/<int:venta_id>/', validar_datos_fiscales_view, name='validar-datos-fiscales'),
    path('comprobantes/<int:comprobante_id>/logs-timbrado/', TimbradoLogListView.as_view(), name='logs-timbrado'),
    path('comprobantes/<int:pk>/ver-pdf/', vista_previa_pdf, name='vista_previa_pdf'),
    path('comprobantes/<int:pk>/vista-previa-xml/', vista_previa_xml, name='vista_previa_xml'),
    path('comprobantes/<int:comprobante_id>/reintentar/', reintentar_timbrado, name='reintentar_timbrado'),
    path('comprobantes/<uuid:uuid>/acuse-cancelacion/', descargar_acuse_cancelacion, name='descargar_acuse_cancelacion'),
    path('comprobantes/<str:uuid>/reenviar-email/', reenviar_email_cfdi, name='reenviar_email_cfdi'),
]






# --- /home/runner/workspace/facturacion/filters.py ---
import django_filters
from facturacion.models import ComprobanteFiscal
import django_filters
from facturacion.models import EnvioCorreoCFDI

class EnvioCorreoCFDIFilter(django_filters.FilterSet):
    destinatario = django_filters.CharFilter(lookup_expr='icontains')
    enviado_por = django_filters.NumberFilter()
    comprobante = django_filters.NumberFilter()
    fecha_envio_inicio = django_filters.DateTimeFilter(field_name='fecha_envio', lookup_expr='gte')
    fecha_envio_fin = django_filters.DateTimeFilter(field_name='fecha_envio', lookup_expr='lte')

    class Meta:
        model = EnvioCorreoCFDI
        fields = ['destinatario', 'enviado_por', 'comprobante']

class ComprobanteFiscalFilter(django_filters.FilterSet):
    uuid = django_filters.CharFilter(lookup_expr='icontains')
    estado = django_filters.CharFilter()
    tipo = django_filters.CharFilter()
    serie = django_filters.CharFilter(lookup_expr='icontains')
    folio = django_filters.NumberFilter()
    venta__cliente__nombre = django_filters.CharFilter(field_name='venta__cliente__nombre', lookup_expr='icontains')
    empresa = django_filters.NumberFilter()

    fecha_timbrado_inicio = django_filters.DateFilter(field_name='fecha_timbrado', lookup_expr='gte')
    fecha_timbrado_fin = django_filters.DateFilter(field_name='fecha_timbrado', lookup_expr='lte')

    class Meta:
        model = ComprobanteFiscal
        fields = [
            'uuid', 'estado', 'tipo', 'serie', 'folio', 'empresa', 'venta__cliente__nombre']


# --- /home/runner/workspace/facturacion/migrations/__init__.py ---



# --- /home/runner/workspace/facturacion/migrations/0001_initial.py ---
# Generated by Django 5.2.4 on 2025-07-30 21:47

import django.db.models.deletion
import django.utils.timezone
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('core', '0001_initial'),
        ('ventas', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ComprobanteFiscal',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('reintentos_timbrado', models.PositiveIntegerField(default=0)),
                ('fecha_ultimo_intento', models.DateTimeField(blank=True, null=True)),
                ('uuid', models.CharField(blank=True, max_length=36, null=True, unique=True)),
                ('xml', models.FileField(blank=True, null=True, upload_to='cfdi_xmls/')),
                ('pdf', models.FileField(blank=True, null=True, upload_to='cfdi_pdfs/')),
                ('fecha_timbrado', models.DateTimeField(blank=True, null=True)),
                ('estado', models.CharField(choices=[('PENDIENTE', 'Pendiente'), ('TIMBRADO', 'Timbrado'), ('CANCELADO', 'Cancelado'), ('ERROR', 'Error')], default='PENDIENTE', max_length=20)),
                ('error_mensaje', models.TextField(blank=True, null=True)),
                ('tipo', models.CharField(choices=[('FACTURA', 'Factura'), ('NOTA_CREDITO', 'Nota de Crédito'), ('RECIBO_NOMINA', 'Recibo de Nómina')], default='FACTURA', max_length=20)),
                ('serie', models.CharField(blank=True, max_length=10, null=True)),
                ('folio', models.PositiveIntegerField(blank=True, null=True)),
                ('correo_enviado', models.BooleanField(default=False)),
                ('estado_sat', models.CharField(blank=True, max_length=50, null=True)),
                ('fecha_estado_sat', models.DateTimeField(blank=True, null=True)),
                ('acuse_cancelacion_xml', models.FileField(blank=True, null=True, upload_to='cfdi_acuses/')),
                ('metodo_pago', models.CharField(blank=True, choices=[('PUE', 'Pago en una sola exhibición'), ('PPD', 'Pago en parcialidades o diferido')], help_text='Método de pago según catálogo SAT (PUE, PPD)', max_length=3, null=True)),
                ('forma_pago', models.CharField(blank=True, choices=[('01', 'Efectivo'), ('02', 'Cheque nominativo'), ('03', 'Transferencia electrónica de fondos'), ('04', 'Tarjeta de crédito'), ('05', 'Monedero electrónico'), ('06', 'Dinero electrónico'), ('08', 'Vales de despensa'), ('12', 'Dación en pago'), ('13', 'Pago por subrogación'), ('14', 'Pago por consignación'), ('15', 'Condonación'), ('17', 'Compensación'), ('23', 'Novación'), ('24', 'Confusión'), ('25', 'Remisión de deuda'), ('26', 'Prescripción o caducidad'), ('27', 'A satisfacción del acreedor'), ('28', 'Tarjeta de débito'), ('29', 'Tarjeta de servicios'), ('30', 'Aplicación de anticipos'), ('31', 'Intermediario de pagos'), ('99', 'Por definir')], help_text='Forma de pago clave SAT (Ej: 01 Efectivo, 03 Transferencia)', max_length=3, null=True)),
                ('exportacion', models.CharField(choices=[('01', 'No aplica'), ('02', 'Definitiva'), ('03', 'Temporal')], default='01', help_text='Exportación según el catálogo SAT c_Exportacion', max_length=2)),
                ('facturama_id', models.CharField(blank=True, max_length=100, null=True)),
                ('motivo_cancelacion', models.CharField(blank=True, choices=[('01', 'Comprobante emitido con errores con relación'), ('02', 'Comprobante emitido con errores sin relación'), ('03', 'No se llevó a cabo la operación'), ('04', 'Operación nominativa relacionada en la factura global')], max_length=3, null=True)),
                ('sustitucion_uuid', models.CharField(blank=True, max_length=36, null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('empresa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='core.empresa')),
                ('venta', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='ventas.venta')),
            ],
        ),
        migrations.CreateModel(
            name='EnvioCorreoCFDI',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('destinatario', models.EmailField(max_length=254)),
                ('fecha_envio', models.DateTimeField(auto_now_add=True)),
                ('comprobante', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='envios', to='facturacion.comprobantefiscal')),
                ('enviado_por', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL)),
            ],
        ),
        migrations.CreateModel(
            name='TimbradoLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('fecha_intento', models.DateTimeField(default=django.utils.timezone.now)),
                ('exito', models.BooleanField(default=False)),
                ('mensaje_error', models.TextField(blank=True, null=True)),
                ('uuid_obtenido', models.CharField(blank=True, max_length=36, null=True)),
                ('facturama_id', models.CharField(blank=True, max_length=100, null=True)),
                ('comprobante', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='logs_timbrado', to='facturacion.comprobantefiscal')),
            ],
            options={
                'ordering': ['-fecha_intento'],
            },
        ),
        migrations.AddIndex(
            model_name='comprobantefiscal',
            index=models.Index(fields=['estado'], name='facturacion_estado_4c1711_idx'),
        ),
        migrations.AddIndex(
            model_name='comprobantefiscal',
            index=models.Index(fields=['tipo'], name='facturacion_tipo_904fe7_idx'),
        ),
    ]



# --- /home/runner/workspace/facturacion/serializers/__init__.py ---



# --- /home/runner/workspace/facturacion/serializers/timbrado.py ---
from rest_framework import serializers
from facturacion.models import TimbradoLog

class TimbradoLogSerializer(serializers.ModelSerializer):
    class Meta:
        model = TimbradoLog
        fields = ['id', 'fecha_intento', 'exito', 'mensaje_error', 'uuid_obtenido', 'facturama_id']


# --- /home/runner/workspace/facturacion/serializers/comprobante_fiscal.py ---
# serializers.py

from rest_framework import serializers
from facturacion.models import ComprobanteFiscal
from ventas.models import Venta
from accounts.models import Usuario
from core.models import Empresa


class EmpresaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Empresa
        fields = ['id', 'nombre', 'rfc']  # Personaliza los campos que quieres incluir

class VentaSerializer(serializers.ModelSerializer):
    cliente_nombre = serializers.CharField(source='cliente.nombre', read_only=True)

    class Meta:
        model = Venta
        fields = ['id', 'cliente_nombre']  # Personaliza los campos que quieres incluir

class ComprobanteFiscalSerializer(serializers.ModelSerializer):
    empresa = EmpresaSerializer(read_only=True)  # Relación anidada
    venta = VentaSerializer(read_only=True)  # Relación anidada
    metodo_pago_display = serializers.CharField(source='get_metodo_pago_display', read_only=True)
    forma_pago_display = serializers.CharField(source='get_forma_pago_display', read_only=True)

    class Meta:
        model = ComprobanteFiscal
        fields = '__all__'  # También incluye todos los campos del modelo



# --- /home/runner/workspace/facturacion/serializers/envio_cfdi.py ---
from facturacion.models import EnvioCorreoCFDI
from rest_framework import serializers

# facturacion/serializers.py
class EnvioCorreoCFDISerializer(serializers.ModelSerializer):
    class Meta:
        model = EnvioCorreoCFDI
        fields = '__all__'


# --- /home/runner/workspace/facturacion/views/__init__.py ---



# --- /home/runner/workspace/facturacion/views/validaciones.py ---
# facturacion/views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from facturacion.utils.validaciones import validar_datos_fiscales
from facturacion.models import ComprobanteFiscal

@api_view(['GET'])
def validar_datos_fiscales_view(request, venta_id):
    try:
        comprobante = ComprobanteFiscal.objects.get(venta_id=venta_id)
    except ComprobanteFiscal.DoesNotExist:
        return Response({"error": "Comprobante no encontrado para esta venta"}, status=404)

    resultado = validar_datos_fiscales(comprobante)
    if resultado["ok"]:
        return Response({"ok": True, "mensaje": "Todos los datos fiscales son válidos"})
    else:
        return Response({"ok": False, "errores": resultado["errores"]}, status=400)



# --- /home/runner/workspace/facturacion/views/timbrado.py ---
from rest_framework import generics
from rest_framework.permissions import IsAuthenticated
from facturacion.models import ComprobanteFiscal, TimbradoLog
from facturacion.serializers.timbrado import TimbradoLogSerializer
from rest_framework.exceptions import NotFound

class TimbradoLogListView(generics.ListAPIView):
    serializer_class = TimbradoLogSerializer
    permission_classes = [IsAuthenticated]  # o déjalo abierto si quieres

    def get_queryset(self):
        comprobante_id = self.kwargs.get('comprobante_id')
        try:
            comprobante = ComprobanteFiscal.objects.get(id=comprobante_id)
        except ComprobanteFiscal.DoesNotExist:
            raise NotFound("Comprobante no encontrado")

        return comprobante.logs_timbrado.all()



# --- /home/runner/workspace/facturacion/views/vista_previa_factura.py ---
from django.http import FileResponse, Http404
from rest_framework.decorators import api_view, permission_classes
from rest_framework import permissions
from facturacion.models import ComprobanteFiscal

@api_view(['GET'])
@permission_classes([permissions.IsAuthenticated])
def vista_previa_pdf(request, pk):
    try:
        comprobante = ComprobanteFiscal.objects.get(pk=pk)
        if not comprobante.pdf or not comprobante.pdf.path:
            raise Http404("PDF no disponible.")
        return FileResponse(open(comprobante.pdf.path, 'rb'), content_type='application/pdf')
    except ComprobanteFiscal.DoesNotExist:
        raise Http404("Comprobante no encontrado.")


# --- /home/runner/workspace/facturacion/views/reintentar_timbrado.py ---
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from facturacion.models import ComprobanteFiscal
from facturacion.services.timbrado_helpers import intentar_timbrado_comprobante
from rest_framework import status

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def reintentar_timbrado(request, comprobante_id):
    try:
        comprobante = ComprobanteFiscal.objects.get(id=comprobante_id)
    except ComprobanteFiscal.DoesNotExist:
        return Response({"error": "Comprobante no encontrado."}, status=status.HTTP_404_NOT_FOUND)

    if comprobante.estado == 'TIMBRADO':
        return Response({"error": "Comprobante ya está timbrado."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        intentar_timbrado_comprobante(comprobante)
        return Response({"message": "Timbrado exitoso.", "uuid": comprobante.uuid})
    except Exception as e:
        return Response({"error": f"Error al timbrar: {str(e)}"}, status=status.HTTP_400_BAD_REQUEST)



# --- /home/runner/workspace/facturacion/views/vista_previa_xml.py ---
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status
from django.http import HttpResponse, Http404
from ventas.utils import generar_xml_desde_comprobante
from facturacion.models import ComprobanteFiscal


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def vista_previa_xml(request, pk):
    try:
        comprobante = ComprobanteFiscal.objects.get(pk=pk)

        if comprobante.estado == 'TIMBRADO':
            return Response({"error": "Este comprobante ya está timbrado."}, status=status.HTTP_400_BAD_REQUEST)

        xml_bytes = generar_xml_desde_comprobante(comprobante)

        return HttpResponse(
            xml_bytes,
            content_type='application/xml'
        )

    except ComprobanteFiscal.DoesNotExist:
        raise Http404("Comprobante no encontrado.")
    except Exception as e:
        return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



# --- /home/runner/workspace/facturacion/views/comprobantes.py ---
# views/comprobantes.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.shortcuts import get_object_or_404

from facturacion.models import ComprobanteFiscal
from facturacion.utils.build_facturama_payload import build_facturama_payload
from facturacion.services.facturama import FacturamaService

class TimbrarComprobanteAPIView(APIView):
    def post(self, request, pk):
        comprobante = get_object_or_404(ComprobanteFiscal, pk=pk)
        payload = build_facturama_payload(comprobante)

        try:
            respuesta = FacturamaService.timbrar_comprobante(payload)
            # Aquí podrías guardar en el comprobante la respuesta o UUID recibido
            return Response(respuesta, status=status.HTTP_201_CREATED)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)


# --- /home/runner/workspace/facturacion/views/lista_comprobantes.py ---
# views.py

from rest_framework import generics
from facturacion.models import ComprobanteFiscal
from facturacion.serializers.comprobante_fiscal import ComprobanteFiscalSerializer
from rest_framework.permissions import IsAuthenticated

class ComprobanteFiscalListView(generics.ListAPIView):
    queryset = ComprobanteFiscal.objects.all()
    serializer_class = ComprobanteFiscalSerializer
    permission_classes = [IsAuthenticated]

    # Filtros, puedes adaptarlo a tus necesidades
    def get_queryset(self):
        queryset = super().get_queryset()
        # Aquí puedes agregar filtros, por ejemplo, por estado o tipo de comprobante
        estado = self.request.query_params.get('estado', None)
        if estado:
            queryset = queryset.filter(estado=estado)
        return queryset



# --- /home/runner/workspace/facturacion/views/acuses.py ---
# facturacion/views/acuses.py

from django.http import FileResponse, JsonResponse
from facturacion.models import ComprobanteFiscal
import os

def descargar_acuse_cancelacion(request, uuid):
    try:
        cfdi = ComprobanteFiscal.objects.get(uuid=uuid)
    except ComprobanteFiscal.DoesNotExist:
        return JsonResponse({"error": "Comprobante no encontrado"}, status=404)

    if not cfdi.acuse_cancelacion_xml:
        return JsonResponse({"error": "No hay acuse de cancelación disponible"}, status=404)

    if not os.path.exists(cfdi.acuse_cancelacion_xml.path):
        return JsonResponse({"error": "Archivo de acuse no encontrado"}, status=404)

    return FileResponse(open(cfdi.acuse_cancelacion_xml.path, 'rb'), content_type='application/xml')



# --- /home/runner/workspace/facturacion/views/cancelar_factura.py ---
# facturacion/views/cancelar_factura.py

import requests
import base64
from django.utils.timezone import now
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.files.base import ContentFile
from facturacion.models import ComprobanteFiscal
from django.conf import settings

@csrf_exempt
def cancelar_cfdi(request, uuid):
    if request.method != 'POST':
        return JsonResponse({"error": "Método no permitido"}, status=405)

    try:
        cfdi = ComprobanteFiscal.objects.get(uuid=uuid)
    except ComprobanteFiscal.DoesNotExist:
        return JsonResponse({"error": "CFDI no encontrado"}, status=404)

    if cfdi.estado == 'CANCELADO':
        return JsonResponse({"message": "El CFDI ya fue cancelado"}, status=400)

    # Validar que tengas el ID de Facturama (no UUID)
    factura_id = getattr(cfdi, 'facturama_id', None)
    if not factura_id:
        return JsonResponse({"error": "No se encontró el ID de Facturama en el comprobante."}, status=400)

    # Parámetros requeridos
    motive = cfdi.motivo_cancelacion or "02"
    uuid_replacement = cfdi.sustitucion_uuid or ""
    cancel_type = "issued"

    # Autenticación básica
    api_key = f'{settings.FACTURAMA_USER}:{settings.FACTURAMA_PASSWORD}'
    api_key_encoded = base64.b64encode(api_key.encode()).decode()
    headers = {
        "Authorization": f"Basic {api_key_encoded}",
        "Content-Type": "application/json"
    }

    url = f'https://apisandbox.facturama.mx/cfdi/{factura_id}?type={cancel_type}&motive={motive}&uuidReplacement={uuid_replacement}'
    response = requests.delete(url, headers=headers)

    if response.status_code == 200:
        data = response.json()

        cfdi.estado = 'CANCELADO'
        cfdi.fecha_cancelacion = now()

        # Si hay acuse XML, guárdalo en disco
        acuse_b64 = data.get("AcuseXmlBase64")
        if acuse_b64:
            acuse_bytes = base64.b64decode(acuse_b64)
            filename = f"acuse_{cfdi.uuid}.xml"
            cfdi.acuse_cancelacion_xml.save(filename, ContentFile(acuse_bytes))

        cfdi.save()

        return JsonResponse({
            "message": "CFDI cancelado correctamente",
            "status": data.get("Status"),
            "uuid": data.get("Uuid"),
            "acuse_xml": bool(acuse_b64)
        })

    try:
        detalles = response.json()
    except Exception:
        detalles = response.text or {}

    return JsonResponse({
        "error": "Error al cancelar CFDI",
        "status_code": response.status_code,
        "detalles": detalles
    }, status=400)

# import requests
# import base64
# from django.utils.timezone import now
# from django.http import JsonResponse
# from django.views.decorators.csrf import csrf_exempt
# from facturacion.models import ComprobanteFiscal
# from django.conf import settings
# from django.views.decorators.csrf import csrf_exempt

# # facturacion/views.py

# @csrf_exempt
# def cancelar_cfdi(request, uuid):
#     try:
#         cfdi = ComprobanteFiscal.objects.get(uuid=uuid)
#     except ComprobanteFiscal.DoesNotExist:
#         return JsonResponse({"error": "CFDI no encontrado"}, status=404)

#     if cfdi.estado == 'CANCELADO':
#         return JsonResponse({"message": "El CFDI ya fue cancelado"}, status=400)

#     # Validar que tengas el ID de Facturama (no UUID)
#     factura_id = getattr(cfdi, 'facturama_id', None)
#     if not factura_id:
#         return JsonResponse({"error": "No se encontró el ID de Facturama en el comprobante."}, status=400)

#     # Parámetros requeridos
#     motive = cfdi.motivo_cancelacion or "02"
#     uuid_replacement = cfdi.sustitucion_uuid or ""
#     cancel_type = "issued"  # o "Received" dependiendo del rol; normalmente "Issued"

#     # Autenticación básica
#     api_key = f'{settings.FACTURAMA_USER}:{settings.FACTURAMA_PASSWORD}'
#     api_key_encoded = base64.b64encode(api_key.encode()).decode()
#     headers = {
#         "Authorization": f"Basic {api_key_encoded}",
#         "Content-Type": "application/json"
#     }

#     url = f'https://apisandbox.facturama.mx/cfdi/{factura_id}?type={cancel_type}&motive={motive}&uuidReplacement={uuid_replacement}'

#     response = requests.delete(url, headers=headers)

#     if response.status_code == 200:
#         cfdi.estado = 'CANCELADO'
#         cfdi.fecha_cancelacion = now()
#         cfdi.save()
#         return JsonResponse({"message": "CFDI cancelado correctamente"})
#     else:
#         try:
#             detalles = response.json()
#         except Exception:
#             detalles = response.text or {}
#         return JsonResponse({
#             "error": "Error al cancelar CFDI",
#             "status_code": response.status_code,
#             "detalles": detalles
#         }, status=400)




# --- /home/runner/workspace/facturacion/views/comprobante_fiscal.py ---
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.utils import timezone

from facturacion.models import ComprobanteFiscal
from facturacion.serializers.comprobante_fiscal import ComprobanteFiscalSerializer
from facturacion.services.consultar_estado_cfdi import consultar_estado_cfdi

from rest_framework import filters
from django_filters.rest_framework import DjangoFilterBackend
from facturacion.filters import ComprobanteFiscalFilter  # si lo pones en un archivo filters.py

class ComprobanteFiscalViewSet(viewsets.ModelViewSet):
    queryset = ComprobanteFiscal.objects.all()
    serializer_class = ComprobanteFiscalSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_class = ComprobanteFiscalFilter  # Usamos el FilterSet personalizado

    @action(detail=True, methods=["get"])
    def actualizar_estado_sat(self, request, pk=None):
        comprobante = self.get_object()

        if not comprobante.esta_timbrado():
            return Response({"error": "El comprobante no está timbrado."}, status=status.HTTP_400_BAD_REQUEST)

        try:
            resultado = consultar_estado_cfdi(
                uuid=comprobante.uuid,
                issuer_rfc=comprobante.empresa.rfc,
                receiver_rfc=comprobante.venta.cliente.rfc,
                total=comprobante.venta.total
            )

            comprobante.estado_sat = resultado.get("Estado")
            comprobante.fecha_estado_sat = timezone.now()
            comprobante.save(update_fields=["estado_sat", "fecha_estado_sat"])

            return Response({
                "uuid": comprobante.uuid,
                "estado_sat": comprobante.estado_sat,
                "fecha_estado_sat": comprobante.fecha_estado_sat,
            })

        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



# --- /home/runner/workspace/facturacion/views/envio_cfdi_viewset.py ---
# facturacion/views/envio_cfdi_viewset.py
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from facturacion.serializers.envio_cfdi import EnvioCorreoCFDISerializer
from facturacion.models import EnvioCorreoCFDI
from facturacion.filters import EnvioCorreoCFDIFilter
from rest_framework import filters

from django_filters.rest_framework import DjangoFilterBackend

class EnvioCorreoCFDIViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = EnvioCorreoCFDI.objects.all().select_related("comprobante", "enviado_por")
    serializer_class = EnvioCorreoCFDISerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_class = EnvioCorreoCFDIFilter
    search_fields = ['destinatario', 'comprobante__uuid', 'enviado_por__username']
    ordering_fields = ['fecha_envio']
    ordering = ['-fecha_envio']


# class EnvioCorreoCFDIViewSet(viewsets.ReadOnlyModelViewSet):
#     queryset = EnvioCorreoCFDI.objects.all().select_related("comprobante", "enviado_por")
#     serializer_class = EnvioCorreoCFDISerializer
#     permission_classes = [IsAuthenticated]



# --- /home/runner/workspace/facturacion/views/reenviar_email_cfdi.py ---
from rest_framework.decorators import api_view, authentication_classes, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework_simplejwt.authentication import JWTAuthentication
from rest_framework.response import Response
from rest_framework import status

from facturacion.models import ComprobanteFiscal, EnvioCorreoCFDI
from facturacion.utils.enviar_correo import enviar_cfdi_por_correo
from django.contrib.auth import get_user_model
from django.core.validators import validate_email
from django.core.exceptions import ValidationError

Usuario = get_user_model()

def obtener_usuario_sistema():
    return Usuario.objects.filter(username='sistema').first()

def es_email_valido(email):
    try:
        validate_email(email)
        return True
    except ValidationError:
        return False

@api_view(['POST'])
@authentication_classes([JWTAuthentication])
@permission_classes([IsAuthenticated])
def reenviar_email_cfdi(request, uuid):
    try:
        comprobante = ComprobanteFiscal.objects.select_related('venta__cliente').get(uuid=uuid)
    except ComprobanteFiscal.DoesNotExist:
        return Response({"error": "Comprobante no encontrado"}, status=404)

    if comprobante.estado == 'CANCELADO':
        return Response({"error": "El comprobante ya fue cancelado y no puede ser reenviado."}, status=400)

    if not comprobante.xml or not comprobante.pdf:
        return Response({"error": "No se puede reenviar: faltan archivos PDF o XML"}, status=400)

    cliente_email = comprobante.venta.cliente.correo
    copia_email = "yaview.lomeli@gmail.com"
    errores = []

    enviado_por = request.user if request and request.user.is_authenticated else obtener_usuario_sistema()

    if es_email_valido(cliente_email):
        try:
            enviar_cfdi_por_correo(cliente_email, comprobante)
            EnvioCorreoCFDI.objects.create(
                comprobante=comprobante,
                destinatario=cliente_email,
                enviado_por=enviado_por
            )
        except Exception as e:
            errores.append(f"Error al enviar a cliente: {str(e)}")
    else:
        errores.append("Correo del cliente inválido.")

    if es_email_valido(copia_email):
        try:
            enviar_cfdi_por_correo(copia_email, comprobante)
            EnvioCorreoCFDI.objects.create(
                comprobante=comprobante,
                destinatario=copia_email,
                enviado_por=enviado_por
            )
        except Exception as e:
            errores.append(f"Error al enviar a copia: {str(e)}")

    if errores:
        return Response({
            "message": "Reenvío incompleto",
            "errores": errores
        }, status=207)

    return Response({"message": "Correo reenviado correctamente"}, status=200)

# from rest_framework.decorators import api_view, authentication_classes, permission_classes
# from rest_framework.permissions import IsAuthenticated
# from rest_framework_simplejwt.authentication import JWTAuthentication
# from rest_framework.response import Response
# from rest_framework import status

# from facturacion.models import ComprobanteFiscal, EnvioCorreoCFDI
# from facturacion.utils.enviar_correo import enviar_cfdi_por_correo
# from django.contrib.auth import get_user_model
# import re

# Usuario = get_user_model()

# def obtener_usuario_sistema():
#     return Usuario.objects.filter(username='sistema').first()

# def es_email_valido(correo):
#     return bool(re.match(r"[^@]+@[^@]+\.[^@]+", correo))


# @api_view(['POST'])
# @authentication_classes([JWTAuthentication])
# @permission_classes([IsAuthenticated])
# def reenviar_email_cfdi(request, uuid):
#     try:
#         comprobante = ComprobanteFiscal.objects.select_related('venta__cliente').get(uuid=uuid)
#     except ComprobanteFiscal.DoesNotExist:
#         return Response({"error": "Comprobante no encontrado"}, status=404)

#     if comprobante.estado == 'CANCELADO':
#         return Response({"error": "El comprobante ya fue cancelado y no puede ser reenviado."}, status=400)

#     if not comprobante.xml or not comprobante.pdf:
#         return Response({"error": "No se puede reenviar: faltan archivos PDF o XML"}, status=400)

#     cliente_email = comprobante.venta.cliente.correo
#     copia_email = "yaview.lomeli@gmail.com"
#     errores = []

#     if es_email_valido(cliente_email):
#         try:
#             enviar_cfdi_por_correo(cliente_email, comprobante)
#             EnvioCorreoCFDI.objects.create(
#                 comprobante=comprobante,
#                 destinatario=cliente_email,
#                 enviado_por=request.user
#             )
#         except Exception as e:
#             errores.append(f"Error al enviar a cliente: {str(e)}")
#     else:
#         errores.append("Correo del cliente inválido.")

#     if es_email_valido(copia_email):
#         try:
#             enviar_cfdi_por_correo(copia_email, comprobante)
#             EnvioCorreoCFDI.objects.create(
#                 comprobante=comprobante,
#                 destinatario=copia_email,
#                 enviado_por=request.user
#             )
#         except Exception as e:
#             errores.append(f"Error al enviar a copia: {str(e)}")

#     if errores:
#         return Response({
#             "message": "Reenvío incompleto",
#             "errores": errores
#         }, status=207)

#     return Response({"message": "Correo reenviado correctamente"}, status=200)



# --- /home/runner/workspace/facturacion/services/facturama.py ---
# services/facturama.py
# from django.conf import Settings
from django.conf import settings   # correcto
import requests
from requests.auth import HTTPBasicAuth

# FACTURAMA_API_URL = "https://api.facturama.mx/3/cfdi"  # Endpoint para timbrar
FACTURAMA_API_URL = settings.FACTURAMA_API_URL
FACTURAMA_USER = settings.FACTURAMA_USER  # Aquí va el RFC o usuario Facturama
FACTURAMA_PASSWORD = settings.FACTURAMA_PASSWORD  # Aquí va la contraseña/token Facturama

class FacturamaService:
    @staticmethod
    def timbrar_comprobante(payload: dict):
        url = FACTURAMA_API_URL
        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json",
        }

        response = requests.post(
            url,
            json=payload,
            auth=HTTPBasicAuth(FACTURAMA_USER, FACTURAMA_PASSWORD),
            headers=headers,
            timeout=30,
        )

        return FacturamaService.handle_response(response)

    @staticmethod
    def handle_response(response):
        if response.status_code == 201:
            # Timbrado exitoso
            return response.json()
        else:
            # Algo falló, puedes loggear o levantar excepción
            raise Exception(
                f"Error al timbrar: {response.status_code} - {response.text}"
            )


    # https://apisandbox.facturama.mx/api/Cfdi/xml/issued/4kxSOfZWU95PfTaUF4xmnw2/


    @staticmethod
    def obtener_pdf_por_id(factura_id):
        url = f"https://apisandbox.facturama.mx/api/Cfdi/pdf/issued/{factura_id}/"
        headers = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
        }
        print(f"DEBUG: Descargando PDF desde: {url}")
        response = requests.get(url, auth=(FACTURAMA_USER, FACTURAMA_PASSWORD), headers=headers)
        print(f"DEBUG: Respuesta PDF - Status: {response.status_code}")
        response.raise_for_status()
        
        # La respuesta es un JSON con el contenido en base64
        response_json = response.json()
        print(f"DEBUG: JSON response keys: {response_json.keys()}")
        
        content_base64 = response_json.get('Content')
        if not content_base64:
            raise Exception("No se encontró el campo 'Content' en la respuesta del PDF")
        
        # Decodificar el contenido base64
        import base64
        pdf_content = base64.b64decode(content_base64)
        print(f"DEBUG: PDF decodificado, tamaño: {len(pdf_content)} bytes")
        return pdf_content

    @staticmethod
    def obtener_xml_por_id(factura_id):
        url = f"https://apisandbox.facturama.mx/api/Cfdi/xml/issued/{factura_id}/"
        headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }
        print(f"DEBUG: Descargando XML desde: {url}")
        response = requests.get(url, auth=(FACTURAMA_USER, FACTURAMA_PASSWORD), headers=headers)
        print(f"DEBUG: Respuesta XML - Status: {response.status_code}")
        response.raise_for_status()
        
        # La respuesta es un JSON con el contenido en base64
        response_json = response.json()
        print(f"DEBUG: JSON response keys: {response_json.keys()}")
        
        content_base64 = response_json.get('Content')
        if not content_base64:
            raise Exception("No se encontró el campo 'Content' en la respuesta del XML")
        
        # Decodificar el contenido base64
        import base64
        xml_content = base64.b64decode(content_base64)
        print(f"DEBUG: XML decodificado, tamaño: {len(xml_content)} bytes")
        return xml_content


    # @staticmethod
    # def obtener_pdf_por_id(factura_id):
    #     url = f"https://apisandbox.facturama.mx/3/cfdi/{factura_id}/"
    #     headers = {
    #         'Content-Type': 'application/json',
    #     }
    #     response = requests.get(url, auth=(FACTURAMA_USER, FACTURAMA_PASSWORD), headers=headers)
    #     response.raise_for_status()
    #     return response.content

    # @staticmethod
    # def obtener_xml_por_id(factura_id):
    #     url = f"https://apisandbox.facturama.mx/3/cfdi/{factura_id}/"
    #     headers = {
    #         'Accept': 'application/xml',
    #     }
    #     response = requests.get(url, auth=(FACTURAMA_USER, FACTURAMA_PASSWORD), headers=headers)
    #     response.raise_for_status()
    #     return response.content


# --- /home/runner/workspace/facturacion/services/consultar_estado_cfdi.py ---
import requests
from django.conf import settings

def consultar_estado_cfdi(uuid: str, issuer_rfc: str, receiver_rfc: str, total: float) -> dict:
    url = f"https://apisandbox.facturama.mx/cfdi/status"
    headers = {
        "Authorization": f"Basic {settings.FACTURAMA_CREDENTIALS}"
    }
    params = {
        "uuid": uuid,
        "issuerRfc": issuer_rfc,
        "receiverRfc": receiver_rfc,
        "total": f"{total:.2f}"  # asegura formato decimal con dos decimales
    }
    
    response = requests.get(url, headers=headers, params=params)
    
    if response.status_code == 200:
        return response.json()
    else:
        raise Exception(f"Error al consultar estado CFDI: {response.text}")


# --- /home/runner/workspace/facturacion/services/timbrado_helpers.py ---
from django.utils import timezone
from facturacion.models import ComprobanteFiscal
from facturacion.services.facturama import FacturamaService
from facturacion.utils.build_facturama_payload import build_facturama_payload
from facturacion.utils.guardar_archivo_base64 import guardar_archivo_base64
from facturacion.utils.descargar_archivo_por_id import  descargar_archivo_por_id
from facturacion.utils.validaciones import validar_datos_fiscales
from facturacion.utils.enviar_correo import enviar_cfdi_por_correo
import re


from django.utils import timezone
from facturacion.models import ComprobanteFiscal, TimbradoLog
from facturacion.services.facturama import FacturamaService
from facturacion.utils.build_facturama_payload import build_facturama_payload
from facturacion.utils.guardar_archivo_base64 import guardar_archivo_base64
from facturacion.utils.descargar_archivo_por_id import descargar_archivo_por_id
from facturacion.utils.validaciones import validar_datos_fiscales
from facturacion.models import EnvioCorreoCFDI
from django.contrib.auth import get_user_model
Usuario = get_user_model()

def obtener_usuario_sistema():
    return Usuario.objects.filter(username='sistema').first()
    

def intentar_timbrado_comprobante(comprobante: ComprobanteFiscal, request=None, max_reintentos=3):

    # Sincronizar método y forma de pago desde venta
    comprobante.metodo_pago = comprobante.venta.metodo_pago or "PUE"
    comprobante.forma_pago = comprobante.venta.forma_pago or "01"
    comprobante.save()

    errores = validar_datos_fiscales(comprobante)
    if not errores["ok"]:
        raise Exception(f"Errores fiscales: {errores['errores']}")

    if comprobante.estado == 'TIMBRADO':
        return comprobante  # Ya está timbrado

    if comprobante.reintentos_timbrado >= max_reintentos:
        raise Exception(f"Máximo de {max_reintentos} reintentos alcanzado para el comprobante {comprobante.id}")

    payload = build_facturama_payload(comprobante)

    try:
        respuesta = FacturamaService.timbrar_comprobante(payload)

        uuid = respuesta.get('Complement', {}).get('TaxStamp', {}).get('Uuid')
        factura_id = respuesta.get('Id')

        comprobante.uuid = uuid
        comprobante.facturama_id = factura_id
        comprobante.estado = 'TIMBRADO'
        comprobante.fecha_timbrado = timezone.now()
        comprobante.error_mensaje = None
        comprobante.reintentos_timbrado += 1
        comprobante.fecha_ultimo_intento = timezone.now()

        xml_base64 = respuesta.get('Xml')
        if xml_base64:
            guardar_archivo_base64(xml_base64, comprobante, tipo='xml')
        elif factura_id:
            descargar_archivo_por_id(factura_id, comprobante, formato='xml')

        pdf_base64 = respuesta.get('Pdf')
        if pdf_base64:
            guardar_archivo_base64(pdf_base64, comprobante, tipo='pdf')
        elif factura_id:
            descargar_archivo_por_id(factura_id, comprobante, formato='pdf')

        comprobante.save()

        # Guardar registro de log de éxito
        TimbradoLog.objects.create(
            comprobante=comprobante,
            fecha_intento=timezone.now(),
            exito=True,
            mensaje_error=None,
            uuid_obtenido=uuid,
            facturama_id=factura_id,
        )

        # Enviar correo con CFDI adjunto
        try:
            cliente_email = comprobante.venta.cliente.correo
            cliente_email_2 = "yaview.lomeli@gmail.com"
            enviado_por = (
                request.user if request and hasattr(request, 'user') and request.user.is_authenticated
                else obtener_usuario_sistema()
            )

            if cliente_email:
                print(comprobante)
                enviar_cfdi_por_correo(cliente_email, comprobante)
                EnvioCorreoCFDI.objects.create(
                    comprobante=comprobante,
                    destinatario=cliente_email,
                    enviado_por=enviado_por
                )

            if cliente_email_2:
                enviar_cfdi_por_correo(cliente_email_2, comprobante)
                EnvioCorreoCFDI.objects.create(
                    comprobante=comprobante,
                    destinatario=cliente_email_2,
                    enviado_por=enviado_por
                )
                

        except Exception as e:
            # Solo loguea el error, no interrumpas el flujo
            print(f"Error enviando correo: {e}")

        return comprobante

    except Exception as e:
        comprobante.estado = 'ERROR'
        comprobante.error_mensaje = str(e)
        comprobante.reintentos_timbrado += 1
        comprobante.fecha_ultimo_intento = timezone.now()
        comprobante.save()

        # Guardar registro de log de error
        TimbradoLog.objects.create(
            comprobante=comprobante,
            fecha_intento=timezone.now(),
            exito=False,
            mensaje_error=str(e),
            uuid_obtenido=None,
            facturama_id=None,
        )

        raise e



# --- /home/runner/workspace/facturacion/utils/__init__.py ---



# --- /home/runner/workspace/facturacion/utils/guardar_archivo_base64.py ---
import base64
from django.core.files.base import ContentFile


def guardar_archivo_base64(base64_str, comprobante, tipo='xml'):
    """
    Guarda un archivo base64 (XML o PDF) en el campo del comprobante correspondiente.
    """
    try:
        decoded_data = base64.b64decode(base64_str)

        if tipo == 'xml':
            comprobante.xml.save(f'cfdi_{comprobante.id}.xml', ContentFile(decoded_data), save=False)
        elif tipo == 'pdf':
            comprobante.pdf.save(f'cfdi_{comprobante.id}.pdf', ContentFile(decoded_data), save=False)
        else:
            raise ValueError("Tipo de archivo no soportado")

    except Exception as e:
        raise Exception(f"Error al guardar archivo {tipo} desde base64: {str(e)}")



# --- /home/runner/workspace/facturacion/utils/descargar_archivo_por_id.py ---
from django.core.files.base import ContentFile
from facturacion.services.facturama import FacturamaService


def descargar_archivo_por_id(factura_id, comprobante, formato='xml'):
    """
    Descarga el XML o PDF desde Facturama usando el ID de la factura.
    """
    try:
        if formato == 'xml':
            archivo_data = FacturamaService.obtener_xml_por_id(factura_id)
            comprobante.xml.save(f'cfdi_{comprobante.id}.xml', ContentFile(archivo_data), save=False)

        elif formato == 'pdf':
            archivo_data = FacturamaService.obtener_pdf_por_id(factura_id)
            comprobante.pdf.save(f'cfdi_{comprobante.id}.pdf', ContentFile(archivo_data), save=False)

        else:
            raise ValueError("Formato no soportado (solo 'xml' o 'pdf')")

    except Exception as e:
        raise Exception(f"Error al descargar archivo {formato} por ID: {str(e)}")



# --- /home/runner/workspace/facturacion/utils/facturama_helpers.py ---
def tipo_cfdi_desde_tipo_comprobante(tipo):
  """
  Convierte el tipo interno del comprobante ('FACTURA', 'NOTA_CREDITO', etc.)
  al tipo de CFDI que Facturama espera: 'I', 'E', 'N', etc.
  """
  mapeo = {
      "FACTURA": "I",           # Ingreso
      "NOTA_CREDITO": "E",      # Egreso
      "RECIBO_NOMINA": "N",     # Nómina
  }
  return mapeo.get(tipo, "I")  # Valor por defecto: Ingreso



# --- /home/runner/workspace/facturacion/utils/build_facturama_payload.py ---
# utils/build_facturama_payload.py

from decimal import Decimal
from facturacion.utils.facturama_helpers import tipo_cfdi_desde_tipo_comprobante
import json  # para impresión legible

def build_facturama_payload(comprobante):
    venta = comprobante.venta
    cliente = venta.cliente
    empresa = comprobante.empresa

    items = []
    for detalle in venta.detalles.all():
        producto = detalle.producto
        cantidad = Decimal(detalle.cantidad)
        precio_unitario = Decimal(detalle.precio_unitario)
        subtotal = cantidad * precio_unitario
        tasa_iva = Decimal("0.16")
        iva = subtotal * tasa_iva
        total = subtotal + iva

        items.append({
            "ProductCode": getattr(producto.clave_sat.clave, 'clave', "01010101"),
            "IdentificationNumber": producto.codigo or "",
            "Description": producto.nombre,
            "Unit": getattr(producto.unidad_medida, 'descripcion', "Unidad"),
            "UnitCode": getattr(producto.unidad_medida, 'clave', "H87"),
            "UnitPrice": float(precio_unitario),
            "Quantity": float(cantidad),
            "Subtotal": float(subtotal),
            "Discount": 0.0,  # Mejora: incluir detalle.descuento si aplica
            "Total": float(total),
            "TaxObject": "02",  # Gravado
            "Taxes": [
                {
                    "Total": float(iva),
                    "Name": "IVA",
                    "Base": float(subtotal),
                    "Rate": float(tasa_iva),
                    "Type": "Traslado",
                    "IsRetention": False,
                }
            ],
        })

    payload = {
        "Serie": comprobante.serie or "A",
        "Folio": comprobante.folio or "100",
        "CfdiType": tipo_cfdi_desde_tipo_comprobante(comprobante.tipo),
        "ExpeditionPlace": empresa.domicilio_codigo_postal or "00000",
        "PaymentConditions": venta.condiciones_pago or "Contado",
        "PaymentMethod": venta.metodo_pago or "PUE",  # Pago en una sola exhibición
        "PaymentForm": venta.forma_pago or "01",      # Efectivo
        "Currency": venta.moneda or "MXN",
        "Exportation": "01",  # No aplica exportación
        "Issuer": {
            "FiscalRegime": str(empresa.regimen_fiscal) if empresa.regimen_fiscal else "601",
            "Rfc": empresa.rfc,
            "Name": empresa.razon_social,
        },
        "Receiver": {
            "Rfc": cliente.rfc,
            "Name": cliente.nombre_completo,
            "CfdiUse": cliente.uso_cfdi or "S01",  # Por definir
            "TaxZipCode": cliente.direccion_codigo_postal or empresa.domicilio_codigo_postal,
            "FiscalRegime": int(cliente.regimen_fiscal) if cliente.regimen_fiscal else 601,
        },
        "Items": items,
    }
    # print("Payload que se enviará a Facturama:")
    # print(json.dumps(payload, indent=4, ensure_ascii=False))


    return payload



# --- /home/runner/workspace/facturacion/utils/validaciones.py ---
# facturacion/utils/validaciones.py

import re

def validar_rfc(rfc):
    return bool(re.match(r"^[A-ZÑ&]{3,4}\d{6}[A-Z0-9]{3}$", rfc or ""))

def validar_clave_unidad(clave):
    return bool(re.match(r"^[A-Z0-9]{1,5}$", clave or ""))

def validar_datos_fiscales(comprobante):
    errores = {}

    cliente = comprobante.venta.cliente
    empresa = comprobante.empresa
    detalles = comprobante.venta.detalles.all()

    # Cliente
    cliente_errores = {}
    if not validar_rfc(cliente.rfc):
        cliente_errores['rfc'] = "RFC inválido o ausente"
    if not cliente.direccion_codigo_postal:
        cliente_errores['direccion_codigo_postal'] = "Código postal faltante"
    if not cliente.uso_cfdi:
        cliente_errores['uso_cfdi'] = "Uso CFDI no definido"

    if cliente_errores:
        errores['cliente'] = cliente_errores

    # Empresa
    empresa_errores = {}
    if not empresa.rfc or not validar_rfc(empresa.rfc):
        empresa_errores['rfc'] = "RFC inválido o ausente"
    if not empresa.regimen_fiscal:
        empresa_errores['regimen_fiscal'] = "Régimen fiscal faltante"

    if empresa_errores:
        errores['empresa'] = empresa_errores

    # Productos
    productos_errores = []
    for d in detalles:
        p = d.producto
        if not p.clave_sat:
            productos_errores.append({
                "id": p.id,
                "error": "Producto sin clave SAT"
            })
        if not p.unidad_medida or not validar_clave_unidad(p.unidad_medida.clave):
            productos_errores.append({
                "id": p.id,
                "error": "Unidad de medida ausente o inválida"
            })

    if productos_errores:
        errores['productos'] = productos_errores

    # Método y forma de pago
    if not comprobante.metodo_pago:
        errores['metodo_pago'] = "Método de pago no definido"
    if not comprobante.forma_pago:
        errores['forma_pago'] = "Forma de pago no definida"

    if errores:
        return {"ok": False, "errores": errores}
    return {"ok": True}



# --- /home/runner/workspace/facturacion/utils/enviar_correo.py ---
from django.core.mail import EmailMessage
from django.conf import settings
import os
import logging

logger = logging.getLogger(__name__)



def enviar_cfdi_por_correo(email_destino, comprobante):
    """
    Envía el CFDI (PDF + XML) como adjuntos al email del cliente.
    """
    if not email_destino:
        raise ValueError("El cliente no tiene un correo electrónico válido.")

    asunto = f"Factura electrónica {comprobante.serie or ''}-{comprobante.folio or ''}".strip("- ")
    cuerpo = (
        f"Estimado cliente,\n\nAdjuntamos su factura electrónica.\n\n"
        f"Gracias por su preferencia.\n\nSaludos,\nNova ERP"
    )

    email = EmailMessage(
        asunto,
        cuerpo,
        settings.DEFAULT_FROM_EMAIL,
        [email_destino],
    )

    try:
        # Adjuntar PDF leyendo contenido directamente
        if comprobante.pdf and comprobante.pdf.path and os.path.exists(comprobante.pdf.path):
            with open(comprobante.pdf.path, 'rb') as f:
                email.attach(f'cfdi_{comprobante.id}.pdf', f.read(), 'application/pdf')
        else:
            logger.warning(f"Archivo PDF no encontrado para comprobante {comprobante.id}")

        # Adjuntar XML leyendo contenido directamente
        if comprobante.xml and comprobante.xml.path and os.path.exists(comprobante.xml.path):
            with open(comprobante.xml.path, 'rb') as f:
                email.attach(f'cfdi_{comprobante.id}.xml', f.read(), 'application/xml')
        else:
            logger.warning(f"Archivo XML no encontrado para comprobante {comprobante.id}")

        email.send(fail_silently=False)
        logger.info(f"Correo enviado a {email_destino} con comprobante {comprobante.id}")
        

        # 🔥 Marcar como enviado si todo fue bien
        comprobante.correo_enviado = True
        comprobante.save(update_fields=['correo_enviado'])

    except Exception as e:
        logger.error(f"Error enviando correo con comprobante {comprobante.id}: {e}")
        raise



# --- /home/runner/workspace/facturacion/management/commands/actualizar_estado_cfdi.py ---
from django.core.management.base import BaseCommand
from facturacion.models import ComprobanteFiscal
from facturacion.services.consultar_estado_cfdi import consultar_estado_cfdi
from django.utils import timezone

class Command(BaseCommand):
    help = 'Consulta el estado SAT de los CFDIs timbrados y actualiza el modelo'

    def handle(self, *args, **options):
        comprobantes = ComprobanteFiscal.objects.filter(estado='TIMBRADO', uuid__isnull=False)

        for c in comprobantes:
            try:
                if not (c.empresa.rfc and c.venta.cliente.rfc and c.venta.total):
                    self.stdout.write(f"⚠️ Saltando comprobante {c.id}: datos incompletos.")
                    continue

                estado_info = consultar_estado_cfdi(
                    uuid=c.uuid,
                    issuer_rfc=c.empresa.rfc,
                    receiver_rfc=c.venta.cliente.rfc,
                    total=c.venta.total
                )

                estado_sat = estado_info.get("Estado", "SIN RESPUESTA")
                c.estado_sat = estado_sat
                c.fecha_estado_sat = timezone.now()
                c.save(update_fields=["estado_sat", "fecha_estado_sat"])

                self.stdout.write(f"✅ {c.uuid} → Estado SAT: {estado_sat}")

            except Exception as e:
                mensaje_error = str(e)
                if "pruebacfdiconsultaqr.cloudapp.net" in mensaje_error:
                    # Error típico del sandbox de Facturama
                    c.estado_sat = "NO DISPONIBLE (SANDBOX)"
                    c.fecha_estado_sat = timezone.now()
                    c.save(update_fields=["estado_sat", "fecha_estado_sat"])
                    self.stdout.write(f"🟡 {c.uuid} → Estado no disponible en sandbox.")
                else:
                    self.stderr.write(f"[ERROR] {c.uuid}: {mensaje_error}")
# from django.core.management.base import BaseCommand
# from facturacion.models import ComprobanteFiscal
# from facturacion.services.consultar_estado_cfdi import consultar_estado_cfdi
# from django.utils import timezone

# class Command(BaseCommand):
#     help = 'Consulta el estado SAT de los CFDIs timbrados y actualiza el modelo'

#     def handle(self, *args, **options):
#         comprobantes = ComprobanteFiscal.objects.filter(estado='TIMBRADO', uuid__isnull=False)
    
#         for c in comprobantes:
#             try:
#                 if not (c.empresa.rfc and c.venta.cliente.rfc and c.venta.total):
#                     self.stdout.write(f"⚠️ Saltando comprobante {c.id}: datos incompletos.")
#                     continue
    
#                 estado_info = consultar_estado_cfdi(
#                     uuid=c.uuid,
#                     issuer_rfc=c.empresa.rfc,
#                     receiver_rfc=c.venta.cliente.rfc,
#                     total=c.venta.total
#                 )
    
#                 c.estado_sat = estado_info.get("Estado")
#                 c.fecha_estado_sat = timezone.now()
#                 c.save(update_fields=["estado_sat", "fecha_estado_sat"])
    
#                 self.stdout.write(f"✅ {c.uuid} → Estado SAT: {c.estado_sat}")
    
#             except Exception as e:
#                 self.stderr.write(f"[ERROR] {c.uuid}: {str(e)}")

   



